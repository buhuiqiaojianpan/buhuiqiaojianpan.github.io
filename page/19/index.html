<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/19/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-html+css+js+ts/4-set+map" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/04/10/html+css+js+ts/4-set+map/" class="article-date">
  <time class="dt-published" datetime="2018-04-10T03:21:26.000Z" itemprop="datePublished">2018-04-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/04/10/html+css+js+ts/4-set+map/">ES6 Set-Map</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <ul>
<li><code>Set</code> 和 <code>Map</code> 主要的应用场景在于 <strong>数据重组</strong> 和 <strong>数据储存</strong></li>
<li><code>Set</code> 是一种叫做<strong>集合</strong>的数据结构，Map 是一种叫做<strong>字典</strong>的数据结构</li>
</ul>
<h3 id="1-集合（Set）"><a href="#1-集合（Set）" class="headerlink" title="1. 集合（Set）"></a>1. 集合（Set）</h3><blockquote>
<p><code>ES6</code> 新增的一种新的数据结构，类似于数组，但成员是唯一且无序的，没有重复的值。</p>
</blockquote>
<p><strong>Set 本身是一种构造函数，用来生成 Set 数据结构。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new Set([iterable])</span><br></pre></td></tr></table></figure>

<p>举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const s = new Set()</span><br><span class="line">[1, 2, 3, 4, 3, 2, 1].forEach(x =&gt; s.add(x))</span><br><span class="line"></span><br><span class="line">for (let i of s) &#123;</span><br><span class="line">    console.log(i)	// 1 2 3 4</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 去重数组的重复对象</span><br><span class="line">let arr = [1, 2, 3, 2, 1, 1]</span><br><span class="line">[... new Set(arr)]	// [1, 2, 3]</span><br></pre></td></tr></table></figure>

<p>Set 对象允许你储存任何类型的唯一值，无论是原始值或者是对象引用。</p>
<p>向 Set 加入值的时候，不会发生类型转换，所以<code>5</code>和<code>&quot;5&quot;</code>是两个不同的值。Set 内部判断两个值是否不同，使用的算法叫做“Same-value-zero equality”，它类似于<strong>精确相等</strong>运算符（<code>===</code>），主要的区别是 <strong>Set 认为<code>NaN</code>等于自身，而精确相等运算符认为<code>NaN</code>不等于自身。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let set = new Set();</span><br><span class="line">let a = NaN;</span><br><span class="line">let b = NaN;</span><br><span class="line">set.add(a);</span><br><span class="line">set.add(b);</span><br><span class="line">set // Set &#123;NaN&#125;</span><br><span class="line"></span><br><span class="line">let set1 = new Set()</span><br><span class="line">set1.add(5)</span><br><span class="line">set1.add(&#x27;5&#x27;)</span><br><span class="line">console.log([...set1])	// [5, &quot;5&quot;]</span><br></pre></td></tr></table></figure>

<ul>
<li><p>Set 实例属性</p>
<ul>
<li><p>constructor： 构造函数</p>
</li>
<li><p>size：元素数量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let set = new Set([1, 2, 3, 2, 1])</span><br><span class="line"></span><br><span class="line">console.log(set.length)	// undefined</span><br><span class="line">console.log(set.size)	// 3</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>Set 实例方法</p>
<ul>
<li><p>操作方法</p>
<ul>
<li><p>add(value)：新增，相当于 array里的push</p>
</li>
<li><p>delete(value)：存在即删除集合中value</p>
</li>
<li><p>has(value)：判断集合中是否存在 value</p>
</li>
<li><p>clear()：清空集合</p>
<hr>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let set = new Set()</span><br><span class="line">set.add(1).add(2).add(1)</span><br><span class="line"></span><br><span class="line">set.has(1)	// true</span><br><span class="line">set.has(3)	// false</span><br><span class="line">set.delete(1)	</span><br><span class="line">set.has(1)	// false</span><br></pre></td></tr></table></figure>

<p><code>Array.from</code> 方法可以将 Set 结构转为数组</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const items = new Set([1, 2, 3, 2])</span><br><span class="line">const array = Array.from(items)</span><br><span class="line">console.log(array)	// [1, 2, 3]</span><br><span class="line">// 或</span><br><span class="line">const arr = [...items]</span><br><span class="line">console.log(arr)	// [1, 2, 3]</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>遍历方法（遍历顺序为插入顺序）</p>
<ul>
<li><p>keys()：返回一个包含集合中所有键的迭代器</p>
</li>
<li><p>values()：返回一个包含集合中所有值得迭代器</p>
</li>
<li><p>entries()：返回一个包含Set对象中所有元素得键值对迭代器</p>
</li>
<li><p>forEach(callbackFn, thisArg)：用于对集合成员执行callbackFn操作，如果提供了 thisArg 参数，回调中的this会是这个参数，<strong>没有返回值</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">let set = new Set([1, 2, 3])</span><br><span class="line">console.log(set.keys())	// SetIterator &#123;1, 2, 3&#125;</span><br><span class="line">console.log(set.values())	// SetIterator &#123;1, 2, 3&#125;</span><br><span class="line">console.log(set.entries())	// SetIterator &#123;1, 2, 3&#125;</span><br><span class="line"></span><br><span class="line">for (let item of set.keys()) &#123;</span><br><span class="line">  console.log(item);</span><br><span class="line">&#125;	// 1	2	 3</span><br><span class="line">for (let item of set.entries()) &#123;</span><br><span class="line">  console.log(item);</span><br><span class="line">&#125;	// [1, 1]	[2, 2]	[3, 3]</span><br><span class="line"></span><br><span class="line">set.forEach((value, key) =&gt;  &#123;</span><br><span class="line">    console.log(key + &#x27; : &#x27; + value)</span><br><span class="line">&#125;)	// 1 : 1	2 : 2		3 : 3</span><br><span class="line">console.log([...set])	// [1, 2, 3]</span><br></pre></td></tr></table></figure>

<p>Set 可默认遍历，默认迭代器生成函数是 values() 方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set.prototype[Symbol.iterator] === Set.prototype.values	// true</span><br></pre></td></tr></table></figure>

<p>所以， Set可以使用 map、filter 方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let set = new Set([1, 2, 3])</span><br><span class="line">set = new Set([...set].map(item =&gt; item * 2))</span><br><span class="line">console.log([...set])	// [2, 4, 6]</span><br><span class="line"></span><br><span class="line">set = new Set([...set].filter(item =&gt; (item &gt;= 4)))</span><br><span class="line">console.log([...set])	//[4, 6]</span><br></pre></td></tr></table></figure>

<p>因此，Set 很容易实现交集（Intersect）、并集（Union）、差集（Difference）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let set1 = new Set([1, 2, 3])</span><br><span class="line">let set2 = new Set([4, 3, 2])</span><br><span class="line"></span><br><span class="line">let intersect = new Set([...set1].filter(value =&gt; set2.has(value)))</span><br><span class="line">let union = new Set([...set1, ...set2])</span><br><span class="line">let difference = new Set([...set1].filter(value =&gt; !set2.has(value)))</span><br><span class="line"></span><br><span class="line">console.log(intersect)	// Set &#123;2, 3&#125;</span><br><span class="line">console.log(union)		// Set &#123;1, 2, 3, 4&#125;</span><br><span class="line">console.log(difference)	// Set &#123;1&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-WeakSet"><a href="#2-WeakSet" class="headerlink" title="2. WeakSet"></a>2. WeakSet</h3><p>WeakSet 对象允许你将<strong>弱引用对象</strong>储存在一个集合中</p>
<p>WeakSet 与 Set 的区别：</p>
<ul>
<li>WeakSet 只能储存对象引用，不能存放值，而 Set 对象都可以</li>
<li>WeakSet 对象中储存的对象值都是被弱引用的，即垃圾回收机制不考虑 WeakSet 对该对象的应用，如果没有其他的变量或属性引用这个对象值，则这个对象将会被垃圾回收掉（不考虑该对象还存在于 WeakSet 中），所以，WeakSet 对象里有多少个成员元素，取决于垃圾回收机制有没有运行，运行前后成员个数可能不一致，遍历结束之后，有的成员可能取不到了（被垃圾回收了），WeakSet 对象是无法被遍历的（ES6 规定 WeakSet 不可遍历），也没有办法拿到它包含的所有元素</li>
</ul>
<p>属性：</p>
<ul>
<li><p>constructor：构造函数，任何一个具有 Iterable 接口的对象，都可以作参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const arr = [[1, 2], [3, 4]]</span><br><span class="line">const weakset = new WeakSet(arr)</span><br><span class="line">console.log(weakset)</span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="https://user-images.githubusercontent.com/19721451/54000905-3d36c980-4184-11e9-9ccf-0f13bc6dd414.png" alt="2019-03-08 9 24 34"></p>
<p>方法：</p>
<ul>
<li>add(value)：在WeakSet 对象中添加一个元素value</li>
<li>has(value)：判断 WeakSet 对象中是否包含value</li>
<li>delete(value)：删除元素 value</li>
<li>clear()：清空所有元素，<strong>注意该方法已废弃</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var ws = new WeakSet()</span><br><span class="line">var obj = &#123;&#125;</span><br><span class="line">var foo = &#123;&#125;</span><br><span class="line"></span><br><span class="line">ws.add(window)</span><br><span class="line">ws.add(obj)</span><br><span class="line"></span><br><span class="line">ws.has(window)	// true</span><br><span class="line">ws.has(foo)	// false</span><br><span class="line"></span><br><span class="line">ws.delete(window)	// true</span><br><span class="line">ws.has(window)	// false</span><br></pre></td></tr></table></figure>

<h3 id="3-字典（Map）"><a href="#3-字典（Map）" class="headerlink" title="3. 字典（Map）"></a>3. 字典（Map）</h3><p>集合 与 字典 的区别：</p>
<ul>
<li>共同点：集合、字典 可以储存不重复的值</li>
<li>不同点：集合 是以 [value, value]的形式储存元素，字典 是以 [key, value] 的形式储存</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const m = new Map()</span><br><span class="line">const o = &#123;p: &#x27;haha&#x27;&#125;</span><br><span class="line">m.set(o, &#x27;content&#x27;)</span><br><span class="line">m.get(o)	// content</span><br><span class="line"></span><br><span class="line">m.has(o)	// true</span><br><span class="line">m.delete(o)	// true</span><br><span class="line">m.has(o)	// false</span><br></pre></td></tr></table></figure>

<p><strong>任何具有 Iterator 接口、且每个成员都是一个双元素的数组的数据结构</strong>都可以当作<code>Map</code>构造函数的参数，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const set = new Set([</span><br><span class="line">  [&#x27;foo&#x27;, 1],</span><br><span class="line">  [&#x27;bar&#x27;, 2]</span><br><span class="line">]);</span><br><span class="line">const m1 = new Map(set);</span><br><span class="line">m1.get(&#x27;foo&#x27;) // 1</span><br><span class="line"></span><br><span class="line">const m2 = new Map([[&#x27;baz&#x27;, 3]]);</span><br><span class="line">const m3 = new Map(m2);</span><br><span class="line">m3.get(&#x27;baz&#x27;) // 3</span><br></pre></td></tr></table></figure>

<p>如果读取一个未知的键，则返回<code>undefined</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">new Map().get(&#x27;asfddfsasadf&#x27;)</span><br><span class="line">// undefined</span><br></pre></td></tr></table></figure>

<p>注意，只有对同一个对象的引用，Map 结构才将其视为同一个键。这一点要非常小心。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const map = new Map();</span><br><span class="line"></span><br><span class="line">map.set([&#x27;a&#x27;], 555);</span><br><span class="line">map.get([&#x27;a&#x27;]) // undefined</span><br></pre></td></tr></table></figure>

<p>上面代码的<code>set</code>和<code>get</code>方法，表面是针对同一个键，但实际上这是两个值，内存地址是不一样的，因此<code>get</code>方法无法读取该键，返回<code>undefined</code>。</p>
<p>由上可知，Map 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属性碰撞（clash）的问题，我们扩展别人的库的时候，如果使用对象作为键名，就不用担心自己的属性与原作者的属性同名。</p>
<p>如果 Map 的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，Map 将其视为一个键，比如<code>0</code>和<code>-0</code>就是一个键，布尔值<code>true</code>和字符串<code>true</code>则是两个不同的键。另外，<code>undefined</code>和<code>null</code>也是两个不同的键。虽然<code>NaN</code>不严格相等于自身，但 Map 将其视为同一个键。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">let map = new Map();</span><br><span class="line"></span><br><span class="line">map.set(-0, 123);</span><br><span class="line">map.get(+0) // 123</span><br><span class="line"></span><br><span class="line">map.set(true, 1);</span><br><span class="line">map.set(&#x27;true&#x27;, 2);</span><br><span class="line">map.get(true) // 1</span><br><span class="line"></span><br><span class="line">map.set(undefined, 3);</span><br><span class="line">map.set(null, 4);</span><br><span class="line">map.get(undefined) // 3</span><br><span class="line"></span><br><span class="line">map.set(NaN, 123);</span><br><span class="line">map.get(NaN) // 123</span><br></pre></td></tr></table></figure>

<p>Map 的属性及方法</p>
<p>属性：</p>
<ul>
<li><p>constructor：构造函数</p>
</li>
<li><p>size：返回字典中所包含的元素个数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const map = new Map([</span><br><span class="line">  [&#x27;name&#x27;, &#x27;An&#x27;],</span><br><span class="line">  [&#x27;des&#x27;, &#x27;JS&#x27;]</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">map.size // 2</span><br></pre></td></tr></table></figure></li>
</ul>
<p>操作方法：</p>
<ul>
<li>set(key, value)：向字典中添加新元素</li>
<li>get(key)：通过键查找特定的数值并返回</li>
<li>has(key)：判断字典中是否存在键key</li>
<li>delete(key)：通过键 key 从字典中移除对应的数据</li>
<li>clear()：将这个字典中的所有元素删除</li>
</ul>
<p>遍历方法</p>
<ul>
<li>Keys()：将字典中包含的所有键名以迭代器形式返回</li>
<li>values()：将字典中包含的所有数值以迭代器形式返回</li>
<li>entries()：返回所有成员的迭代器</li>
<li>forEach()：遍历字典的所有成员</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const map = new Map([</span><br><span class="line">            [&#x27;name&#x27;, &#x27;An&#x27;],</span><br><span class="line">            [&#x27;des&#x27;, &#x27;JS&#x27;]</span><br><span class="line">        ]);</span><br><span class="line">console.log(map.entries())	// MapIterator &#123;&quot;name&quot; =&gt; &quot;An&quot;, &quot;des&quot; =&gt; &quot;JS&quot;&#125;</span><br><span class="line">console.log(map.keys()) // MapIterator &#123;&quot;name&quot;, &quot;des&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>Map 结构的默认遍历器接口（<code>Symbol.iterator</code>属性），就是<code>entries</code>方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map[Symbol.iterator] === map.entries</span><br><span class="line">// true</span><br></pre></td></tr></table></figure>

<p>Map 结构转为数组结构，比较快速的方法是使用扩展运算符（<code>...</code>）。</p>
<p>对于 forEach ，看一个例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const reporter = &#123;</span><br><span class="line">  report: function(key, value) &#123;</span><br><span class="line">    console.log(&quot;Key: %s, Value: %s&quot;, key, value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let map = new Map([</span><br><span class="line">    [&#x27;name&#x27;, &#x27;An&#x27;],</span><br><span class="line">    [&#x27;des&#x27;, &#x27;JS&#x27;]</span><br><span class="line">])</span><br><span class="line">map.forEach(function(value, key, map) &#123;</span><br><span class="line">  this.report(key, value);</span><br><span class="line">&#125;, reporter);</span><br><span class="line">// Key: name, Value: An</span><br><span class="line">// Key: des, Value: JS</span><br></pre></td></tr></table></figure>

<p>在这个例子中， forEach 方法的回调函数的 this，就指向 reporter</p>
<p><strong>与其他数据结构的相互转换</strong></p>
<ol>
<li><p>Map 转 Array</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const map = new Map([[1, 1], [2, 2], [3, 3]])</span><br><span class="line">console.log([...map])	// [[1, 1], [2, 2], [3, 3]]</span><br></pre></td></tr></table></figure>
</li>
<li><p>Array 转 Map</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const map = new Map([[1, 1], [2, 2], [3, 3]])</span><br><span class="line">console.log(map)	// Map &#123;1 =&gt; 1, 2 =&gt; 2, 3 =&gt; 3&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Map 转 Object</p>
<p>因为 Object 的键名都为字符串，而Map 的键名为对象，所以转换的时候会把非字符串键名转换为字符串键名。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function mapToObj(map) &#123;</span><br><span class="line">    let obj = Object.create(null)</span><br><span class="line">    for (let [key, value] of map) &#123;</span><br><span class="line">        obj[key] = value</span><br><span class="line">    &#125;</span><br><span class="line">    return obj</span><br><span class="line">&#125;</span><br><span class="line">const map = new Map().set(&#x27;name&#x27;, &#x27;An&#x27;).set(&#x27;des&#x27;, &#x27;JS&#x27;)</span><br><span class="line">mapToObj(map) // &#123;name: &quot;An&quot;, des: &quot;JS&quot;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Object 转 Map</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function objToMap(obj) &#123;</span><br><span class="line">    let map = new Map()</span><br><span class="line">    for (let key of Object.keys(obj)) &#123;</span><br><span class="line">        map.set(key, obj[key])</span><br><span class="line">    &#125;</span><br><span class="line">    return map</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">objToMap(&#123;&#x27;name&#x27;: &#x27;An&#x27;, &#x27;des&#x27;: &#x27;JS&#x27;&#125;) // Map &#123;&quot;name&quot; =&gt; &quot;An&quot;, &quot;des&quot; =&gt; &quot;JS&quot;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Map 转 JSON</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function mapToJson(map) &#123;</span><br><span class="line">    return JSON.stringify([...map])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let map = new Map().set(&#x27;name&#x27;, &#x27;An&#x27;).set(&#x27;des&#x27;, &#x27;JS&#x27;)</span><br><span class="line">mapToJson(map)	// [[&quot;name&quot;,&quot;An&quot;],[&quot;des&quot;,&quot;JS&quot;]]</span><br></pre></td></tr></table></figure>
</li>
<li><p>JSON 转 Map</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function jsonToStrMap(jsonStr) &#123;</span><br><span class="line">  return objToMap(JSON.parse(jsonStr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jsonToStrMap(&#x27;&#123;&quot;name&quot;: &quot;An&quot;, &quot;des&quot;: &quot;JS&quot;&#125;&#x27;) // Map &#123;&quot;name&quot; =&gt; &quot;An&quot;, &quot;des&quot; =&gt; &quot;JS&quot;&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="4-WeakMap"><a href="#4-WeakMap" class="headerlink" title="4. WeakMap"></a>4. WeakMap</h3><p>WeakMap 对象是一组键值对的集合，其中的<strong>键是弱引用对象，而值可以是任意</strong>。</p>
<p><strong>注意，WeakMap 弱引用的只是键名，而不是键值。键值依然是正常引用。</strong></p>
<p>WeakMap 中，每个键对自己所引用对象的引用都是弱引用，在没有其他引用和该键引用同一对象，这个对象将会被垃圾回收（相应的key则变成无效的），所以，WeakMap 的 key 是不可枚举的。</p>
<p>属性：</p>
<ul>
<li>constructor：构造函数</li>
</ul>
<p>方法：</p>
<ul>
<li>has(key)：判断是否有 key 关联对象</li>
<li>get(key)：返回key关联对象（没有则则返回 undefined）</li>
<li>set(key)：设置一组key关联对象</li>
<li>delete(key)：移除 key 的关联对象</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let myElement = document.getElementById(&#x27;logo&#x27;);</span><br><span class="line">let myWeakmap = new WeakMap();</span><br><span class="line"></span><br><span class="line">myWeakmap.set(myElement, &#123;timesClicked: 0&#125;);</span><br><span class="line"></span><br><span class="line">myElement.addEventListener(&#x27;click&#x27;, function() &#123;</span><br><span class="line">  let logoData = myWeakmap.get(myElement);</span><br><span class="line">  logoData.timesClicked++;</span><br><span class="line">&#125;, false);</span><br></pre></td></tr></table></figure>

<h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h3><ul>
<li>Set<ul>
<li>成员唯一、无序且不重复</li>
<li>[value, value]，键值与键名是一致的（或者说只有键值，没有键名）</li>
<li>可以遍历，方法有：add、delete、has</li>
</ul>
</li>
<li>WeakSet<ul>
<li>成员都是对象</li>
<li>成员都是弱引用，可以被垃圾回收机制回收，可以用来保存DOM节点，不容易造成内存泄漏</li>
<li>不能遍历，方法有add、delete、has</li>
</ul>
</li>
<li>Map<ul>
<li>本质上是键值对的集合，类似集合</li>
<li>可以遍历，方法很多可以跟各种数据格式转换</li>
</ul>
</li>
<li>WeakMap<ul>
<li>只接受对象作为键名（null除外），不接受其他类型的值作为键名</li>
<li>键名是弱引用，键值可以是任意的，键名所指向的对象可以被垃圾回收，此时键名是无效的</li>
<li>不能遍历，方法有get、set、has、delete</li>
</ul>
</li>
</ul>
<h3 id="6-扩展：Object与Set、Map"><a href="#6-扩展：Object与Set、Map" class="headerlink" title="6. 扩展：Object与Set、Map"></a>6. 扩展：Object与Set、Map</h3><ol>
<li><p>Object 与 Set</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// Object</span><br><span class="line">const properties1 = &#123;</span><br><span class="line">    &#x27;width&#x27;: 1,</span><br><span class="line">    &#x27;height&#x27;: 1</span><br><span class="line">&#125;</span><br><span class="line">console.log(properties1[&#x27;width&#x27;]? true: false) // true</span><br><span class="line"></span><br><span class="line">// Set</span><br><span class="line">const properties2 = new Set()</span><br><span class="line">properties2.add(&#x27;width&#x27;)</span><br><span class="line">properties2.add(&#x27;height&#x27;)</span><br><span class="line">console.log(properties2.has(&#x27;width&#x27;)) // true</span><br></pre></td></tr></table></figure>
</li>
<li><p>Object 与 Map</p>
</li>
</ol>
<p>JS 中的对象（Object），本质上是键值对的集合（hash 结构）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const data = &#123;&#125;;</span><br><span class="line">const element = document.getElementsByClassName(&#x27;App&#x27;);</span><br><span class="line"></span><br><span class="line">data[element] = &#x27;metadata&#x27;;</span><br><span class="line">console.log(data[&#x27;[object HTMLCollection]&#x27;]) // &quot;metadata&quot;</span><br></pre></td></tr></table></figure>

<p>但当以一个DOM节点作为对象 data 的键，对象会被自动转化为字符串[Object HTMLCollection]，所以说，Object 结构提供了 <strong>字符串-值</strong> 对应，Map则提供了 <strong>值-值</strong> 的对应</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/04/10/html+css+js+ts/4-set+map/" data-id="cl7k9sbhv00d098u03irrb006" data-title="ES6 Set-Map" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/es6/" rel="tag">es6</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-html+css+js+ts/4-Reflect" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/04/07/html+css+js+ts/4-Reflect/" class="article-date">
  <time class="dt-published" datetime="2018-04-07T06:32:15.000Z" itemprop="datePublished">2018-04-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/04/07/html+css+js+ts/4-Reflect/">ES6 Reflect</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><h3 id="1-1-什么是Reflect"><a href="#1-1-什么是Reflect" class="headerlink" title="1.1 什么是Reflect"></a>1.1 什么是Reflect</h3><blockquote>
<p>为操作对象而提供的新<code>API</code></p>
</blockquote>
<h3 id="1-2-为什么要设计Reflect"><a href="#1-2-为什么要设计Reflect" class="headerlink" title="1.2 为什么要设计Reflect"></a>1.2 为什么要设计Reflect</h3><ol>
<li>将<code>Object</code>对象的属于语言内部的方法放到<code>Reflect</code>对象上，即从<code>Reflect</code>对象上拿<code>Object</code>对象内部方法</li>
<li>将用老<code>Object</code>方法报错的情况，改为返回<code>false</code></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 旧写法</span><br><span class="line">try &#123;</span><br><span class="line">  Object.defineProperty(target, property, attributes);</span><br><span class="line">  // success</span><br><span class="line">&#125; catch (e) &#123;</span><br><span class="line">  // failure</span><br><span class="line">&#125;</span><br><span class="line">// 新写法</span><br><span class="line">if (Reflect.defineProperty(target, property, attributes)) &#123;</span><br><span class="line">  // success</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  // failure</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>让<code>Object</code>操作变成函数行为</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 旧写法</span><br><span class="line">&#x27;name&#x27; in Object //true</span><br><span class="line">// 新写法</span><br><span class="line">Reflect.has(Object,&#x27;name&#x27;) //true</span><br></pre></td></tr></table></figure>

<ol>
<li><code>Reflect</code>与<code>Proxy</code>是相辅相成的，在<code>Proxy</code>上有的方法，在<code>Reflect</code>就一定有</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let target=&#123;&#125;</span><br><span class="line">let handler=&#123;</span><br><span class="line">  set(target,proName,proValue,receiver)&#123;</span><br><span class="line">    //确认对象的属性赋值成功</span><br><span class="line">    let isSuccess=Reflect.set(target,proName,proValue,receiver)</span><br><span class="line">    if(isSuccess)&#123;</span><br><span class="line">      console.log(&quot;成功&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    return isSuccess</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let proxy=new Proxy(target,handler)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>确保对象的属性能正确赋值，广义上讲，即确保对象的原生行为能够正常进行，这就是<code>Reflect</code>的作用</p>
</blockquote>
<h2 id="二、Reflect的API"><a href="#二、Reflect的API" class="headerlink" title="二、Reflect的API"></a>二、Reflect的API</h2><blockquote>
<p>注：和<code>Proxy</code>的<code>API</code>一致</p>
</blockquote>
<h3 id="2-1-Reflect-get-target-property-receiver"><a href="#2-1-Reflect-get-target-property-receiver" class="headerlink" title="2.1 Reflect.get(target,property,receiver)"></a>2.1 Reflect.get(target,property,receiver)</h3><blockquote>
<p>查找并返回<code>target</code>对象的<code>property</code>属性</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">let obj=&#123;</span><br><span class="line">  name:&quot;poetries&quot;,</span><br><span class="line">&#125;</span><br><span class="line">let result=Reflect.get(obj,&quot;name&quot;)</span><br><span class="line">console.log(result) //poetries</span><br><span class="line">let obj=&#123;</span><br><span class="line">  //属性yu部署了getter读取函数</span><br><span class="line">  get yu()&#123;</span><br><span class="line">    //this返回的是Reflect.get的receiver参数对象</span><br><span class="line">    return this.name+this.age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let receiver=&#123;</span><br><span class="line">  name:&quot;shen&quot;,</span><br><span class="line">  age:&quot;18&quot;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let result=Reflect.get(obj,&quot;yu&quot;,receiver)</span><br><span class="line">console.log(result) //shen18</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：如果<code>Reflect.get()</code>的第一个参数不是对象，则会报错</p>
</blockquote>
<h3 id="2-2-Reflect-set-target-propName-propValue-receiver"><a href="#2-2-Reflect-set-target-propName-propValue-receiver" class="headerlink" title="2.2 Reflect.set(target,propName,propValue,receiver)"></a>2.2 Reflect.set(target,propName,propValue,receiver)</h3><blockquote>
<p>设置<code>target</code>对象的<code>propName</code>属性为<code>propValue</code></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let obj=&#123;</span><br><span class="line">  name:&quot;poetries&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let result=Reflect.set(obj,&quot;name&quot;,&quot;静观流叶&quot;)</span><br><span class="line">console.log(result) //true</span><br><span class="line">console.log(obj.name) //静观流叶</span><br></pre></td></tr></table></figure>

<h3 id="2-3-Reflect-set与Proxy-set"><a href="#2-3-Reflect-set与Proxy-set" class="headerlink" title="2.3 Reflect.set与Proxy.set"></a>2.3 Reflect.set与Proxy.set</h3><blockquote>
<p><code>Reflect.set</code>与<code>Proxy.set</code>联合使用,并且传入<code>receiver</code>，则会进行定义属性操作</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">let obj=&#123;</span><br><span class="line">  name:&quot;chen&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let handler=&#123;</span><br><span class="line">  set(target,key,value,receiver)&#123;</span><br><span class="line">    console.log(&quot;Proxy拦截赋值操作&quot;)</span><br><span class="line">    //Reflect完成赋值操作</span><br><span class="line">    Reflect.set(target,key,value,receiver)</span><br><span class="line">  &#125;,</span><br><span class="line">  defineProperty(target,key,attribute)&#123;</span><br><span class="line">    console.log(&quot;Proxy拦截定义属性操作&quot;)</span><br><span class="line">    //Reflect完成定义属性操作</span><br><span class="line">    Reflect.defineProperty(target,key,attribute)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let proxy=new Proxy(obj,handler)</span><br><span class="line">proxy.name=&quot;ya&quot;</span><br><span class="line">//Proxy拦截赋值操作</span><br><span class="line">//Proxy拦截定义属性操作</span><br></pre></td></tr></table></figure>

<blockquote>
<p>为什么Reflect.set()传入receiver参数，就会触发定义属性的操作？</p>
</blockquote>
<p>因为<code>Proxy.set()</code>中的<code>receiver</code>是<code>Proxy</code>的实例，即<code>obj</code>，而<code>Reflect.set</code>一旦传入<code>receiver</code>，就会将属性赋值到<code>receiver</code>上面，也是<code>obj</code>，所以就会触发<code>defineProperty</code>拦截</p>
<h3 id="2-4-Reflect-has-obj-name"><a href="#2-4-Reflect-has-obj-name" class="headerlink" title="2.4 Reflect.has(obj,name)"></a>2.4 Reflect.has(obj,name)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var obj= &#123;</span><br><span class="line">  name: &quot;poetries&quot;,</span><br><span class="line">&#125;;</span><br><span class="line">//旧写法</span><br><span class="line">&#x27;name&#x27; in obj // true</span><br><span class="line">//新写法</span><br><span class="line">Reflect.has(obj, &#x27;name&#x27;) // true</span><br></pre></td></tr></table></figure>

<h3 id="2-5-Reflect-deleteProperty-obj-name"><a href="#2-5-Reflect-deleteProperty-obj-name" class="headerlink" title="2.5 Reflect.deleteProperty(obj, name)"></a>2.5 Reflect.deleteProperty(obj, name)</h3><blockquote>
<p>删除对象的属性</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 旧写法</span><br><span class="line">delete obj.name;</span><br><span class="line">// 新写法</span><br><span class="line">Reflect.deleteProperty(obj, &#x27;name&#x27;);</span><br></pre></td></tr></table></figure>

<h3 id="2-6-Reflect-construct-target-args"><a href="#2-6-Reflect-construct-target-args" class="headerlink" title="2.6 Reflect.construct(target, args)"></a>2.6 Reflect.construct(target, args)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function Person(name) &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">&#125;</span><br><span class="line">// 旧 new写法</span><br><span class="line">let person= new Person(&#x27;poetries&#x27;)</span><br><span class="line">// 新写法：Reflect.construct 的写法</span><br><span class="line">let person = Reflect.construct(Person, [&#x27;poetries&#x27;]);</span><br></pre></td></tr></table></figure>

<h3 id="2-7-Reflect-getPrototypeOf-obj"><a href="#2-7-Reflect-getPrototypeOf-obj" class="headerlink" title="2.7 Reflect.getPrototypeOf(obj)"></a>2.7 Reflect.getPrototypeOf(obj)</h3><blockquote>
<p>用于读取对象的<code>proto</code>属性，对应<code>Object.getPrototypeOf(obj)</code></p>
</blockquote>
<h3 id="2-8-Reflect-setPrototypeOf-obj-newProto"><a href="#2-8-Reflect-setPrototypeOf-obj-newProto" class="headerlink" title="2.8 Reflect.setPrototypeOf(obj, newProto)"></a>2.8 Reflect.setPrototypeOf(obj, newProto)</h3><blockquote>
<p>设置目标对象的原型（<code>prototype</code>），对应<code>Object.setPrototypeOf(obj, newProto)</code>方法</p>
</blockquote>
<h3 id="2-9-Reflect-apply-func-thisArg-args"><a href="#2-9-Reflect-apply-func-thisArg-args" class="headerlink" title="2.9 Reflect.apply(func, thisArg, args)"></a>2.9 Reflect.apply(func, thisArg, args)</h3><blockquote>
<p>继承目标对象的特定方法</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let array=[1,2,3,4,5,6]</span><br><span class="line">// 旧写法</span><br><span class="line">let small= Math.min.apply(Math, array) //1</span><br><span class="line">let big = Math.max.apply(Math, array) //6</span><br><span class="line">let type = Object.prototype.toString.call(small) //&quot;[object Number]&quot;</span><br><span class="line">// 新写法</span><br><span class="line">const small= Reflect.apply(Math.min, Math, array)</span><br><span class="line">const big = Reflect.apply(Math.max, Math, array)</span><br><span class="line">//第三个参数是Object类型的就好，因为调用的是Object的原型方法toString</span><br><span class="line">const type = Reflect.apply(Object.prototype.toString, small, [])</span><br></pre></td></tr></table></figure>

<h3 id="2-10-Reflect-defineProperty-target-propertyKey-attributes"><a href="#2-10-Reflect-defineProperty-target-propertyKey-attributes" class="headerlink" title="2.10 Reflect.defineProperty(target, propertyKey, attributes)"></a>2.10 Reflect.defineProperty(target, propertyKey, attributes)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function MyDate() &#123;</span><br><span class="line">  ...</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">// 旧写法</span><br><span class="line">Object.defineProperty(MyDate, &#x27;now&#x27;, &#123;</span><br><span class="line">  value: () =&gt; Date.now()</span><br><span class="line">&#125;);</span><br><span class="line">// 新写法</span><br><span class="line">Reflect.defineProperty(MyDate, &#x27;now&#x27;, &#123;</span><br><span class="line">  value: () =&gt; Date.now()</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>与<code>Proxy.defineProperty</code>配合使用</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let proxy = new Proxy(&#123;&#125;, &#123;</span><br><span class="line">  defineProperty(target, prop, descriptor) &#123;</span><br><span class="line">    console.log(descriptor);</span><br><span class="line">    return Reflect.defineProperty(target, prop, descriptor);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">proxy .name= &#x27;chen&#x27;;</span><br><span class="line">// &#123;value: &quot;chen&quot;, writable: true, enumerable: true, configurable: true&#125;</span><br><span class="line">p.name // &quot;chen&quot;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如上，<code>Proxy.defineProperty</code>对属性赋值设置拦截，然后使用<code>Reflect.defineProperty</code>完成赋值</p>
</blockquote>
<h3 id="2-11-Reflect-getOwnPropertyDescriptor-target-propertyKey"><a href="#2-11-Reflect-getOwnPropertyDescriptor-target-propertyKey" class="headerlink" title="2.11 Reflect.getOwnPropertyDescriptor(target, propertyKey)"></a>2.11 Reflect.getOwnPropertyDescriptor(target, propertyKey)</h3><blockquote>
<p>基本等同于<code>Object.getOwnPropertyDescriptor</code>，用于得到指定属性的描述对象</p>
</blockquote>
<h3 id="2-12-Reflect-isExtensible-target"><a href="#2-12-Reflect-isExtensible-target" class="headerlink" title="2.12 Reflect.isExtensible (target)"></a>2.12 Reflect.isExtensible (target)</h3><blockquote>
<p>对应<code>Object.isExtensible</code>，返回一个布尔值，表示当前对象是否可扩展</p>
</blockquote>
<h3 id="2-13-Reflect-preventExtensions-target"><a href="#2-13-Reflect-preventExtensions-target" class="headerlink" title="2.13 Reflect.preventExtensions(target)"></a>2.13 Reflect.preventExtensions(target)</h3><blockquote>
<p>对应<code>Object.preventExtensions</code>方法，用于让一个对象变为不可扩展。它返回一个布尔值，表示是否操作成功</p>
</blockquote>
<h3 id="2-14-Reflect-ownKeys-target"><a href="#2-14-Reflect-ownKeys-target" class="headerlink" title="2.14 Reflect.ownKeys (target)"></a>2.14 Reflect.ownKeys (target)</h3><blockquote>
<p>用于返回对象的所有属性</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/04/07/html+css+js+ts/4-Reflect/" data-id="cl7k9sbhp00ca98u0hmk6e0yj" data-title="ES6 Reflect" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/es6/" rel="tag">es6</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-html+css+js+ts/4-Proxy" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/04/05/html+css+js+ts/4-Proxy/" class="article-date">
  <time class="dt-published" datetime="2018-04-05T12:13:50.000Z" itemprop="datePublished">2018-04-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/04/05/html+css+js+ts/4-Proxy/">ES6 Proxy</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="一、proxy概述"><a href="#一、proxy概述" class="headerlink" title="一、proxy概述"></a>一、proxy概述</h2><p><strong>Proxy的兼容性</strong></p>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/55.png" alt="img"></p>
<blockquote>
<p><code>proxy</code>在目标对象的外层搭建了一层拦截，外界对目标对象的某些操作，必须通过这层拦截</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var proxy = new Proxy(target, handler);</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>new Proxy()</code>表示生成一个<code>Proxy</code>实例，<code>target</code>参数表示所要拦截的目标对象，<code>handler</code>参数也是一个对象，用来定制拦截行为</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var target = &#123;</span><br><span class="line">   name: &#x27;poetries&#x27;</span><br><span class="line"> &#125;;</span><br><span class="line"> var logHandler = &#123;</span><br><span class="line">   get: function(target, key) &#123;</span><br><span class="line">     console.log(`$&#123;key&#125; 被读取`);</span><br><span class="line">     return target[key];</span><br><span class="line">   &#125;,</span><br><span class="line">   set: function(target, key, value) &#123;</span><br><span class="line">     console.log(`$&#123;key&#125; 被设置为 $&#123;value&#125;`);</span><br><span class="line">     target[key] = value;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> var targetWithLog = new Proxy(target, logHandler);</span><br><span class="line"> </span><br><span class="line"> targetWithLog.name; // 控制台输出：name 被读取</span><br><span class="line"> targetWithLog.name = &#x27;others&#x27;; // 控制台输出：name 被设置为 others</span><br><span class="line"> </span><br><span class="line"> console.log(target.name); // 控制台输出: others</span><br></pre></td></tr></table></figure>

<ul>
<li><code>targetWithLog</code> 读取属性的值时，实际上执行的是 <code>logHandler.get</code> ：在控制台输出信息，并且读取被代理对象 <code>target</code> 的属性。</li>
<li>在 <code>targetWithLog</code> 设置属性值时，实际上执行的是 <code>logHandler.set</code> ：在控制台输出信息，并且设置被代理对象 <code>target</code> 的属性的值</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 由于拦截函数总是返回35，所以访问任何属性都得到35</span><br><span class="line">var proxy = new Proxy(&#123;&#125;, &#123;</span><br><span class="line">  get: function(target, property) &#123;</span><br><span class="line">    return 35;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">proxy.time // 35</span><br><span class="line">proxy.name // 35</span><br><span class="line">proxy.title // 35</span><br></pre></td></tr></table></figure>

<p><strong>Proxy 实例也可以作为其他对象的原型对象</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var proxy = new Proxy(&#123;&#125;, &#123;</span><br><span class="line">  get: function(target, property) &#123;</span><br><span class="line">    return 35;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">let obj = Object.create(proxy);</span><br><span class="line">obj.time // 35</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>proxy</code>对象是<code>obj</code>对象的原型，<code>obj</code>对象本身并没有<code>time</code>属性，所以根据原型链，会在<code>proxy</code>对象上读取该属性，导致被拦截</p>
</blockquote>
<p><strong>Proxy的作用</strong></p>
<blockquote>
<p>对于代理模式 <code>Proxy</code> 的作用主要体现在三个方面</p>
</blockquote>
<ul>
<li>拦截和监视外部对对象的访问</li>
<li>降低函数或类的复杂度</li>
<li>在复杂操作前对操作进行校验或对所需资源进行管理</li>
</ul>
<h2 id="二、Proxy所能代理的范围–handler"><a href="#二、Proxy所能代理的范围–handler" class="headerlink" title="二、Proxy所能代理的范围–handler"></a>二、Proxy所能代理的范围–handler</h2><blockquote>
<p>实际上 <code>handler</code> 本身就是<code>ES6</code>所新设计的一个对象.它的作用就是用来 自定义代理对象的各种可代理操作 。它本身一共有<code>13</code>中方法,每种方法都可以代理一种操作.其<code>13</code>种方法如下</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">// 在读取代理对象的原型时触发该操作，比如在执行 Object.getPrototypeOf(proxy) 时。</span><br><span class="line">handler.getPrototypeOf()</span><br><span class="line"></span><br><span class="line">// 在设置代理对象的原型时触发该操作，比如在执行 Object.setPrototypeOf(proxy, null) 时。</span><br><span class="line">handler.setPrototypeOf()</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">// 在判断一个代理对象是否是可扩展时触发该操作，比如在执行 Object.isExtensible(proxy) 时。</span><br><span class="line">handler.isExtensible()</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">// 在让一个代理对象不可扩展时触发该操作，比如在执行 Object.preventExtensions(proxy) 时。</span><br><span class="line">handler.preventExtensions()</span><br><span class="line"></span><br><span class="line">// 在获取代理对象某个属性的属性描述时触发该操作，比如在执行 Object.getOwnPropertyDescriptor(proxy, &quot;foo&quot;) 时。</span><br><span class="line">handler.getOwnPropertyDescriptor()</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">// 在定义代理对象某个属性时的属性描述时触发该操作，比如在执行 Object.defineProperty(proxy, &quot;foo&quot;, &#123;&#125;) 时。</span><br><span class="line">andler.defineProperty()</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">// 在判断代理对象是否拥有某个属性时触发该操作，比如在执行 &quot;foo&quot; in proxy 时。</span><br><span class="line">handler.has()</span><br><span class="line"></span><br><span class="line">// 在读取代理对象的某个属性时触发该操作，比如在执行 proxy.foo 时。</span><br><span class="line">handler.get()</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">// 在给代理对象的某个属性赋值时触发该操作，比如在执行 proxy.foo = 1 时。</span><br><span class="line">handler.set()</span><br><span class="line"></span><br><span class="line">// 在删除代理对象的某个属性时触发该操作，比如在执行 delete proxy.foo 时。</span><br><span class="line">handler.deleteProperty()</span><br><span class="line"></span><br><span class="line">// 在获取代理对象的所有属性键时触发该操作，比如在执行 Object.getOwnPropertyNames(proxy) 时。</span><br><span class="line">handler.ownKeys()</span><br><span class="line"></span><br><span class="line">// 在调用一个目标对象为函数的代理对象时触发该操作，比如在执行 proxy() 时。</span><br><span class="line">handler.apply()</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">// 在给一个目标对象为构造函数的代理对象构造实例时触发该操作，比如在执行new proxy() 时。</span><br><span class="line">handler.construct()</span><br></pre></td></tr></table></figure>

<h2 id="三、Proxy场景"><a href="#三、Proxy场景" class="headerlink" title="三、Proxy场景"></a>三、Proxy场景</h2><h3 id="3-1-实现私有变量"><a href="#3-1-实现私有变量" class="headerlink" title="3.1 实现私有变量"></a>3.1 实现私有变量</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">var target = &#123;</span><br><span class="line">   name: &#x27;poetries&#x27;,</span><br><span class="line">   _age: 22</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var logHandler = &#123;</span><br><span class="line">  get: function(target,key)&#123;</span><br><span class="line">    if(key.startsWith(&#x27;_&#x27;))&#123;</span><br><span class="line">      console.log(&#x27;私有变量age不能被访问&#x27;)</span><br><span class="line">      return false</span><br><span class="line">    &#125;</span><br><span class="line">    return target[key];</span><br><span class="line">  &#125;,</span><br><span class="line">  set: function(target, key, value) &#123;</span><br><span class="line">     if(key.startsWith(&#x27;_&#x27;))&#123;</span><br><span class="line">      console.log(&#x27;私有变量age不能被修改&#x27;)</span><br><span class="line">      return false</span><br><span class="line">    &#125;</span><br><span class="line">     target[key] = value;</span><br><span class="line">   &#125;</span><br><span class="line">&#125; </span><br><span class="line">var targetWithLog = new Proxy(target, logHandler);</span><br><span class="line"> </span><br><span class="line">// 私有变量age不能被访问</span><br><span class="line">targetWithLog.name; </span><br><span class="line"> </span><br><span class="line">// 私有变量age不能被修改</span><br><span class="line">targetWithLog.name = &#x27;others&#x27;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在下面的代码中，我们声明了一个私有的 <code>apiKey</code>，便于 <code>api</code> 这个对象内部的方法调用，但不希望从外部也能够访问 <code>api._apiKey</code></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var api = &#123;  </span><br><span class="line">    _apiKey: &#x27;123abc456def&#x27;,</span><br><span class="line">    /* mock methods that use this._apiKey */</span><br><span class="line">    getUsers: function()&#123;&#125;, </span><br><span class="line">    getUser: function(userId)&#123;&#125;, </span><br><span class="line">    setUser: function(userId, config)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// logs &#x27;123abc456def&#x27;;</span><br><span class="line">console.log(&quot;An apiKey we want to keep private&quot;, api._apiKey);</span><br><span class="line"></span><br><span class="line">// get and mutate _apiKeys as desired</span><br><span class="line">var apiKey = api._apiKey;  </span><br><span class="line">api._apiKey = &#x27;987654321&#x27;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>很显然，约定俗成是没有束缚力的。使用 <code>ES6 Proxy</code> 我们就可以实现真实的私有变量了，下面针对不同的读取方式演示两个不同的私有化方法。第一种方法是使用 <code>set / get</code> 拦截读写请求并返回 <code>undefined</code>:</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">let api = &#123;  </span><br><span class="line">    _apiKey: &#x27;123abc456def&#x27;,</span><br><span class="line">    getUsers: function()&#123; &#125;, </span><br><span class="line">    getUser: function(userId)&#123; &#125;, </span><br><span class="line">    setUser: function(userId, config)&#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const RESTRICTED = [&#x27;_apiKey&#x27;];</span><br><span class="line">api = new Proxy(api, &#123;  </span><br><span class="line">    get(target, key, proxy) &#123;</span><br><span class="line">        if(RESTRICTED.indexOf(key) &gt; -1) &#123;</span><br><span class="line">            throw Error(`$&#123;key&#125; is restricted. Please see api documentation for further info.`);</span><br><span class="line">        &#125;</span><br><span class="line">        return Reflect.get(target, key, proxy);</span><br><span class="line">    &#125;,</span><br><span class="line">    set(target, key, value, proxy) &#123;</span><br><span class="line">        if(RESTRICTED.indexOf(key) &gt; -1) &#123;</span><br><span class="line">            throw Error(`$&#123;key&#125; is restricted. Please see api documentation for further info.`);</span><br><span class="line">        &#125;</span><br><span class="line">        return Reflect.get(target, key, value, proxy);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 以下操作都会抛出错误</span><br><span class="line">console.log(api._apiKey);</span><br><span class="line">api._apiKey = &#x27;987654321&#x27;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>第二种方法是使用 <code>has</code> 拦截 <code>in</code> 操作</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">var api = &#123;  </span><br><span class="line">    _apiKey: &#x27;123abc456def&#x27;,</span><br><span class="line">    getUsers: function()&#123; &#125;, </span><br><span class="line">    getUser: function(userId)&#123; &#125;, </span><br><span class="line">    setUser: function(userId, config)&#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const RESTRICTED = [&#x27;_apiKey&#x27;];</span><br><span class="line">api = new Proxy(api, &#123;  </span><br><span class="line">    has(target, key) &#123;</span><br><span class="line">        return (RESTRICTED.indexOf(key) &gt; -1) ?</span><br><span class="line">            false :</span><br><span class="line">            Reflect.has(target, key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// these log false, and `for in` iterators will ignore _apiKey</span><br><span class="line">console.log(&quot;_apiKey&quot; in api);</span><br><span class="line"></span><br><span class="line">for (var key in api) &#123;  </span><br><span class="line">    if (api.hasOwnProperty(key) &amp;&amp; key === &quot;_apiKey&quot;) &#123;</span><br><span class="line">        console.log(&quot;This will never be logged because the proxy obscures _apiKey...&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-抽离校验模块"><a href="#3-2-抽离校验模块" class="headerlink" title="3.2 抽离校验模块"></a>3.2 抽离校验模块</h3><blockquote>
<p>让我们从一个简单的类型校验开始做起，这个示例演示了如何使用 <code>Proxy</code> 保障数据类型的准确性</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">let numericDataStore = &#123;  </span><br><span class="line">    count: 0,</span><br><span class="line">    amount: 1234,</span><br><span class="line">    total: 14</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">numericDataStore = new Proxy(numericDataStore, &#123;  </span><br><span class="line">    set(target, key, value, proxy) &#123;</span><br><span class="line">        if (typeof value !== &#x27;number&#x27;) &#123;</span><br><span class="line">            throw Error(&quot;Properties in numericDataStore can only be numbers&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return Reflect.set(target, key, value, proxy);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 抛出错误，因为 &quot;foo&quot; 不是数值</span><br><span class="line">numericDataStore.count = &quot;foo&quot;;</span><br><span class="line"></span><br><span class="line">// 赋值成功</span><br><span class="line">numericDataStore.count = 333;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果要直接为对象的所有属性开发一个校验器可能很快就会让代码结构变得臃肿，使用 <code>Proxy</code> 则可以将校验器从核心逻辑分离出来自成一体</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">function createValidator(target, validator) &#123;  </span><br><span class="line">    return new Proxy(target, &#123;</span><br><span class="line">        _validator: validator,</span><br><span class="line">        set(target, key, value, proxy) &#123;</span><br><span class="line">            if (target.hasOwnProperty(key)) &#123;</span><br><span class="line">                let validator = this._validator[key];</span><br><span class="line">                if (!!validator(value)) &#123;</span><br><span class="line">                    return Reflect.set(target, key, value, proxy);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    throw Error(`Cannot set $&#123;key&#125; to $&#123;value&#125;. Invalid.`);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                throw Error(`$&#123;key&#125; is not a valid property`)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const personValidators = &#123;  </span><br><span class="line">    name(val) &#123;</span><br><span class="line">        return typeof val === &#x27;string&#x27;;</span><br><span class="line">    &#125;,</span><br><span class="line">    age(val) &#123;</span><br><span class="line">        return typeof age === &#x27;number&#x27; &amp;&amp; age &gt; 18;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Person &#123;  </span><br><span class="line">    constructor(name, age) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">        return createValidator(this, personValidators);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const bill = new Person(&#x27;Bill&#x27;, 25);</span><br><span class="line"></span><br><span class="line">// 以下操作都会报错</span><br><span class="line">bill.name = 0;  </span><br><span class="line">bill.age = &#x27;Bill&#x27;;  </span><br><span class="line">bill.age = 15;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>通过校验器和主逻辑的分离，你可以无限扩展 <code>personValidators</code> 校验器的内容，而不会对相关的类或函数造成直接破坏。更复杂一点，我们还可以使用 <code>Proxy</code> 模拟类型检查，检查函数是否接收了类型和数量都正确的参数</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;  </span><br><span class="line">    pickyMethodOne: function(obj, str, num) &#123; /* ... */ &#125;,</span><br><span class="line">    pickyMethodTwo: function(num, obj) &#123; /*... */ &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const argTypes = &#123;  </span><br><span class="line">    pickyMethodOne: [&quot;object&quot;, &quot;string&quot;, &quot;number&quot;],</span><br><span class="line">    pickyMethodTwo: [&quot;number&quot;, &quot;object&quot;]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj = new Proxy(obj, &#123;  </span><br><span class="line">    get: function(target, key, proxy) &#123;</span><br><span class="line">        var value = target[key];</span><br><span class="line">        return function(...args) &#123;</span><br><span class="line">            var checkArgs = argChecker(key, args, argTypes[key]);</span><br><span class="line">            return Reflect.apply(value, target, args);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">function argChecker(name, args, checkers) &#123;  </span><br><span class="line">    for (var idx = 0; idx &lt; args.length; idx++) &#123;</span><br><span class="line">        var arg = args[idx];</span><br><span class="line">        var type = checkers[idx];</span><br><span class="line">        if (!arg || typeof arg !== type) &#123;</span><br><span class="line">            console.warn(`You are incorrectly implementing the signature of $&#123;name&#125;. Check param $&#123;idx + 1&#125;`);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.pickyMethodOne();  </span><br><span class="line">// &gt; You are incorrectly implementing the signature of pickyMethodOne. Check param 1</span><br><span class="line">// &gt; You are incorrectly implementing the signature of pickyMethodOne. Check param 2</span><br><span class="line">// &gt; You are incorrectly implementing the signature of pickyMethodOne. Check param 3</span><br><span class="line"></span><br><span class="line">obj.pickyMethodTwo(&quot;wopdopadoo&quot;, &#123;&#125;);  </span><br><span class="line">// &gt; You are incorrectly implementing the signature of pickyMethodTwo. Check param 1</span><br><span class="line"></span><br><span class="line">// No warnings logged</span><br><span class="line">obj.pickyMethodOne(&#123;&#125;, &quot;a little string&quot;, 123);  </span><br><span class="line">obj.pickyMethodOne(123, &#123;&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="3-3-访问日志"><a href="#3-3-访问日志" class="headerlink" title="3.3 访问日志"></a>3.3 访问日志</h3><blockquote>
<p>对于那些调用频繁、运行缓慢或占用执行环境资源较多的属性或接口，开发者会希望记录它们的使用情况或性能表现，这个时候就可以使用 <code>Proxy</code> 充当中间件的角色，轻而易举实现日志功能</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">let api = &#123;  </span><br><span class="line">    _apiKey: &#x27;123abc456def&#x27;,</span><br><span class="line">    getUsers: function() &#123; /* ... */ &#125;,</span><br><span class="line">    getUser: function(userId) &#123; /* ... */ &#125;,</span><br><span class="line">    setUser: function(userId, config) &#123; /* ... */ &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function logMethodAsync(timestamp, method) &#123;  </span><br><span class="line">    setTimeout(function() &#123;</span><br><span class="line">        console.log(`$&#123;timestamp&#125; - Logging $&#123;method&#125; request asynchronously.`);</span><br><span class="line">    &#125;, 0)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">api = new Proxy(api, &#123;  </span><br><span class="line">    get: function(target, key, proxy) &#123;</span><br><span class="line">        var value = target[key];</span><br><span class="line">        return function(...arguments) &#123;</span><br><span class="line">            logMethodAsync(new Date(), key);</span><br><span class="line">            return Reflect.apply(value, target, arguments);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">api.getUsers();</span><br></pre></td></tr></table></figure>

<h3 id="3-4-预警和拦截"><a href="#3-4-预警和拦截" class="headerlink" title="3.4 预警和拦截"></a>3.4 预警和拦截</h3><blockquote>
<p>假设你不想让其他开发者删除 <code>noDelete</code> 属性，还想让调用 <code>oldMethod</code> 的开发者了解到这个方法已经被废弃了，或者告诉开发者不要修改 <code>doNotChange</code> 属性，那么就可以使用 <code>Proxy</code> 来实现</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">let dataStore = &#123;  </span><br><span class="line">    noDelete: 1235,</span><br><span class="line">    oldMethod: function() &#123;/*...*/ &#125;,</span><br><span class="line">    doNotChange: &quot;tried and true&quot;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const NODELETE = [&#x27;noDelete&#x27;];  </span><br><span class="line">const NOCHANGE = [&#x27;doNotChange&#x27;];</span><br><span class="line">const DEPRECATED = [&#x27;oldMethod&#x27;];  </span><br><span class="line"></span><br><span class="line">dataStore = new Proxy(dataStore, &#123;  </span><br><span class="line">    set(target, key, value, proxy) &#123;</span><br><span class="line">        if (NOCHANGE.includes(key)) &#123;</span><br><span class="line">            throw Error(`Error! $&#123;key&#125; is immutable.`);</span><br><span class="line">        &#125;</span><br><span class="line">        return Reflect.set(target, key, value, proxy);</span><br><span class="line">    &#125;,</span><br><span class="line">    deleteProperty(target, key) &#123;</span><br><span class="line">        if (NODELETE.includes(key)) &#123;</span><br><span class="line">            throw Error(`Error! $&#123;key&#125; cannot be deleted.`);</span><br><span class="line">        &#125;</span><br><span class="line">        return Reflect.deleteProperty(target, key);</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    get(target, key, proxy) &#123;</span><br><span class="line">        if (DEPRECATED.includes(key)) &#123;</span><br><span class="line">            console.warn(`Warning! $&#123;key&#125; is deprecated.`);</span><br><span class="line">        &#125;</span><br><span class="line">        var val = target[key];</span><br><span class="line"></span><br><span class="line">        return typeof val === &#x27;function&#x27; ?</span><br><span class="line">            function(...args) &#123;</span><br><span class="line">                Reflect.apply(target[key], target, args);</span><br><span class="line">            &#125; :</span><br><span class="line">            val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// these will throw errors or log warnings, respectively</span><br><span class="line">dataStore.doNotChange = &quot;foo&quot;;  </span><br><span class="line">delete dataStore.noDelete;  </span><br><span class="line">dataStore.oldMethod();</span><br></pre></td></tr></table></figure>

<h3 id="3-5-过滤操作"><a href="#3-5-过滤操作" class="headerlink" title="3.5 过滤操作"></a>3.5 过滤操作</h3><blockquote>
<p>某些操作会非常占用资源，比如传输大文件，这个时候如果文件已经在分块发送了，就不需要在对新的请求作出相应（非绝对），这个时候就可以使用 <code>Proxy</code> 对当请求进行特征检测，并根据特征过滤出哪些是不需要响应的，哪些是需要响应的。下面的代码简单演示了过滤特征的方式，并不是完整代码，相信大家会理解其中的妙处</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;  </span><br><span class="line">    getGiantFile: function(fileId) &#123;/*...*/ &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj = new Proxy(obj, &#123;  </span><br><span class="line">    get(target, key, proxy) &#123;</span><br><span class="line">        return function(...args) &#123;</span><br><span class="line">            const id = args[0];</span><br><span class="line">            let isEnroute = checkEnroute(id);</span><br><span class="line">            let isDownloading = checkStatus(id);      </span><br><span class="line">            let cached = getCached(id);</span><br><span class="line"></span><br><span class="line">            if (isEnroute || isDownloading) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            if (cached) &#123;</span><br><span class="line">                return cached;</span><br><span class="line">            &#125;</span><br><span class="line">            return Reflect.apply(target[key], target, args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="3-6-中断代理"><a href="#3-6-中断代理" class="headerlink" title="3.6 中断代理"></a>3.6 中断代理</h3><blockquote>
<p><code>Proxy</code> 支持随时取消对 <code>target</code> 的代理，这一操作常用于完全封闭对数据或接口的访问。在下面的示例中，我们使用了 <code>Proxy.revocable</code> 方法创建了可撤销代理的代理对象：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let sensitiveData = &#123; username: &#x27;devbryce&#x27; &#125;;</span><br><span class="line">const &#123;sensitiveData, revokeAccess&#125; = Proxy.revocable(sensitiveData, handler);</span><br><span class="line">function handleSuspectedHack()&#123;  </span><br><span class="line">    revokeAccess();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// logs &#x27;devbryce&#x27;</span><br><span class="line">console.log(sensitiveData.username);</span><br><span class="line">handleSuspectedHack();</span><br><span class="line">// TypeError: Revoked</span><br><span class="line">console.log(sensitiveData.username);</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/04/05/html+css+js+ts/4-Proxy/" data-id="cl7k9sbho00c098u07f2gh3s7" data-title="ES6 Proxy" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/es6/" rel="tag">es6</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-html+css+js+ts/4-module" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/04/02/html+css+js+ts/4-module/" class="article-date">
  <time class="dt-published" datetime="2018-04-02T01:14:49.000Z" itemprop="datePublished">2018-04-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/04/02/html+css+js+ts/4-module/">ES6 module</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h2><p>模块，（Module），是能够单独命名并独立地完成一定功能的程序语句的<strong>集合（即程序代码和数据结构的集合体）</strong>。</p>
<p>两个基本的特征：外部特征和内部特征</p>
<ul>
<li>外部特征是指模块跟外部环境联系的接口（即其他模块或程序调用该模块的方式，包括有输入输出参数、引用的全局变量）和模块的功能</li>
<li>内部特征是指模块的内部环境具有的特点（即该模块的局部数据和程序代码）</li>
</ul>
<h3 id="为什么需要模块化"><a href="#为什么需要模块化" class="headerlink" title="为什么需要模块化"></a>为什么需要模块化</h3><ul>
<li>代码抽象</li>
<li>代码封装</li>
<li>代码复用</li>
<li>依赖管理</li>
</ul>
<p>如果没有模块化，我们代码会怎样？</p>
<ul>
<li>变量和方法不容易维护，容易污染全局作用域</li>
<li>加载资源的方式通过script标签从上到下。</li>
<li>依赖的环境主观逻辑偏重，代码较多就会比较复杂。</li>
<li>大型项目资源难以维护，特别是多人合作的情况下，资源的引入会让人奔溃</li>
</ul>
<p>因此，需要一种将<code>JavaScript</code>程序模块化的机制，如</p>
<ul>
<li>CommonJs (典型代表：node.js早期)</li>
<li>AMD (典型代表：require.js)</li>
<li>CMD (典型代表：sea.js)</li>
</ul>
<h3 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h3><p><code>Asynchronous ModuleDefinition</code>（AMD），异步模块定义，采用异步方式加载模块。所有依赖模块的语句，都定义在一个回调函数中，等到模块加载完成之后，这个回调函数才会运行</p>
<p>代表库为<code>require.js</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** main.js 入口文件/主模块 **/</span></span><br><span class="line"><span class="comment">// 首先用config()指定各模块路径和引用名</span></span><br><span class="line"><span class="built_in">require</span>.<span class="title function_">config</span>(&#123;</span><br><span class="line">  <span class="attr">baseUrl</span>: <span class="string">&quot;js/lib&quot;</span>,</span><br><span class="line">  <span class="attr">paths</span>: &#123;</span><br><span class="line">    <span class="string">&quot;jquery&quot;</span>: <span class="string">&quot;jquery.min&quot;</span>,  <span class="comment">//实际路径为js/lib/jquery.min.js</span></span><br><span class="line">    <span class="string">&quot;underscore&quot;</span>: <span class="string">&quot;underscore.min&quot;</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 执行基本操作</span></span><br><span class="line"><span class="built_in">require</span>([<span class="string">&quot;jquery&quot;</span>,<span class="string">&quot;underscore&quot;</span>],<span class="keyword">function</span>(<span class="params">$,_</span>)&#123;</span><br><span class="line">  <span class="comment">// some code here</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="CommonJs"><a href="#CommonJs" class="headerlink" title="CommonJs"></a>CommonJs</h3><p><code>CommonJS</code> 是一套 <code>Javascript</code> 模块规范，用于服务端</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>=&#123; foo , bar&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">const</span> &#123; foo,bar &#125; = <span class="built_in">require</span>(<span class="string">&#x27;./a.js&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>其有如下特点：</p>
<ul>
<li>所有代码都运行在模块作用域，不会污染全局作用域</li>
<li>模块是同步加载的，即只有加载完成，才能执行后面的操作</li>
<li>模块在首次执行后就会缓存，再次加载只返回缓存结果，如果想要再次执行，可清除缓存</li>
<li><code>require</code>返回的值是被输出的值的拷贝，模块内部的变化也不会影响这个值</li>
</ul>
<p>既然存在了<code>AMD</code>以及<code>CommonJs</code>机制，<code>ES6</code>的<code>Module</code>又有什么不一样？</p>
<p>ES6 在语言标准的层面上，实现了<code>Module</code>，即模块功能，完全可以取代 <code>CommonJS</code>和 <code>AMD</code>规范，成为浏览器和服务器通用的模块解决方案</p>
<p><code>CommonJS</code> 和<code>AMD</code> 模块，都只能在运行时确定这些东西。比如，<code>CommonJS</code>模块就是对象，输入时必须查找对象属性</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CommonJS模块</span></span><br><span class="line"><span class="keyword">let</span> &#123; stat, exists, readfile &#125; = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> _fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> stat = _fs.<span class="property">stat</span>;</span><br><span class="line"><span class="keyword">let</span> exists = _fs.<span class="property">exists</span>;</span><br><span class="line"><span class="keyword">let</span> readfile = _fs.<span class="property">readfile</span>;</span><br></pre></td></tr></table></figure>

<p><code>ES6</code>设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES6模块</span></span><br><span class="line"><span class="keyword">import</span> &#123; stat, exists, readFile &#125; <span class="keyword">from</span> <span class="string">&#x27;fs&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>上述代码，只加载3个方法，其他方法不加载，即 <code>ES6</code> 可以在编译时就完成模块加载</p>
<p>由于编译加载，使得静态分析成为可能。包括现在流行的<code>typeScript</code>也是依靠静态分析实现功能</p>
<h2 id="二、使用"><a href="#二、使用" class="headerlink" title="二、使用"></a>二、使用</h2><p><code>ES6</code>模块内部自动采用了严格模式，这里就不展开严格模式的限制，毕竟这是<code>ES5</code>之前就已经规定好</p>
<p>模块功能主要由两个命令构成：</p>
<ul>
<li><code>export</code>：用于规定模块的对外接口</li>
<li><code>import</code>：用于输入其他模块提供的功能</li>
</ul>
<h3 id="export"><a href="#export" class="headerlink" title="export"></a>export</h3><p>一个模块就是一个独立的文件，该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用<code>export</code>关键字输出该变量</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// profile.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> firstName = <span class="string">&#x27;Michael&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> lastName = <span class="string">&#x27;Jackson&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> year = <span class="number">1958</span>;</span><br><span class="line"></span><br><span class="line">或 </span><br><span class="line"><span class="comment">// 建议使用下面写法，这样能瞬间确定输出了哪些变量</span></span><br><span class="line"><span class="keyword">var</span> firstName = <span class="string">&#x27;Michael&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> lastName = <span class="string">&#x27;Jackson&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> year = <span class="number">1958</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; firstName, lastName, year &#125;;</span><br></pre></td></tr></table></figure>

<p>输出函数或类</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">multiply</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>通过<code>as</code>可以进行输出变量的重命名</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">v1</span>(<span class="params"></span>) &#123; ... &#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">v2</span>(<span class="params"></span>) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">  v1 <span class="keyword">as</span> streamV1,</span><br><span class="line">  v2 <span class="keyword">as</span> streamV2,</span><br><span class="line">  v2 <span class="keyword">as</span> streamLatestVersion</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="import"><a href="#import" class="headerlink" title="import"></a>import</h3><p>使用<code>export</code>命令定义了模块的对外接口以后，其他 JS 文件就可以通过<code>import</code>命令加载这个模块</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; firstName, lastName, year &#125; <span class="keyword">from</span> <span class="string">&#x27;./profile.js&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">setName</span>(<span class="params">element</span>) &#123;</span><br><span class="line">  element.<span class="property">textContent</span> = firstName + <span class="string">&#x27; &#x27;</span> + lastName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样如果想要输入变量起别名，通过<code>as</code>关键字</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; lastName <span class="keyword">as</span> surname &#125; <span class="keyword">from</span> <span class="string">&#x27;./profile.js&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>当加载整个模块的时候，需要用到星号<code>*</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// circle.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">area</span>(<span class="params">radius</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="property">PI</span> * radius * radius;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">circumference</span>(<span class="params">radius</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span> * <span class="title class_">Math</span>.<span class="property">PI</span> * radius;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> circle <span class="keyword">from</span> <span class="string">&#x27;./circle&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(circle)   <span class="comment">// &#123;area:area,circumference:circumference&#125;</span></span><br></pre></td></tr></table></figure>

<p>输入的变量都是只读的，不允许修改，但是如果是对象，允许修改属性</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;a&#125; <span class="keyword">from</span> <span class="string">&#x27;./xxx.js&#x27;</span></span><br><span class="line"></span><br><span class="line">a.<span class="property">foo</span> = <span class="string">&#x27;hello&#x27;</span>; <span class="comment">// 合法操作</span></span><br><span class="line">a = &#123;&#125;; <span class="comment">// Syntax Error : &#x27;a&#x27; is read-only;</span></span><br></pre></td></tr></table></figure>

<p>不过建议即使能修改，但我们不建议。因为修改之后，我们很难差错</p>
<p><code>import</code>后面我们常接着<code>from</code>关键字，<code>from</code>指定模块文件的位置，可以是相对路径，也可以是绝对路径</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; a &#125; <span class="keyword">from</span> <span class="string">&#x27;./a&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>如果只有一个模块名，需要有配置文件，告诉引擎模块的位置</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; myMethod &#125; <span class="keyword">from</span> <span class="string">&#x27;util&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>在编译阶段，<code>import</code>会提升到整个模块的头部，首先执行</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">foo</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="string">&#x27;my_module&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>多次重复执行同样的导入，只会执行一次</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;lodash&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;lodash&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>上面的情况，大家都能看到用户在导入模块的时候，需要知道加载的变量名和函数，否则无法加载</p>
<p>如果不需要知道变量名或函数就完成加载，就要用到<code>export default</code>命令，为模块指定默认输出</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// export-default.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加载该模块的时候，<code>import</code>命令可以为该函数指定任意名字</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// import-default.js</span></span><br><span class="line"><span class="keyword">import</span> customName <span class="keyword">from</span> <span class="string">&#x27;./export-default&#x27;</span>;</span><br><span class="line"><span class="title function_">customName</span>(); <span class="comment">// &#x27;foo&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="动态加载"><a href="#动态加载" class="headerlink" title="动态加载"></a>动态加载</h3><p>允许您仅在需要时动态加载模块，而不必预先加载所有模块，这存在明显的性能优势</p>
<p>这个新功能允许您将<code>import()</code>作为函数调用，将其作为参数传递给模块的路径。 它返回一个 <code>promise</code>，它用一个模块对象来实现，让你可以访问该对象的导出</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">import</span>(<span class="string">&#x27;/modules/myModule.mjs&#x27;</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params"><span class="variable language_">module</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// Do something with the module.</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<h3 id="复合写法"><a href="#复合写法" class="headerlink" title="复合写法"></a>复合写法</h3><p>如果在一个模块之中，先输入后输出同一个模块，<code>import</code>语句可以与<code>export</code>语句写在一起</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123; foo, bar &#125; <span class="keyword">from</span> <span class="string">&#x27;my_module&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以简单理解为</span></span><br><span class="line"><span class="keyword">import</span> &#123; foo, bar &#125; <span class="keyword">from</span> <span class="string">&#x27;my_module&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; foo, bar &#125;;</span><br></pre></td></tr></table></figure>

<p>同理能够搭配<code>as</code>、<code>*</code>搭配使用</p>
<h2 id="三、使用场景"><a href="#三、使用场景" class="headerlink" title="三、使用场景"></a>三、使用场景</h2><p>如今，<code>ES6</code>模块化已经深入我们日常项目开发中，像<code>vue</code>、<code>react</code>项目搭建项目，组件化开发处处可见，其也是依赖模块化实现</p>
<p><code>vue</code>组件</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;App&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      组件化开发 ---- 模块化</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">name</span>: <span class="string">&#x27;HelloWorld&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">props</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">msg</span>: <span class="title class_">String</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p><code>react</code>组件</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;App&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">		组件化开发 ---- 模块化</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure>

<p>包括完成一些复杂应用的时候，我们也可以拆分成各个模块</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/04/02/html+css+js+ts/4-module/" data-id="cl7k9sbhs00co98u07fd14c3c" data-title="ES6 module" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/es6/" rel="tag">es6</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-html+css+js+ts/4-Generator" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/04/01/html+css+js+ts/4-Generator/" class="article-date">
  <time class="dt-published" datetime="2018-04-01T14:53:15.000Z" itemprop="datePublished">2018-04-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/04/01/html+css+js+ts/4-Generator/">ES6 Generator</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="一、什么是Generator-函数"><a href="#一、什么是Generator-函数" class="headerlink" title="一、什么是Generator 函数"></a>一、什么是Generator 函数</h2><h3 id="1-1-语法"><a href="#1-1-语法" class="headerlink" title="1.1 语法"></a>1.1 语法</h3><blockquote>
<p>学习 <code>Generator</code> 语法，你需要了解<code>function*</code> 、<code>yield</code>、<code>next</code>三个基本概念。</p>
</blockquote>
<ul>
<li><code>function*</code> 用来声明一个函数是生成器函数，它比普通的函数声明多了一个<code>*</code>,<code>*</code>的位置比较随意可以挨着 <code>function</code> 关键字，也可以挨着函数名</li>
<li><code>yield</code> 产出的意思，这个关键字只能出现在生成器函数体内，但是生成器中也可以没有<code>yield</code> 关键字，函数遇到 <code>yield</code> 的时候会暂停，并把 <code>yield</code> 后面的表达式结果抛出去</li>
<li><code>next</code>作用是将代码的控制权交还给生成器函数</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 声明生成器函数</span><br><span class="line">function* generator() &#123;</span><br><span class="line">    // A</span><br><span class="line">    yield &#x27;foo&#x27;</span><br><span class="line">    // B</span><br><span class="line">&#125;</span><br><span class="line">// 获取生成器对象</span><br><span class="line">let g = generator();</span><br><span class="line">// 第一个 next()，首次启动生成器</span><br><span class="line">g.next(); // &#123;value: &quot;foo&quot;, done: false&#125;</span><br><span class="line">// 唤醒被 yield 暂停的状态</span><br><span class="line">g.next();</span><br><span class="line">// &#123;value: undefined, done: true&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-过程分析"><a href="#1-2-过程分析" class="headerlink" title="1.2 过程分析"></a>1.2 过程分析</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 分析一个简单例子</span><br><span class="line">function* helloGenerator() &#123;</span><br><span class="line">   yield &quot;hello&quot;;</span><br><span class="line">   yield &quot;generator&quot;;</span><br><span class="line">   return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var h = helloGenerator();</span><br><span class="line"></span><br><span class="line">console.log(h.next());//&#123; value: &#x27;hello&#x27;, done: false &#125;</span><br><span class="line">console.log(h.next());//&#123; value: &#x27;generator&#x27;, done: false &#125;</span><br><span class="line">console.log(h.next());//&#123; value: &#x27;undefined&#x27;, done: true &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>创建了<code>h</code>对象，指向<code>helloGenerator</code>的句柄</li>
<li>第一次调用<code>next()</code>，执行到<code>&quot;yield hello&quot;</code>，暂缓执行,并返回了<code>&quot;hello&quot;</code></li>
<li>第二次调用<code>next()</code>，继续上一次的执行，执行到<code>&quot;yield generator&quot;</code>,暂缓执行，并返回了<code>&quot;generator&quot;</code>。</li>
<li>第三次调用<code>next()</code>,直接执行<code>return</code>，并返回<code>done:true</code>，表明结束</li>
</ul>
<blockquote>
<p>经过上面的分析，<code>yield</code>实际就是暂缓执行的标示，每执行一次<code>next()</code>，相当于指针移动到下一个<code>yield</code>位置</p>
</blockquote>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/54.png" alt="img"></p>
<p><strong>总结一下</strong>，<code>Generator</code>函数是<code>ES6</code>提供的一种异步编程解决方案。通过<code>yield</code>标识位和<code>next()</code>方法调用，实现函数的分段执行</p>
<h3 id="1-3-yield-表达式"><a href="#1-3-yield-表达式" class="headerlink" title="1.3 yield 表达式"></a>1.3 yield 表达式</h3><blockquote>
<p><code>yield</code>是<code>Generator</code>函数的暂缓执行的标识，对于<code>yield</code>只能配合<code>Generator</code>函数使用，在普通的函数中使用会报错</p>
</blockquote>
<p><code>Generator</code>函数中还有一种<code>yield*</code>这个表达方式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function* foo()&#123;</span><br><span class="line">   	yield &quot;a&quot;;</span><br><span class="line">   	yield &quot;b&quot;;</span><br><span class="line">   &#125;</span><br><span class="line">   function* gen(x,y)&#123;</span><br><span class="line">   	  yield 1;</span><br><span class="line">   	  yield 2;</span><br><span class="line">   	  yield* foo();</span><br><span class="line">   	  yield 3;</span><br><span class="line">   &#125;</span><br><span class="line">   var g = gen();</span><br><span class="line">   console.log(g.next());//&#123;value: 1, done: false&#125;</span><br><span class="line">   console.log(g.next());//&#123;value: 2, done: false&#125;</span><br><span class="line">   console.log(g.next());//&#123;value: &quot;a&quot;, done: true&#125;</span><br><span class="line">   console.log(g.next());//&#123;value: &quot;b&quot;, done: true&#125;</span><br><span class="line">   console.log(g.next());//&#123;value: &quot;3&quot;, done: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当执行<code>yield*</code>时，实际是遍历后面的<code>Generator</code>函数，等价于下面的写法：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function* foo()&#123;</span><br><span class="line">   	yield &quot;a&quot;;</span><br><span class="line">   	yield &quot;b&quot;;</span><br><span class="line">&#125;</span><br><span class="line">function* gen(x,y)&#123;</span><br><span class="line">    yield 1;</span><br><span class="line">    yield 2;</span><br><span class="line">    </span><br><span class="line">    for(var value of foo())&#123;</span><br><span class="line">      yield value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    yield 3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：<code>yield</code> 后面只能适配<code>Generator</code>函数</p>
<h2 id="二、Generator应用场景"><a href="#二、Generator应用场景" class="headerlink" title="二、Generator应用场景"></a>二、Generator应用场景</h2><h3 id="2-1-异步操作的同步化表达"><a href="#2-1-异步操作的同步化表达" class="headerlink" title="2.1 异步操作的同步化表达"></a>2.1 异步操作的同步化表达</h3><blockquote>
<p><code>Generator</code>函数的暂停执行的效果，意味着可以把异步操作写在<code>yield</code>表达式里面，等到调用<code>next</code>方法时再往后执行。这实际上等同于不需要写回调函数了，因为异步操作的后续操作可以放在<code>yield</code>表达式下面，反正要等到调用<code>next</code>方法时再执行。所以，<code>Generator</code>函数的一个重要实际意义就是用来处理异步操作，改写回调函数</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function* loadUI() &#123;</span><br><span class="line">  showLoadingScreen();</span><br><span class="line">  yield loadUIDataAsynchronously();</span><br><span class="line">  hideLoadingScreen();</span><br><span class="line">&#125;</span><br><span class="line">var loader = loadUI();</span><br><span class="line">// 加载UI</span><br><span class="line">loader.next()</span><br><span class="line"></span><br><span class="line">// 卸载UI</span><br><span class="line">loader.next()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面代码中，第一次调用<code>loadUI</code>函数时，该函数不会执行，仅返回一个遍历器。下一次对该遍历器调用<code>next</code>方法，则会显示<code>Loading</code>界面，并且异步加载数据。等到数据加载完成，再一次使用next方法，则会隐藏<code>Loading</code>界面。可以看到，这种写法的好处是所有<code>Loading</code>界面的逻辑，都被封装在一个函数，按部就班非常清晰</p>
</blockquote>
<ul>
<li>通过<code>Generator</code>函数部署<code>Ajax</code>操作，可以用同步的方式表达。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function* main() &#123;</span><br><span class="line">  var result = yield request(&quot;http://some.url&quot;);</span><br><span class="line">  var resp = JSON.parse(result);</span><br><span class="line">    console.log(resp.value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function request(url) &#123;</span><br><span class="line">  makeAjaxCall(url, function(response)&#123;</span><br><span class="line">    it.next(response);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var it = main();</span><br><span class="line">it.next();</span><br></pre></td></tr></table></figure>

<h3 id="2-2-控制流管理"><a href="#2-2-控制流管理" class="headerlink" title="2.2 控制流管理"></a>2.2 控制流管理</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 异步函数</span><br><span class="line"></span><br><span class="line">function getDataAsync (url) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            var res = &#123;</span><br><span class="line">                url: url,</span><br><span class="line">                data: Math.random()</span><br><span class="line">            &#125;</span><br><span class="line">            resolve(res)</span><br><span class="line">        &#125;, 1000)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用 <code>Generator</code> 函数可以这样写</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function * getData () &#123;</span><br><span class="line">    var res1 = yield getDataAsync(&#x27;/page/1?param=123&#x27;)</span><br><span class="line">    console.log(res1)</span><br><span class="line">    var res2 = yield getDataAsync(`/page/2?param=$&#123;res1.data&#125;`)</span><br><span class="line">    console.log(res2)</span><br><span class="line">    var res3 = yield getDataAsync(`/page/2?param=$&#123;res2.data&#125;`)</span><br><span class="line">    console.log(res3))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>然后我们这样逐步执行</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var g = getData()</span><br><span class="line">g.next().value.then(res1 =&gt; &#123;</span><br><span class="line">    g.next(res1).value.then(res2 =&gt; &#123;</span><br><span class="line">        g.next(res2).value.then(() =&gt; &#123;</span><br><span class="line">            g.next()</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面的代码，我们逐步调用遍历器的 <code>next()</code>方法，由于每一个 <code>next()</code> 方法返回值的 <code>value</code> 属性为一个 <code>Promise</code> 对象，所以我们为其添加 <code>then</code>方法， 在 <code>then</code> 方法里面接着运行 <code>next</code> 方法挪移遍历器指针，直到 <code>Generator</code> 函数运行完成，实际上，这个过程我们不必手动完成，可以封装成一个简单的执行器</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function run (gen) &#123;</span><br><span class="line">    var g = gen()</span><br><span class="line"></span><br><span class="line">    function next (data) &#123;</span><br><span class="line">        var res = g.next(data)</span><br><span class="line">        if (res.done) return res.value</span><br><span class="line">        res.value.then((data) =&gt; &#123;</span><br><span class="line">            next(data)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    next()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>run</code>方法用来自动运行异步的 <code>Generator</code> 函数，其实就是一个递归的过程调用的过程。这样我们就不必手动执行 <code>Generator</code> 函数了。 有了 <code>run</code> 方法，我们只需要这样运行 <code>getData</code> 方法</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run(getData)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这样，我们就可以把异步操作封装到 <code>Generator</code> 函数内部，使用 <code>run</code>方法作为 <code>Generator</code> 函数的自执行器，来处理异步。其实我们不难发现， <code>async/await</code> 方法相比于 <code>Generator</code> 处理异步的方式，有很多相似的地方，只不过 async&#x2F;await 在语义化方面更加明显，同时 <code>async/await</code> 不需要我们手写执行器，其内部已经帮我们封装好了，这就是为什么说 <code>async/await</code>是 <code>Generator</code>函数处理异步的语法糖了</p>
</blockquote>
<h3 id="2-3-部署-Iterator-接口"><a href="#2-3-部署-Iterator-接口" class="headerlink" title="2.3 部署 Iterator 接口"></a>2.3 部署 Iterator 接口</h3><blockquote>
<p>利用 <code>Generator</code> 函数，可以在任意对象上部署 <code>Iterator</code> 接口。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function* iterEntries(obj) &#123;</span><br><span class="line">  let keys = Object.keys(obj);</span><br><span class="line">  for (let i=0; i &lt; keys.length; i++) &#123;</span><br><span class="line">    let key = keys[i];</span><br><span class="line">    yield [key, obj[key]];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let myObj = &#123; foo: 3, bar: 7 &#125;;</span><br><span class="line"></span><br><span class="line">for (let [key, value] of iterEntries(myObj)) &#123;</span><br><span class="line">  console.log(key, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// foo 3</span><br><span class="line">// bar 7</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上述代码中，<code>myObj</code>是一个普通对象，通过<code>iterEntries</code>函数，就有了 <code>Iterator</code> 接口。也就是说，可以在任意对象上部署<code>next</code>方法</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 下面是一个对数组部署 Iterator 接口的例子，尽管数组原生具有这个接口</span><br><span class="line"></span><br><span class="line">function* makeSimpleGenerator(array)&#123;</span><br><span class="line">  var nextIndex = 0;</span><br><span class="line"></span><br><span class="line">  while(nextIndex &lt; array.length)&#123;</span><br><span class="line">    yield array[nextIndex++];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var gen = makeSimpleGenerator([&#x27;yo&#x27;, &#x27;ya&#x27;]);</span><br><span class="line"></span><br><span class="line">gen.next().value // &#x27;yo&#x27;</span><br><span class="line">gen.next().value // &#x27;ya&#x27;</span><br><span class="line">gen.next().done  // true</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/04/01/html+css+js+ts/4-Generator/" data-id="cl7k9sbhn00bx98u02el82uxy" data-title="ES6 Generator" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/es6/" rel="tag">es6</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-html+css+js+ts/4-es6-数组扩展" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/03/30/html+css+js+ts/4-es6-%E6%95%B0%E7%BB%84%E6%89%A9%E5%B1%95/" class="article-date">
  <time class="dt-published" datetime="2018-03-30T01:14:49.000Z" itemprop="datePublished">2018-03-30</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/03/30/html+css+js+ts/4-es6-%E6%95%B0%E7%BB%84%E6%89%A9%E5%B1%95/">es6数组扩展</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="一、扩展运算符的应用"><a href="#一、扩展运算符的应用" class="headerlink" title="一、扩展运算符的应用"></a>一、扩展运算符的应用</h2><p>ES6通过扩展元素符<code>...</code>，好比 <code>rest</code> 参数的逆运算，将一个数组转为用逗号分隔的参数序列</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(...[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="comment">// 1 2 3</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>, ...[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="number">5</span>)</span><br><span class="line"><span class="comment">// 1 2 3 4 5</span></span><br><span class="line"></span><br><span class="line">[...<span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;div&#x27;</span>)]</span><br><span class="line"><span class="comment">// [&lt;div&gt;, &lt;div&gt;, &lt;div&gt;]</span></span><br></pre></td></tr></table></figure>

<p>主要用于函数调用的时候，将一个数组变为参数序列</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">push</span>(<span class="params">array, ...items</span>) &#123;</span><br><span class="line">  array.<span class="title function_">push</span>(...items);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> numbers = [<span class="number">4</span>, <span class="number">38</span>];</span><br><span class="line"><span class="title function_">add</span>(...numbers) <span class="comment">// 42</span></span><br></pre></td></tr></table></figure>

<p>可以将某些数据结构转为数组</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[...<span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;div&#x27;</span>)]</span><br></pre></td></tr></table></figure>

<p>能够更简单实现数组复制</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a1 = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">const</span> [...a2] = a1;</span><br><span class="line"><span class="comment">// [1,2]</span></span><br></pre></td></tr></table></figure>

<p>数组的合并也更为简洁了</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> arr3 = [<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>];</span><br><span class="line">[...arr1, ...arr2, ...arr3]</span><br><span class="line"><span class="comment">// [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27; ]</span></span><br></pre></td></tr></table></figure>

<p>注意：通过扩展运算符实现的是浅拷贝，修改了引用指向的值，会同步反映到新数组</p>
<p>下面看个例子就清楚多了</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>,[<span class="number">1</span>,<span class="number">2</span>]];</span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> arr3  = [...arr1,...arr2]</span><br><span class="line">arr[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">9999</span> <span class="comment">// 修改arr1里面数组成员值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr[<span class="number">3</span>]) <span class="comment">// 影响到arr3,[&#x27;a&#x27;,&#x27;b&#x27;,[9999,2],&#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure>

<p>扩展运算符可以与解构赋值结合起来，用于生成数组</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [first, ...rest] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">first <span class="comment">// 1</span></span><br><span class="line">rest  <span class="comment">// [2, 3, 4, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [first, ...rest] = [];</span><br><span class="line">first <span class="comment">// undefined</span></span><br><span class="line">rest  <span class="comment">// []</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [first, ...rest] = [<span class="string">&quot;foo&quot;</span>];</span><br><span class="line">first  <span class="comment">// &quot;foo&quot;</span></span><br><span class="line">rest   <span class="comment">// []</span></span><br></pre></td></tr></table></figure>

<p>如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [...butLast, last] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [first, ...middle, last] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>



<p>可以将字符串转为真正的数组</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[...<span class="string">&#x27;hello&#x27;</span>]</span><br><span class="line"><span class="comment">// [ &quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot; ]</span></span><br></pre></td></tr></table></figure>

<p>定义了遍历器（Iterator）接口的对象，都可以用扩展运算符转为真正的数组</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> nodeList = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> array = [...nodeList];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>([</span><br><span class="line">  [<span class="number">1</span>, <span class="string">&#x27;one&#x27;</span>],</span><br><span class="line">  [<span class="number">2</span>, <span class="string">&#x27;two&#x27;</span>],</span><br><span class="line">  [<span class="number">3</span>, <span class="string">&#x27;three&#x27;</span>],</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [...map.<span class="title function_">keys</span>()]; <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>

<p>如果对没有 Iterator 接口的对象，使用扩展运算符，将会报错</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> arr = [...obj]; <span class="comment">// TypeError: Cannot spread non-iterable object</span></span><br></pre></td></tr></table></figure>

<h2 id="二、构造函数新增的方法"><a href="#二、构造函数新增的方法" class="headerlink" title="二、构造函数新增的方法"></a>二、构造函数新增的方法</h2><p>关于构造函数，数组新增的方法有如下：</p>
<ul>
<li>Array.from()</li>
<li>Array.of()</li>
</ul>
<h3 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from()"></a>Array.from()</h3><p>将两类对象转为真正的数组：类似数组的对象和可遍历<code>（iterable）</code>的对象（包括 <code>ES6</code> 新增的数据结构 <code>Set</code> 和 <code>Map</code>）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arrayLike = &#123;</span><br><span class="line">    <span class="string">&#x27;0&#x27;</span>: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;1&#x27;</span>: <span class="string">&#x27;b&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;2&#x27;</span>: <span class="string">&#x27;c&#x27;</span>,</span><br><span class="line">    <span class="attr">length</span>: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> arr2 = <span class="title class_">Array</span>.<span class="title function_">from</span>(arrayLike); <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure>

<p>还可以接受第二个参数，用来对每个元素进行处理，将处理后的值放入返回的数组</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="title function_">from</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="function">(<span class="params">x</span>) =&gt;</span> x * x)</span><br><span class="line"><span class="comment">// [1, 4, 9]</span></span><br></pre></td></tr></table></figure>

<h3 id="Array-of"><a href="#Array-of" class="headerlink" title="Array.of()"></a>Array.of()</h3><p>用于将一组值，转换为数组</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="title function_">of</span>(<span class="number">3</span>, <span class="number">11</span>, <span class="number">8</span>) <span class="comment">// [3,11,8]</span></span><br></pre></td></tr></table></figure>

<p>没有参数的时候，返回一个空数组</p>
<p>当参数只有一个的时候，实际上是指定数组的长度</p>
<p>参数个数不少于 2 个时，<code>Array()</code>才会返回由参数组成的新数组</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>() <span class="comment">// []</span></span><br><span class="line"><span class="title class_">Array</span>(<span class="number">3</span>) <span class="comment">// [, , ,]</span></span><br><span class="line"><span class="title class_">Array</span>(<span class="number">3</span>, <span class="number">11</span>, <span class="number">8</span>) <span class="comment">// [3, 11, 8]</span></span><br></pre></td></tr></table></figure>

<h3 id="三、实例对象新增的方法"><a href="#三、实例对象新增的方法" class="headerlink" title="三、实例对象新增的方法"></a>三、实例对象新增的方法</h3><p>关于数组实例对象新增的方法有如下：</p>
<ul>
<li>copyWithin()</li>
<li>find()、findIndex()</li>
<li>fill()</li>
<li>entries()，keys()，values()</li>
<li>includes()</li>
<li>flat()，flatMap()</li>
</ul>
<h3 id="copyWithin"><a href="#copyWithin" class="headerlink" title="copyWithin()"></a>copyWithin()</h3><p>将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组</p>
<p>参数如下：</p>
<ul>
<li>target（必需）：从该位置开始替换数据。如果为负值，表示倒数。</li>
<li>start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示从末尾开始计算。</li>
<li>end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示从末尾开始计算。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].<span class="title function_">copyWithin</span>(<span class="number">0</span>, <span class="number">3</span>) <span class="comment">// 将从 3 号位直到数组结束的成员（4 和 5），复制到从 0 号位开始的位置，结果覆盖了原来的 1 和 2</span></span><br><span class="line"><span class="comment">// [4, 5, 3, 4, 5] </span></span><br></pre></td></tr></table></figure>

<h3 id="find-、findIndex"><a href="#find-、findIndex" class="headerlink" title="find()、findIndex()"></a>find()、findIndex()</h3><p><code>find()</code>用于找出第一个符合条件的数组成员</p>
<p>参数是一个回调函数，接受三个参数依次为当前的值、当前的位置和原数组</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>].<span class="title function_">find</span>(<span class="keyword">function</span>(<span class="params">value, index, arr</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> value &gt; <span class="number">9</span>;</span><br><span class="line">&#125;) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">findIndex`返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回`-1</span><br><span class="line">[1, 5, 10, 15].findIndex(function(value, index, arr) &#123;</span><br><span class="line">  return value &gt; 9;</span><br><span class="line">&#125;) // 2</span><br></pre></td></tr></table></figure>

<p>这两个方法都可以接受第二个参数，用来绑定回调函数的<code>this</code>对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">v</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> v &gt; <span class="variable language_">this</span>.<span class="property">age</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person = &#123;<span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span>, <span class="attr">age</span>: <span class="number">20</span>&#125;;</span><br><span class="line">[<span class="number">10</span>, <span class="number">12</span>, <span class="number">26</span>, <span class="number">15</span>].<span class="title function_">find</span>(f, person);    <span class="comment">// 26</span></span><br></pre></td></tr></table></figure>

<h3 id="fill"><a href="#fill" class="headerlink" title="fill()"></a>fill()</h3><p>使用给定值，填充一个数组</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>].<span class="title function_">fill</span>(<span class="number">7</span>)</span><br><span class="line"><span class="comment">// [7, 7, 7]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">3</span>).<span class="title function_">fill</span>(<span class="number">7</span>)</span><br><span class="line"><span class="comment">// [7, 7, 7]</span></span><br></pre></td></tr></table></figure>

<p>还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>].<span class="title function_">fill</span>(<span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment">// [&#x27;a&#x27;, 7, &#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure>

<p>注意，如果填充的类型为对象，则是浅拷贝</p>
<h3 id="entries-，keys-，values"><a href="#entries-，keys-，values" class="headerlink" title="entries()，keys()，values()"></a>entries()，keys()，values()</h3><p><code>keys()</code>是对键名的遍历、<code>values()</code>是对键值的遍历，<code>entries()</code>是对键值对的遍历</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">or (<span class="keyword">let</span> index <span class="keyword">of</span> [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>].<span class="title function_">keys</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> elem <span class="keyword">of</span> [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>].<span class="title function_">values</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(elem);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &#x27;a&#x27;</span></span><br><span class="line"><span class="comment">// &#x27;b&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [index, elem] <span class="keyword">of</span> [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>].<span class="title function_">entries</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(index, elem);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0 &quot;a&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="includes"><a href="#includes" class="headerlink" title="includes()"></a>includes()</h3><p>用于判断数组是否包含给定的值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="title function_">includes</span>(<span class="number">2</span>)     <span class="comment">// true</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="title function_">includes</span>(<span class="number">4</span>)     <span class="comment">// false</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="title class_">NaN</span>].<span class="title function_">includes</span>(<span class="title class_">NaN</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>方法的第二个参数表示搜索的起始位置，默认为<code>0</code></p>
<p>参数为负数则表示倒数的位置</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="title function_">includes</span>(<span class="number">3</span>, <span class="number">3</span>);  <span class="comment">// false</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="title function_">includes</span>(<span class="number">3</span>, -<span class="number">1</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="flat-，flatMap"><a href="#flat-，flatMap" class="headerlink" title="flat()，flatMap()"></a>flat()，flatMap()</h3><p>将数组扁平化处理，返回一个新数组，对原数据没有影响</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]].<span class="title function_">flat</span>()</span><br><span class="line"><span class="comment">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>

<p><code>flat()</code>默认只会“拉平”一层，如果想要“拉平”多层的嵌套数组，可以将<code>flat()</code>方法的参数写成一个整数，表示想要拉平的层数，默认为1</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]]].<span class="title function_">flat</span>()</span><br><span class="line"><span class="comment">// [1, 2, 3, [4, 5]]</span></span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]]].<span class="title function_">flat</span>(<span class="number">2</span>)</span><br><span class="line"><span class="comment">// [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>

<p><code>flatMap()</code>方法对原数组的每个成员执行一个函数相当于执行<code>Array.prototype.map()</code>，然后对返回值组成的数组执行<code>flat()</code>方法。该方法返回一个新数组，不改变原数组</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 相当于 [[2, 4], [3, 6], [4, 8]].flat()</span></span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].<span class="title function_">flatMap</span>(<span class="function">(<span class="params">x</span>) =&gt;</span> [x, x * <span class="number">2</span>])</span><br><span class="line"><span class="comment">// [2, 4, 3, 6, 4, 8]</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flatMap()`方法还可以有第二个参数，用来绑定遍历函数里面的`this</span><br></pre></td></tr></table></figure>

<h3 id="四、数组的空位"><a href="#四、数组的空位" class="headerlink" title="四、数组的空位"></a>四、数组的空位</h3><p>数组的空位指，数组的某一个位置没有任何值</p>
<p>ES6 则是明确将空位转为<code>undefined</code>，包括<code>Array.from</code>、扩展运算符、<code>copyWithin()</code>、<code>fill()</code>、<code>entries()</code>、<code>keys()</code>、<code>values()</code>、<code>find()</code>和<code>findIndex()</code></p>
<p>建议大家在日常书写中，避免出现空位</p>
<h3 id="五、排序稳定性"><a href="#五、排序稳定性" class="headerlink" title="五、排序稳定性"></a>五、排序稳定性</h3><p>将<code>sort()</code>默认设置为稳定的排序算法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [</span><br><span class="line">  <span class="string">&#x27;peach&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;straw&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;apple&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;spork&#x27;</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">stableSorting</span> = (<span class="params">s1, s2</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (s1[<span class="number">0</span>] &lt; s2[<span class="number">0</span>]) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">arr.<span class="title function_">sort</span>(stableSorting)</span><br><span class="line"><span class="comment">// [&quot;apple&quot;, &quot;peach&quot;, &quot;straw&quot;, &quot;spork&quot;]</span></span><br></pre></td></tr></table></figure>

<p>排序结果中，<code>straw</code>在<code>spork</code>的前面，跟原始顺序一致</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/03/30/html+css+js+ts/4-es6-%E6%95%B0%E7%BB%84%E6%89%A9%E5%B1%95/" data-id="cl7k9sbht00cu98u0bbe5d8qn" data-title="es6数组扩展" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/es6/" rel="tag">es6</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-html+css+js+ts/4-es6-函数扩展" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/03/27/html+css+js+ts/4-es6-%E5%87%BD%E6%95%B0%E6%89%A9%E5%B1%95/" class="article-date">
  <time class="dt-published" datetime="2018-03-27T08:28:18.000Z" itemprop="datePublished">2018-03-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/03/27/html+css+js+ts/4-es6-%E5%87%BD%E6%95%B0%E6%89%A9%E5%B1%95/">es6函数扩展</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="一、参数"><a href="#一、参数" class="headerlink" title="一、参数"></a>一、参数</h2><p>ES6&#96;允许为函数的参数设置默认值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">log</span>(<span class="params">x, y = <span class="string">&#x27;World&#x27;</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello&#x27;</span>) <span class="comment">// Hello World</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello&#x27;</span>, <span class="string">&#x27;China&#x27;</span>) <span class="comment">// Hello China</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello&#x27;</span>, <span class="string">&#x27;&#x27;</span>) <span class="comment">// Hello</span></span><br></pre></td></tr></table></figure>

<p>函数的形参是默认声明的，不能使用<code>let</code>或<code>const</code>再次声明</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">x = <span class="number">5</span></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">1</span>; <span class="comment">// error</span></span><br><span class="line">    <span class="keyword">const</span> x = <span class="number">2</span>; <span class="comment">// error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参数默认值可以与解构赋值的默认值结合起来使用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">&#123;x, y = <span class="number">5</span>&#125;</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>(&#123;&#125;) <span class="comment">// undefined 5</span></span><br><span class="line"><span class="title function_">foo</span>(&#123;<span class="attr">x</span>: <span class="number">1</span>&#125;) <span class="comment">// 1 5</span></span><br><span class="line"><span class="title function_">foo</span>(&#123;<span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>&#125;) <span class="comment">// 1 2</span></span><br><span class="line"><span class="title function_">foo</span>() <span class="comment">// TypeError: Cannot read property &#x27;x&#x27; of undefined</span></span><br></pre></td></tr></table></figure>

<p>上面的<code>foo</code>函数，当参数为对象的时候才能进行解构，如果没有提供参数的时候，变量<code>x</code>和<code>y</code>就不会生成，从而报错，这里设置默认值避免</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">&#123;x, y = <span class="number">5</span>&#125; = &#123;&#125;</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>() <span class="comment">// undefined 5</span></span><br></pre></td></tr></table></figure>

<p>参数默认值应该是函数的尾参数，如果不是非尾部的参数设置默认值，实际上这个参数是没发省略的</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x = <span class="number">1</span>, y</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>() <span class="comment">// [1, undefined]</span></span><br><span class="line"><span class="title function_">f</span>(<span class="number">2</span>) <span class="comment">// [2, undefined]</span></span><br><span class="line"><span class="title function_">f</span>(, <span class="number">1</span>) <span class="comment">// 报错</span></span><br><span class="line"><span class="title function_">f</span>(<span class="literal">undefined</span>, <span class="number">1</span>) <span class="comment">// [1, 1]</span></span><br></pre></td></tr></table></figure>

<h2 id="二、属性"><a href="#二、属性" class="headerlink" title="二、属性"></a>二、属性</h2><h3 id="函数的length属性"><a href="#函数的length属性" class="headerlink" title="函数的length属性"></a>函数的length属性</h3><p><code>length</code>将返回没有指定默认值的参数个数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span> (<span class="params">a</span>) &#123;&#125;).<span class="property">length</span> <span class="comment">// 1</span></span><br><span class="line">(<span class="keyword">function</span> (<span class="params">a = <span class="number">5</span></span>) &#123;&#125;).<span class="property">length</span> <span class="comment">// 0</span></span><br><span class="line">(<span class="keyword">function</span> (<span class="params">a, b, c = <span class="number">5</span></span>) &#123;&#125;).<span class="property">length</span> <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p><code>rest</code> 参数也不会计入<code>length</code>属性</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span>(<span class="params">...args</span>) &#123;&#125;).<span class="property">length</span> <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<p>如果设置了默认值的参数不是尾参数，那么<code>length</code>属性也不再计入后面的参数了</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span> (<span class="params">a = <span class="number">0</span>, b, c</span>) &#123;&#125;).<span class="property">length</span> <span class="comment">// 0</span></span><br><span class="line">(<span class="keyword">function</span> (<span class="params">a, b = <span class="number">1</span>, c</span>) &#123;&#125;).<span class="property">length</span> <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<h3 id="name属性"><a href="#name属性" class="headerlink" title="name属性"></a>name属性</h3><p>返回该函数的函数名</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5</span></span><br><span class="line">f.<span class="property">name</span> <span class="comment">// &quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6</span></span><br><span class="line">f.<span class="property">name</span> <span class="comment">// &quot;f&quot;</span></span><br></pre></td></tr></table></figure>

<p>如果将一个具名函数赋值给一个变量，则 <code>name</code>属性都返回这个具名函数原本的名字</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bar = <span class="keyword">function</span> <span class="title function_">baz</span>(<span class="params"></span>) &#123;&#125;;</span><br><span class="line">bar.<span class="property">name</span> <span class="comment">// &quot;baz&quot;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Function`构造函数返回的函数实例，`name`属性的值为`anonymous</span><br><span class="line">(new Function).name // &quot;anonymous&quot;</span><br></pre></td></tr></table></figure>

<p><code>bind</code>返回的函数，<code>name</code>属性值会加上<code>bound</code>前缀</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;&#125;;</span><br><span class="line">foo.<span class="title function_">bind</span>(&#123;&#125;).<span class="property">name</span> <span class="comment">// &quot;bound foo&quot;</span></span><br><span class="line"></span><br><span class="line">(<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;).<span class="title function_">bind</span>(&#123;&#125;).<span class="property">name</span> <span class="comment">// &quot;bound &quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="三、作用域"><a href="#三、作用域" class="headerlink" title="三、作用域"></a>三、作用域</h2><p>一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域</p>
<p>等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值时，是不会出现的</p>
<p>下面例子中，<code>y=x</code>会形成一个单独作用域，<code>x</code>没有被定义，所以指向全局变量<code>x</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">y = x</span>) &#123; </span><br><span class="line">  <span class="comment">// 等同于 let y = x  </span></span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">2</span>; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>() <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<h2 id="四、严格模式"><a href="#四、严格模式" class="headerlink" title="四、严格模式"></a>四、严格模式</h2><p>只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">doSomething</span>(<span class="params">a, b = a</span>) &#123;</span><br><span class="line">  <span class="string">&#x27;use strict&#x27;</span>;</span><br><span class="line">  <span class="comment">// code</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">const</span> doSomething = <span class="keyword">function</span> (<span class="params">&#123;a, b&#125;</span>) &#123;</span><br><span class="line">  <span class="string">&#x27;use strict&#x27;</span>;</span><br><span class="line">  <span class="comment">// code</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">doSomething</span> = (<span class="params">...a</span>) =&gt; &#123;</span><br><span class="line">  <span class="string">&#x27;use strict&#x27;</span>;</span><br><span class="line">  <span class="comment">// code</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="comment">// 报错</span></span><br><span class="line">  <span class="title function_">doSomething</span>(<span class="params">&#123;a, b&#125;</span>) &#123;</span><br><span class="line">    <span class="string">&#x27;use strict&#x27;</span>;</span><br><span class="line">    <span class="comment">// code</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="五、箭头函数"><a href="#五、箭头函数" class="headerlink" title="五、箭头函数"></a>五、箭头函数</h2><p>使用“箭头”（<code>=&gt;</code>）定义函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title function_">f</span> = v =&gt; v;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">function</span> (<span class="params">v</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> v;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title function_">f</span> = (<span class="params"></span>) =&gt; <span class="number">5</span>;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="number">5</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="title function_">sum</span> = (<span class="params">num1, num2</span>) =&gt; num1 + num2;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> sum = <span class="keyword">function</span>(<span class="params">num1, num2</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用<code>return</code>语句返回</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title function_">sum</span> = (<span class="params">num1, num2</span>) =&gt; &#123; <span class="keyword">return</span> num1 + num2; &#125;</span><br></pre></td></tr></table></figure>

<p>如果返回对象，需要加括号将对象包裹</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">getTempItem</span> = id =&gt; (&#123; <span class="attr">id</span>: id, <span class="attr">name</span>: <span class="string">&quot;Temp&quot;</span> &#125;);</span><br></pre></td></tr></table></figure>

<p>注意点：</p>
<ul>
<li>函数体内的<code>this</code>对象，就是定义时所在的对象，而不是使用时所在的对象</li>
<li>不可以当作构造函数，也就是说，不可以使用<code>new</code>命令，否则会抛出一个错误</li>
<li>不可以使用<code>arguments</code>对象，该对象在函数体内不存在。如果要用，可以用 <code>rest</code> 参数代替</li>
<li>不可以使用<code>yield</code>命令，因此箭头函数不能用作 Generator 函数</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/03/27/html+css+js+ts/4-es6-%E5%87%BD%E6%95%B0%E6%89%A9%E5%B1%95/" data-id="cl7k9sbhr00ch98u0fc77gszf" data-title="es6函数扩展" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/es6/" rel="tag">es6</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-html+css+js+ts/4-es6-对象扩展.md" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/03/25/html+css+js+ts/4-es6-%E5%AF%B9%E8%B1%A1%E6%89%A9%E5%B1%95.md/" class="article-date">
  <time class="dt-published" datetime="2018-03-25T02:23:42.000Z" itemprop="datePublished">2018-03-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/03/25/html+css+js+ts/4-es6-%E5%AF%B9%E8%B1%A1%E6%89%A9%E5%B1%95.md/">es6对象扩展</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="一、属性的简写"><a href="#一、属性的简写" class="headerlink" title="一、属性的简写"></a>一、属性的简写</h2><p>ES6中，当对象键名与对应值名相等的时候，可以进行简写</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> baz = &#123;<span class="attr">foo</span>:foo&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">const</span> baz = &#123;foo&#125;</span><br></pre></td></tr></table></figure>

<p>方法也能够进行简写</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> o = &#123;</span><br><span class="line">  <span class="title function_">method</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello!&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> o = &#123;</span><br><span class="line">  <span class="attr">method</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello!&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在函数内作为返回值，也会变得方便很多</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getPoint</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> x = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">const</span> y = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;x, y&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">getPoint</span>()</span><br><span class="line"><span class="comment">// &#123;x:1, y:10&#125;</span></span><br></pre></td></tr></table></figure>

<p>注意：简写的对象方法不能用作构造函数，否则会报错</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">foo</span> = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> obj.<span class="title function_">f</span>() <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<h2 id="二、属性名表达式"><a href="#二、属性名表达式" class="headerlink" title="二、属性名表达式"></a>二、属性名表达式</h2><p>ES6 允许字面量定义对象时，将表达式放在括号内</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> lastWord = <span class="string">&#x27;last word&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = &#123;</span><br><span class="line">  <span class="string">&#x27;first word&#x27;</span>: <span class="string">&#x27;hello&#x27;</span>,</span><br><span class="line">  [lastWord]: <span class="string">&#x27;world&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">a[<span class="string">&#x27;first word&#x27;</span>] <span class="comment">// &quot;hello&quot;</span></span><br><span class="line">a[lastWord] <span class="comment">// &quot;world&quot;</span></span><br><span class="line">a[<span class="string">&#x27;last word&#x27;</span>] <span class="comment">// &quot;world&quot;</span></span><br></pre></td></tr></table></figure>

<p>表达式还可以用于定义方法名</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  [<span class="string">&#x27;h&#x27;</span> + <span class="string">&#x27;ello&#x27;</span>]() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;hi&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">hello</span>() <span class="comment">// hi</span></span><br></pre></td></tr></table></figure>

<p>注意，属性名表达式与简洁表示法，不能同时使用，会报错</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> bar = <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> baz = &#123; [foo] &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> baz = &#123; [foo]: <span class="string">&#x27;abc&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>注意，属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串<code>[object Object]</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> keyA = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> keyB = &#123;<span class="attr">b</span>: <span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myObject = &#123;</span><br><span class="line">  [keyA]: <span class="string">&#x27;valueA&#x27;</span>,</span><br><span class="line">  [keyB]: <span class="string">&#x27;valueB&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">myObject <span class="comment">// Object &#123;[object Object]: &quot;valueB&quot;&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="三、super关键字"><a href="#三、super关键字" class="headerlink" title="三、super关键字"></a>三、super关键字</h2><p><code>this</code>关键字总是指向函数所在的当前对象，ES6 又新增了另一个类似的关键字<code>super</code>，指向当前对象的原型对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> proto = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="string">&#x27;world&#x27;</span>,</span><br><span class="line">  <span class="title function_">find</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">super</span>.<span class="property">foo</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(obj, proto); <span class="comment">// 为obj设置原型对象</span></span><br><span class="line">obj.<span class="title function_">find</span>() <span class="comment">// &quot;hello&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="四、扩展运算符的应用"><a href="#四、扩展运算符的应用" class="headerlink" title="四、扩展运算符的应用"></a>四、扩展运算符的应用</h2><p>在解构赋值中，未被读取的可遍历的属性，分配到指定的对象上面</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; x, y, ...z &#125; = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">a</span>: <span class="number">3</span>, <span class="attr">b</span>: <span class="number">4</span> &#125;;</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line">y <span class="comment">// 2</span></span><br><span class="line">z <span class="comment">// &#123; a: 3, b: 4 &#125;</span></span><br></pre></td></tr></table></figure>

<p>注意：解构赋值必须是最后一个参数，否则会报错</p>
<p>解构赋值是浅拷贝</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">a</span>: &#123; <span class="attr">b</span>: <span class="number">1</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">let</span> &#123; ...x &#125; = obj;</span><br><span class="line">obj.<span class="property">a</span>.<span class="property">b</span> = <span class="number">2</span>; <span class="comment">// 修改obj里面a属性中键值</span></span><br><span class="line">x.<span class="property">a</span>.<span class="property">b</span> <span class="comment">// 2，影响到了结构出来x的值</span></span><br></pre></td></tr></table></figure>

<p>对象的扩展运算符等同于使用<code>Object.assign()</code>方法</p>
<h2 id="五、属性的遍历"><a href="#五、属性的遍历" class="headerlink" title="五、属性的遍历"></a>五、属性的遍历</h2><p>ES6 一共有 5 种方法可以遍历对象的属性。</p>
<ul>
<li>for…in：循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）</li>
<li>Object.keys(obj)：返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名</li>
<li>Object.getOwnPropertyNames(obj)：回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名</li>
<li>Object.getOwnPropertySymbols(obj)：返回一个数组，包含对象自身的所有 Symbol 属性的键名</li>
<li>Reflect.ownKeys(obj)：返回一个数组，包含对象自身的（不含继承的）所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举</li>
</ul>
<p>上述遍历，都遵守同样的属性遍历的次序规则：</p>
<ul>
<li>首先遍历所有数值键，按照数值升序排列</li>
<li>其次遍历所有字符串键，按照加入时间升序排列</li>
<li>最后遍历所有 Symbol 键，按照加入时间升序排</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(&#123; [<span class="title class_">Symbol</span>()]:<span class="number">0</span>, <span class="attr">b</span>:<span class="number">0</span>, <span class="number">10</span>:<span class="number">0</span>, <span class="number">2</span>:<span class="number">0</span>, <span class="attr">a</span>:<span class="number">0</span> &#125;)</span><br><span class="line"><span class="comment">// [&#x27;2&#x27;, &#x27;10&#x27;, &#x27;b&#x27;, &#x27;a&#x27;, Symbol()]</span></span><br></pre></td></tr></table></figure>

<h2 id="六、对象新增的方法"><a href="#六、对象新增的方法" class="headerlink" title="六、对象新增的方法"></a>六、对象新增的方法</h2><p>关于对象新增的方法，分别有以下：</p>
<ul>
<li>Object.is()</li>
<li>Object.assign()</li>
<li>Object.getOwnPropertyDescriptors()</li>
<li>Object.setPrototypeOf()，Object.getPrototypeOf()</li>
<li>Object.keys()，Object.values()，Object.entries()</li>
<li>Object.fromEntries()</li>
</ul>
<h3 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is()"></a>Object.is()</h3><p>严格判断两个值是否相等，与严格比较运算符（&#x3D;&#x3D;&#x3D;）的行为基本一致，不同之处只有两个：一是<code>+0</code>不等于<code>-0</code>，二是<code>NaN</code>等于自身</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+<span class="number">0</span> === -<span class="number">0</span> <span class="comment">//true</span></span><br><span class="line"><span class="title class_">NaN</span> === <span class="title class_">NaN</span> <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">is</span>(+<span class="number">0</span>, -<span class="number">0</span>) <span class="comment">// false</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">is</span>(<span class="title class_">NaN</span>, <span class="title class_">NaN</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object.assign()`方法用于对象的合并，将源对象`source`的所有可枚举属性，复制到目标对象`target</span><br></pre></td></tr></table></figure>

<p><code>Object.assign()</code>方法的第一个参数是目标对象，后面的参数都是源对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> source1 = &#123; <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> source2 = &#123; <span class="attr">c</span>: <span class="number">3</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(target, source1, source2);</span><br><span class="line">target <span class="comment">// &#123;a:1, b:2, c:3&#125;</span></span><br></pre></td></tr></table></figure>

<p>注意：<code>Object.assign()</code>方法是浅拷贝，遇到同名属性会进行替换</p>
<h3 id="Object-getOwnPropertyDescriptors"><a href="#Object-getOwnPropertyDescriptors" class="headerlink" title="Object.getOwnPropertyDescriptors()"></a>Object.getOwnPropertyDescriptors()</h3><p>返回指定对象所有自身属性（非继承属性）的描述对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="number">123</span>,</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">bar</span>() &#123; <span class="keyword">return</span> <span class="string">&#x27;abc&#x27;</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptors</span>(obj)</span><br><span class="line"><span class="comment">// &#123; foo:</span></span><br><span class="line"><span class="comment">//    &#123; value: 123,</span></span><br><span class="line"><span class="comment">//      writable: true,</span></span><br><span class="line"><span class="comment">//      enumerable: true,</span></span><br><span class="line"><span class="comment">//      configurable: true &#125;,</span></span><br><span class="line"><span class="comment">//   bar:</span></span><br><span class="line"><span class="comment">//    &#123; get: [Function: get bar],</span></span><br><span class="line"><span class="comment">//      set: undefined,</span></span><br><span class="line"><span class="comment">//      enumerable: true,</span></span><br><span class="line"><span class="comment">//      configurable: true &#125; &#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="Object-setPrototypeOf"><a href="#Object-setPrototypeOf" class="headerlink" title="Object.setPrototypeOf()"></a>Object.setPrototypeOf()</h3><p><code>Object.setPrototypeOf</code>方法用来设置一个对象的原型对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(object, prototype)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法</span></span><br><span class="line"><span class="keyword">const</span> o = <span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(&#123;&#125;, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<h3 id="Object-getPrototypeOf"><a href="#Object-getPrototypeOf" class="headerlink" title="Object.getPrototypeOf()"></a>Object.getPrototypeOf()</h3><p>用于读取一个对象的原型对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(obj);</span><br></pre></td></tr></table></figure>

<h3 id="Object-keys"><a href="#Object-keys" class="headerlink" title="Object.keys()"></a>Object.keys()</h3><p>返回自身的（不含继承的）所有可遍历（enumerable）属性的键名的数组</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span>, <span class="attr">baz</span>: <span class="number">42</span> &#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">keys</span>(obj)</span><br><span class="line"><span class="comment">// [&quot;foo&quot;, &quot;baz&quot;]</span></span><br></pre></td></tr></table></figure>

<h3 id="Object-values"><a href="#Object-values" class="headerlink" title="Object.values()"></a>Object.values()</h3><p>返回自身的（不含继承的）所有可遍历（enumerable）属性的键对应值的数组</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span>, <span class="attr">baz</span>: <span class="number">42</span> &#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">values</span>(obj)</span><br><span class="line"><span class="comment">// [&quot;bar&quot;, 42]</span></span><br></pre></td></tr></table></figure>

<h3 id="Object-entries"><a href="#Object-entries" class="headerlink" title="Object.entries()"></a>Object.entries()</h3><p>返回一个对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对的数组</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span>, <span class="attr">baz</span>: <span class="number">42</span> &#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">entries</span>(obj)</span><br><span class="line"><span class="comment">// [ [&quot;foo&quot;, &quot;bar&quot;], [&quot;baz&quot;, 42] ]</span></span><br></pre></td></tr></table></figure>

<h3 id="Object-fromEntries"><a href="#Object-fromEntries" class="headerlink" title="Object.fromEntries()"></a>Object.fromEntries()</h3><p>用于将一个键值对数组转为对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">fromEntries</span>([</span><br><span class="line">  [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>],</span><br><span class="line">  [<span class="string">&#x27;baz&#x27;</span>, <span class="number">42</span>]</span><br><span class="line">])</span><br><span class="line"><span class="comment">// &#123; foo: &quot;bar&quot;, baz: 42 &#125;</span></span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/03/25/html+css+js+ts/4-es6-%E5%AF%B9%E8%B1%A1%E6%89%A9%E5%B1%95.md/" data-id="cl7k9sbhq00ce98u0baro7qta" data-title="es6对象扩展" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/es6/" rel="tag">es6</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-html+css+js+ts/4-es6" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/03/23/html+css+js+ts/4-es6/" class="article-date">
  <time class="dt-published" datetime="2018-03-23T07:26:54.000Z" itemprop="datePublished">2018-03-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/03/23/html+css+js+ts/4-es6/">ES 2015~2019</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><img src="https://poetries1.gitee.io/img-repo/2019/11/123.png"></p>
<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><ul>
<li><code>ES6</code>是<code>ECMA</code>为<code>JavaScript</code>制定的第6个标准版本</li>
<li>标准委员会最终决定，标准在每年6月正式发布并作为当年的正式版本，接下来的时间里就在此版本的基础上进行改动，直到下一年6月草案就自然变成新一年的版本，这样一来就无需以前的版本号，只要用年份标记即可。<code>ECMAscript 2015</code>是在2015年6月发布ES6的第一个版本。以此类推，<code>ECMAscript</code> 2016是ES6的第二个版本、 ECMAscript 2017是ES6的第三个版本。ES6既是一个历史名词也是一个泛指，含义是5.1版本以后的JavaScript下一代标准，目前涵盖了<code>ES2015</code>、<code>ES2016</code>、<code>ES2017</code>、<code>ES2018</code>、<code>ES2019</code></li>
</ul>
<blockquote>
<p>所以有些文章上提到的ES7(实质上是ES2016)、ES8(实质上是ES2017)、ES9(实质上是ES2018)、ES10(实质上是ES2019)，实质上都是一些不规范的概念。从ES1到ES6，每个标准都是花了好几年甚至十多年才制定下来，你一个ES6到ES7，ES7到ES8，才用了一年，按照这样的定义下去，那不是很快就ES20了。用正确的概念来说ES6目前涵盖了ES2015、ES2016、ES2017、ES2018、ES2019</p>
</blockquote>
<p><img src="https://poetries1.gitee.io/img-repo/2019/11/124.png" alt="img"></p>
<h2 id="二、ES2015"><a href="#二、ES2015" class="headerlink" title="二、ES2015"></a>二、ES2015</h2><p><img src="https://poetries1.gitee.io/img-repo/2019/11/125.png" alt="img"></p>
<h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><ul>
<li><code>const</code>命令：声明常量</li>
<li><code>let</code>命令：声明变量</li>
</ul>
<blockquote>
<p>作用</p>
</blockquote>
<p><strong>作用域</strong></p>
<ul>
<li>全局作用域</li>
<li>函数作用域：<code>function() &#123;&#125;</code></li>
<li>块级作用域：<code>&#123;&#125;</code></li>
</ul>
<p><strong>作用范围</strong></p>
<ul>
<li><code>var</code>命令在全局代码中执行</li>
<li><code>const</code>命令和<code>let</code>命令只能在代码块中执行</li>
</ul>
<p><strong>赋值使用</strong></p>
<ul>
<li><code>const</code>命令声明常量后必须立马赋值</li>
<li><code>let</code>命令声明变量后可立马赋值或使用时赋值</li>
</ul>
<blockquote>
<p>声明方法：<code>var</code>、<code>const</code>、<code>let</code>、<code>function</code>、<code>class</code>、<code>import</code></p>
</blockquote>
<p><strong>重点难点</strong></p>
<ul>
<li>不允许重复声明</li>
<li>未定义就使用会报错：<code>const</code>命令和<code>let</code>命令不存在变量提升</li>
<li>暂时性死区：在代码块内使用let命令声明变量之前，该变量都不可用</li>
</ul>
<h3 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h3><ul>
<li>字符串解构：<code>const [a, b, c, d, e] = &quot;hello&quot;</code></li>
<li>数值解构：<code>const &#123; toString: s &#125; = 123</code></li>
<li>布尔值解构：<code>const &#123; toString: b &#125; = true</code></li>
</ul>
<p><strong>对象解构</strong></p>
<ul>
<li>形式：<code>const &#123; x, y &#125; = &#123; x: 1, y: 2 &#125;</code></li>
<li>默认：<code>const &#123; x, y = 2 &#125; = &#123; x: 1 &#125;</code></li>
<li>改名：<code>const &#123; x, y: z &#125; = &#123; x: 1, y: 2 &#125;</code></li>
</ul>
<p><strong>数组解构</strong></p>
<ul>
<li>规则：数据结构具有<code>Iterator</code>接口可采用数组形式的解构赋值</li>
<li>形式：<code>const [x, y] = [1, 2]</code></li>
<li>默认：<code>const [x, y = 2] = [1]</code></li>
</ul>
<p><strong>函数参数解构</strong></p>
<ul>
<li>数组解构：<code>function Func([x = 0, y = 1]) &#123;&#125;</code></li>
<li>对象解构：<code>function Func(&#123; x = 0, y = 1 &#125; = &#123;&#125;) &#123;&#125;</code></li>
</ul>
<p><strong>应用场景</strong></p>
<ul>
<li>交换变量值：<code>[x, y] = [y, x]</code></li>
<li>返回函数多个值：<code>const [x, y, z] = Func()</code></li>
<li>定义函数参数：<code>Func([1, 2])</code></li>
<li>提取JSON数据：<code>const &#123; name, version &#125; = packageJson</code></li>
<li>定义函数参数默认值：<code>function Func(&#123; x = 1, y = 2 &#125; = &#123;&#125;) &#123;&#125;</code></li>
<li>遍历Map结构：<code>for (let [k, v] of Map) &#123;&#125;</code></li>
<li>输入模块指定属性和方法：<code>const &#123; readFile, writeFile &#125; = require(&quot;fs&quot;)</code></li>
</ul>
<p><strong>重点难点</strong></p>
<ul>
<li>匹配模式：只要等号两边的模式相同，左边的变量就会被赋予对应的值</li>
<li>解构赋值规则：只要等号右边的值不是对象或数组，就先将其转为对象</li>
<li>解构默认值生效条件：属性值严格等于undefined</li>
<li>解构遵循匹配模式</li>
<li>解构不成功时变量的值等于<code>undefined</code></li>
<li><code>undefined</code>和<code>null</code>无法转为对象，因此无法进行解构</li>
</ul>
<h3 id="字符串扩展"><a href="#字符串扩展" class="headerlink" title="字符串扩展"></a>字符串扩展</h3><ul>
<li><code>Unicode</code>表示法：大括号包含表示<code>Unicode</code>字符(<code>\u&#123;0xXX&#125;</code>或<code>\u&#123;0XXX&#125;</code>)</li>
<li>字符串遍历：可通过for-of遍历字符串</li>
<li>字符串模板：可单行可多行可插入变量的增强版字符串</li>
<li>标签模板：函数参数的特殊调用</li>
<li><code>String.raw()</code>：返回把字符串所有变量替换且对斜杠进行转义的结果</li>
<li><code>String.fromCodePoint()</code>：返回码点对应字符</li>
<li><code>codePointAt()</code>：返回字符对应码点(<code>String.fromCodePoint()</code>的逆操作)</li>
<li><code>normalize()</code>：把字符的不同表示方法统一为同样形式，返回新字符串(Unicode正规化)</li>
<li><code>repeat()</code>：把字符串重复n次，返回新字符串</li>
<li><code>matchAll()</code>：返回正则表达式在字符串的所有匹配</li>
<li><code>includes()</code>：是否存在指定字符串</li>
<li><code>startsWith()</code>：是否存在字符串头部指定字符串</li>
<li><code>endsWith()</code>：是否存在字符串尾部指定字符串</li>
</ul>
<p><strong>重点难点</strong></p>
<blockquote>
<p>以上扩展方法均可作用于由4个字节储存的<code>Unicode</code>字符上</p>
</blockquote>
<h3 id="数值扩展"><a href="#数值扩展" class="headerlink" title="数值扩展"></a>数值扩展</h3><ul>
<li>二进制表示法：0b或0B开头表示二进制(<code>0bXX</code>或<code>0BXX</code>)</li>
<li>八进制表示法：0o或0O开头表示二进制(<code>0oXX</code>或<code>0OXX</code>)</li>
<li><code>Number.EPSILON</code>：数值最小精度</li>
<li><code>Number.MIN_SAFE_INTEGER</code>：最小安全数值(<code>-2^53</code>)</li>
<li><code>Number.MAX_SAFE_INTEGER</code>：最大安全数值(<code>2^53</code>)</li>
<li><code>Number.parseInt()</code>：返回转换值的整数部分</li>
<li><code>Number.parseFloat()</code>：返回转换值的浮点数部分</li>
<li><code>Number.isFinite()</code>：是否为有限数值</li>
<li><code>Number.isNaN()</code>：是否为<code>NaN</code></li>
<li><code>Number.isInteger()</code>：是否为整数</li>
<li><code>Number.isSafeInteger()</code>：是否在数值安全范围内</li>
<li><code>Math.trunc()</code>：返回数值整数部分</li>
<li><code>Math.sign()</code>：返回数值类型(正数1、负数-1、零0)</li>
<li><code>Math.cbrt()</code>：返回数值立方根</li>
<li><code>Math.clz32()</code>：返回数值的32位无符号整数形式</li>
<li><code>Math.imul()</code>：返回两个数值相乘</li>
<li><code>Math.fround()</code>：返回数值的32位单精度浮点数形式</li>
<li><code>Math.hypot()</code>：返回所有数值平方和的平方根</li>
<li><code>Math.expm1()</code>：返回<code>e^n - 1</code></li>
<li><code>Math.log1p()</code>：返回<code>1 + n</code>的自然对数(<code>Math.log(1 + n)</code>)</li>
<li><code>Math.log10()</code>：返回以10为底的n的对数</li>
<li><code>Math.log2()</code>：返回以2为底的n的对数</li>
<li><code>Math.sinh()</code>：返回n的双曲正弦</li>
<li><code>Math.cosh()</code>：返回n的双曲余弦</li>
<li><code>Math.tanh()</code>：返回n的双曲正切</li>
<li><code>Math.asinh()</code>：返回n的反双曲正弦</li>
<li><code>Math.acosh()</code>：返回n的反双曲余弦</li>
<li><code>Math.atanh()</code>：返回n的反双曲正切</li>
</ul>
<h3 id="对象扩展"><a href="#对象扩展" class="headerlink" title="对象扩展"></a>对象扩展</h3><ul>
<li>简洁表示法：直接写入变量和函数作为对象的属性和方法<code>(&#123; prop, method() &#123;&#125; &#125;)</code></li>
<li>属性名表达式：字面量定义对象时使用[]定义键(<code>[prop]</code>，不能与上同时使用)</li>
<li>方法的name属性：返回方法函数名<ul>
<li>取值函数(<code>getter</code>)和存值函数(<code>setter</code>)：<code>get/set</code>函数名(属性的描述对象在get和set上)</li>
<li><code>bind</code>返回的函数：<code>bound</code> 函数名</li>
<li><code>Function</code>构造函数返回的函数实例：<code>anonymous</code></li>
</ul>
</li>
<li>属性的可枚举性和遍历：描述对象的<code>enumerable</code></li>
<li><code>super</code>关键字：指向当前对象的原型对象(只能用在对象的简写方法中<code>method() &#123;&#125;</code>)</li>
<li><code>Object.is()</code>：对比两值是否相等</li>
<li><code>Object.assign()</code>：合并对象(浅拷贝)，返回原对象</li>
<li><code>Object.getPrototypeOf()</code>：返回对象的原型对象</li>
<li><code>Object.setPrototypeOf()</code>：设置对象的原型对象</li>
<li><code>__proto__</code>：返回或设置对象的原型对象</li>
</ul>
<p><strong>属性遍历</strong></p>
<ul>
<li>描述：自身、可继承、可枚举、非枚举、<code>Symbol</code></li>
<li>遍历<ul>
<li><code>for-in</code>：遍历对象自身可继承可枚举属性</li>
<li><code>Object.keys()</code>：返回对象自身可枚举属性的键组成的数组</li>
<li><code>Object.getOwnPropertyNames()</code>：返回对象自身可继承可枚举非枚举属性的键组成的数组</li>
<li><code>Object.getOwnPropertySymbols()</code>：返回对象<code>Symbol</code>属性的键组成的数组</li>
<li><code>Reflect.ownKeys()</code>：返回对象自身可继承可枚举非枚举Symbol属性的键组成的数组</li>
</ul>
</li>
<li>规则<ul>
<li>首先遍历所有数值键，按照数值升序排列</li>
<li>其次遍历所有字符串键，按照加入时间升序排列</li>
<li>最后遍历所有<code>Symbol</code>键，按照加入时间升序排列</li>
</ul>
</li>
</ul>
<h3 id="数组扩展"><a href="#数组扩展" class="headerlink" title="数组扩展"></a>数组扩展</h3><ul>
<li><p>扩展运算符(<code>...</code>)：转换数组为用逗号分隔的参数序列(<code>[...arr]</code>，相当于<code>rest/spread</code>参数的逆运算)</p>
</li>
<li><pre><code>Array.from()
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">：转换具有</span><br><span class="line"></span><br></pre></td></tr></table></figure>
Iterator
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  接口的数据结构为真正数组，返回新数组</span><br><span class="line"></span><br><span class="line">  - 类数组对象：包含`length`的对象、`Arguments`对象、`NodeList`对象</span><br><span class="line">  - 可遍历对象：`String`、`Set`结构、`Map`结构、`Generator`函数</span><br><span class="line"></span><br><span class="line">- `Array.of()`：转换一组值为真正数组，返回新数组</span><br><span class="line"></span><br><span class="line">- `copyWithin()`：把指定位置的成员复制到其他位置，返回原数组</span><br><span class="line"></span><br><span class="line">- `find()`：返回第一个符合条件的成员</span><br><span class="line"></span><br><span class="line">- `findIndex()`：返回第一个符合条件的成员索引值</span><br><span class="line"></span><br><span class="line">- `fill()`：根据指定值填充整个数组，返回原数组</span><br><span class="line"></span><br><span class="line">- `keys()`：返回以索引值为遍历器的对象</span><br><span class="line"></span><br><span class="line">- `values()`：返回以属性值为遍历器的对象</span><br><span class="line"></span><br><span class="line">- `entries()`：返回以索引值和属性值为遍历器的对象</span><br><span class="line"></span><br><span class="line">- 数组空位：ES6明确将数组空位转为`undefined`(空位处理规不一，建议避免出现)</span><br><span class="line"></span><br><span class="line">**扩展应用**</span><br><span class="line"></span><br><span class="line">- 克隆数组：`const arr = [...arr1]`</span><br><span class="line">- 合并数组：`const arr = [...arr1, ...arr2]`</span><br><span class="line">- 拼接数组：`arr.push(...arr1)`</span><br><span class="line">- 代替`apply`：`Math.max.apply(null, [x, y]) =&gt; Math.max(...[x, y])`</span><br><span class="line">- 转换字符串为数组：`[...&quot;hello&quot;]`</span><br><span class="line">- 转换类数组对象为数组：`[...Arguments, ...NodeList]`</span><br><span class="line">- 转换可遍历对象为数组：`[...String, ...Set, ...Map, ...Generator]`</span><br><span class="line">- 与数组解构赋值结合：`const [x, ...rest/spread] = [1, 2, 3]`</span><br><span class="line">- 计算`Unicode`字符长度：`Array.from(&quot;hello&quot;).length =&gt; [...&quot;hello&quot;].length`</span><br><span class="line"></span><br><span class="line">**重点难点**</span><br><span class="line"></span><br><span class="line">- 使用`keys()`、`values()`、`entries()`返回的遍历器对象，可用`for-of`自动遍历或`next()`手动遍历</span><br><span class="line"></span><br><span class="line">### 函数扩展</span><br><span class="line"></span><br><span class="line">- 参数默认值：为函数参数指定默认值</span><br><span class="line"></span><br><span class="line">  - 形式：`function Func(x = 1, y = 2) &#123;&#125;`</span><br><span class="line">  - 参数赋值：惰性求值(函数调用后才求值)</span><br><span class="line">  - 参数位置：尾参数</span><br><span class="line">  - 参数作用域：函数作用域</span><br><span class="line">  - 声明方式：默认声明，不能用`const`或`let`再次声明</span><br><span class="line">  - `length`：返回没有指定默认值的参数个数</span><br><span class="line">  - 与解构赋值默认值结合：`function Func(&#123; x = 1, y = 2 &#125; = &#123;&#125;) &#123;&#125;`</span><br><span class="line">  - 应用</span><br><span class="line">    - 指定某个参数不得省略，省略即抛出错误：`function Func(x = throwMissing()) &#123;&#125;`</span><br><span class="line">    - 将参数默认值设为`undefined`，表明此参数可省略：`Func(undefined, 1)`</span><br><span class="line"></span><br><span class="line">- rest/spread参数(…)：返回函数多余参数</span><br><span class="line"></span><br><span class="line">  - 形式：以数组的形式存在，之后不能再有其他参数</span><br><span class="line">  - 作用：代替`Arguments`对象</span><br><span class="line">  - `length`：返回没有指定默认值的参数个数但不包括`rest/spread`参数</span><br><span class="line"></span><br><span class="line">- 严格模式：在严格条件下运行JS</span><br><span class="line"></span><br><span class="line">  - 应用：只要函数参数使用默认值、解构赋值、扩展运算符，那么函数内部就不能显式设定为严格模式</span><br><span class="line"></span><br><span class="line">- name属性</span><br><span class="line"></span><br><span class="line">  ：返回函数的函数名</span><br><span class="line"></span><br><span class="line">  - 将匿名函数赋值给变量：空字符串(ES5)、变量名(ES6)</span><br><span class="line">  - 将具名函数赋值给变量：函数名(ES5和ES6)</span><br><span class="line">  - `bind`返回的函数：`bound` 函数名(ES5和ES6)</span><br><span class="line">  - `Function`构造函数返回的函数实例：`anonymous`(ES5和ES6)</span><br><span class="line"></span><br><span class="line">- 箭头函数(=&gt;)：函数简写</span><br><span class="line"></span><br><span class="line">  - 无参数：`() =&gt; &#123;&#125;`</span><br><span class="line"></span><br><span class="line">  - 单个参数：`x =&gt; &#123;&#125;`</span><br><span class="line"></span><br><span class="line">  - 多个参数：`(x, y) =&gt; &#123;&#125;`</span><br><span class="line"></span><br><span class="line">  - 解构参数：`(&#123;x, y&#125;) =&gt; &#123;&#125;`</span><br><span class="line"></span><br><span class="line">  - 嵌套使用：部署管道机制</span><br><span class="line"></span><br><span class="line">  - ```</span><br><span class="line">    this</span><br></pre></td></tr></table></figure>

  指向固定化

  - 并非因为内部有绑定`this`的机制，而是根本没有自己的`this`，导致内部的`this`就是外层代码块的`this`
  - 因为没有`this`，因此不能用作构造函数
</code></pre>
</li>
<li><p>尾调用优化：只保留内层函数的调用帧</p>
<ul>
<li>尾调用<ul>
<li>定义：某个函数的最后一步是调用另一个函数</li>
<li>形式：<code>function f(x) &#123; return g(x); &#125;</code></li>
</ul>
</li>
<li>尾递归<ul>
<li>定义：函数尾调用自身</li>
<li>作用：只要使用尾递归就不会发生栈溢出，相对节省内存</li>
<li>实现：把所有用到的内部变量改写成函数的参数并使用参数默认值</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>箭头函数误区</strong></p>
<ul>
<li>函数体内的<code>this</code>是定义时所在的对象而不是使用时所在的对象</li>
<li>可让<code>this</code>指向固定化，这种特性很有利于封装回调函数</li>
<li>不可当作构造函数，因此箭头函数不可使用<code>new</code>命令</li>
<li>不可使用<code>yield</code>命令，因此箭头函数不能用作<code>Generator</code>函数</li>
<li>不可使用<code>Arguments</code>对象，此对象在函数体内不存在(可用<code>rest/spread</code>参数代替)</li>
<li>返回对象时必须在对象外面加上括号</li>
</ul>
<h3 id="正则扩展"><a href="#正则扩展" class="headerlink" title="正则扩展"></a>正则扩展</h3><ul>
<li><p><strong>变更<code>RegExp</code>构造函数入参</strong>：允许首参数为正则对象，尾参数为正则修饰符(返回的正则表达式会忽略原正则表达式的修饰符)</p>
</li>
<li><p><strong>正则方法调用变更</strong>：字符串对象的<code>match()</code>、<code>replace()</code>、<code>search()</code>、<code>split()</code>内部调用转为调用<code>RegExp</code>实例对应的<code>RegExp.prototype[Symbol.方法]</code></p>
</li>
<li><p>u修饰符</p>
<p>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Unicode</span><br></pre></td></tr></table></figure>

<p>模式修饰符，正确处理大于</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\uFFFF</span><br></pre></td></tr></table></figure>

<p>的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Unicode</span><br></pre></td></tr></table></figure>

<p>字符</p>
<ul>
<li>点字符(<code>.</code>)</li>
<li><code>Unicode</code>表示法</li>
<li>量词</li>
<li>预定义模式</li>
<li><code>i</code>修饰符</li>
<li>转义</li>
</ul>
</li>
<li><p><strong>y修饰符</strong>：粘连修饰符，确保匹配必须从剩余的第一个位置开始全局匹配(与g修饰符作用类似)</p>
</li>
<li><p><strong>unicode</strong>：是否设置<code>u</code>修饰符</p>
</li>
<li><p><strong>sticky</strong>：是否设置<code>y</code>修饰符</p>
</li>
<li><p><strong>flags</strong>：正则表达式的修饰符</p>
</li>
</ul>
<p><strong>重点难点</strong></p>
<ul>
<li><code>y</code>修饰符隐含头部匹配标志<code>^</code></li>
<li>单单一个y修饰符对<code>match()</code>只能返回第一个匹配，必须与g修饰符联用才能返回所有匹配</li>
</ul>
<h3 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h3><ul>
<li>定义：独一无二的值</li>
<li>声明：<code>const set = Symbol(str)</code></li>
<li>入参：字符串(可选)</li>
</ul>
<p><strong>方法</strong></p>
<ul>
<li><code>Symbol()</code>：创建以参数作为描述的Symbol值(不登记在全局环境)</li>
<li><code>Symbol.for()</code>：创建以参数作为描述的Symbol值，如存在此参数则返回原有的Symbol值(先搜索后创建，登记在全局环境)</li>
<li><code>Symbol.keyFor()</code>：返回已登记的<code>Symbol</code>值的描述(只能返回<code>Symbol.for()</code>的<code>key</code>)</li>
<li><code>Object.getOwnPropertySymbols()</code>：返回对象中所有用作属性名的<code>Symbol</code>值的数组</li>
</ul>
<p><strong>内置</strong></p>
<ul>
<li><code>Symbol.hasInstance</code>：指向一个内部方法，当其他对象使用<code>instanceof</code>运算符判断是否为此对象的实例时会调用此方法</li>
<li><code>Symbol.isConcatSpreadable</code>：指向一个布尔值，定义对象用于<code>Array.prototype.concat()</code>时是否可展开</li>
<li><code>Symbol.species</code>：指向一个构造函数，当实例对象使用自身构造函数时会调用指定的构造函数</li>
<li><code>Symbol.match</code>：指向一个函数，当实例对象被<code>String.prototype.match()</code>调用时会重新定义<code>match()</code>的行为</li>
<li><code>Symbol.replace</code>：指向一个函数，当实例对象被<code>String.prototype.replace()</code>调用时会重新定义<code>replace()</code>的行为</li>
<li><code>Symbol.search</code>：指向一个函数，当实例对象被<code>String.prototype.search()</code>调用时会重新定义<code>search()</code>的行为</li>
<li><code>Symbol.split</code>：指向一个函数，当实例对象被<code>String.prototype.split()</code>调用时会重新定义<code>split()</code>的行为</li>
<li><code>Symbol.iterator</code>：指向一个默认遍历器方法，当实例对象执行<code>for-of</code>时会调用指定的默认遍历器</li>
<li><code>Symbol.toPrimitive</code>：指向一个函数，当实例对象被转为原始类型的值时会返回此对象对应的原始类型值</li>
<li><code>Symbol.toStringTag</code>：指向一个函数，当实例对象被<code>Object.prototype.toString()</code>调用时其返回值会出现在<code>toString()</code>返回的字符串之中表示对象的类型</li>
<li><code>Symbol.unscopables</code>：指向一个对象，指定使用<code>with</code>时哪些属性会被<code>with</code>环境排除</li>
</ul>
<p><strong>数据类型</strong></p>
<ul>
<li><code>Undefined</code></li>
<li><code>Null</code></li>
<li><code>String</code></li>
<li><code>Number</code></li>
<li><code>Boolean</code></li>
<li><code>Object</code>(包含<code>Array</code>、<code>Function</code>、<code>Date</code>、<code>RegExp</code>、<code>Error</code>)</li>
<li><code>Symbol</code></li>
</ul>
<p><strong>应用场景</strong></p>
<ul>
<li>唯一化对象属性名：属性名属于<code>Symbol</code>类型，就都是独一无二的，可保证不会与其他属性名产生冲突</li>
<li>消除魔术字符串：在代码中多次出现且与代码形成强耦合的某一个具体的字符串或数值</li>
<li>遍历属性名：无法通过<code>for-in</code>、<code>for-of</code>、<code>Object.keys()</code>、<code>Object.getOwnPropertyNames()</code>、<code>JSON.stringify()</code>返回，只能通过<code>Object.getOwnPropertySymbols</code>返回<br>启用模块的<code>Singleton</code>模式：调用一个类在任何时候返回同一个实例(<code>window</code>和<code>global</code>)，- 使用<code>Symbol.for()</code>来模拟全局的<code>Singleton</code>模式</li>
</ul>
<p><strong>重点难点</strong></p>
<ul>
<li><code>Symbol()</code>生成一个原始类型的值不是对象，因此<code>Symbol()</code>前不能使用<code>new</code>命令</li>
<li><code>Symbol()</code>参数表示对当前<code>Symbol</code>值的描述，相同参数的<code>Symbol()</code>返回值不相等</li>
<li><code>Symbol</code>值不能与其他类型的值进行运算</li>
<li><code>Symbol</code>值可通过<code>String()</code>或<code>toString()</code>显式转为字符串</li>
<li><code>Symbol</code>值作为对象属性名时，此属性是公开属性，但不是私有属性</li>
<li><code>Symbol</code>值作为对象属性名时，只能用方括号运算符(<code>[]</code>)读取，不能用点运算符(<code>.</code>)读取&#96;</li>
<li><code>Symbol</code>值作为对象属性名时，不会被常规方法遍历得到，可利用此特性为对象定义非私有但又只用于内部的方法</li>
</ul>
<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p><strong>Set</strong></p>
<ul>
<li>定义：类似于数组的数据结构，成员值都是唯一且没有重复的值</li>
<li>声明：<code>const set = new Set(arr)</code></li>
<li>入参：具有<code>Iterator</code>接口的数据结构</li>
<li>属性<ul>
<li><code>constructor</code>：构造函数，返回<code>Set</code></li>
<li><code>size</code>：返回实例成员总数</li>
</ul>
</li>
<li>方法<ul>
<li><code>add()</code>：添加值，返回实例</li>
<li><code>delete()</code>：删除值，返回布尔值</li>
<li><code>has()</code>：检查值，返回布尔值</li>
<li><code>clear()</code>：清除所有成员</li>
<li><code>keys()</code>：返回以属性值为遍历器的对象</li>
<li><code>values()</code>：返回以属性值为遍历器的对象</li>
<li><code>entries()</code>：返回以属性值和属性值为遍历器的对象</li>
<li><code>forEach()</code>：使用回调函数遍历每个成员</li>
</ul>
</li>
</ul>
<p><strong>应用场景</strong></p>
<ul>
<li>去重字符串：<code>[...new Set(str)].join(&quot;&quot;)</code></li>
<li>去重数组：<code>[...new Set(arr)]或Array.from(new Set(arr))</code></li>
<li>集合数组<ul>
<li>声明：<code>const a = new Set(arr1)、const b = new Set(arr2)</code></li>
<li>并集：<code>new Set([...a, ...b])</code></li>
<li>交集：<code>new Set([...a].filter(v =&gt; b.has(v)))</code></li>
<li>差集：<code>new Set([...a].filter(v =&gt; !b.has(v)))</code></li>
</ul>
</li>
<li>映射集合<ul>
<li>声明：<code>let set = new Set(arr)</code></li>
<li>映射：<code>set = new Set([...set].map(v =&gt; v * 2))</code>或<code>set = new Set(Array.from(set, v =&gt; v * 2))</code></li>
</ul>
</li>
</ul>
<p><strong>重点难点</strong></p>
<ul>
<li>遍历顺序：插入顺序</li>
<li>没有键只有值，可认为键和值两值相等</li>
<li>添加多个<code>NaN</code>时，只会存在一个<code>NaN</code></li>
<li>添加相同的对象时，会认为是不同的对象</li>
<li>添加值时不会发生类型转换<code>(5 !== &quot;5&quot;)</code></li>
<li><code>keys()</code>和<code>values()</code>的行为完全一致，<code>entries()</code>返回的遍历器同时包括键和值且两值相等</li>
</ul>
<p><strong>WeakSet</strong></p>
<ul>
<li>定义：和<code>Set</code>结构类似，成员值只能是对象</li>
<li>声明：<code>const set = new WeakSet(arr)</code></li>
<li>入参：具有&#96;Iterator接口的数据结构</li>
<li>属性<ul>
<li><code>constructor</code>：构造函数，返回<code>WeakSet</code></li>
</ul>
</li>
<li>方法<ul>
<li><code>add()</code>：添加值，返回实例</li>
<li><code>delete()</code>：删除值，返回布尔值</li>
<li><code>has()</code>：检查值，返回布尔值</li>
</ul>
</li>
</ul>
<p><strong>应用场景</strong></p>
<ul>
<li>储存<code>DOM</code>节点：<code>DOM</code>节点被移除时自动释放此成员，不用担心这些节点从文档移除时会引发内存泄漏</li>
<li>临时存放一组对象或存放跟对象绑定的信息：只要这些对象在外部消失，它在<code>WeakSe</code>t结构中的引用就会自动消</li>
</ul>
<p><strong>重点难点</strong></p>
<ul>
<li>成员都是弱引用，垃圾回收机制不考虑<code>WeakSet</code>结构对此成员的引用</li>
<li>成员不适合引用，它会随时消失，因此ES6规定<code>WeakSet</code>结构不可遍历</li>
<li>其他对象不再引用成员时，垃圾回收机制会自动回收此成员所占用的内存，不考虑此成员是否还存在于<code>WeakSet</code>结构中</li>
</ul>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p><strong>Map</strong></p>
<ul>
<li>定义：类似于对象的数据结构，成员键可以是任何类型的值</li>
<li>声明：<code>const set = new Map(arr)</code></li>
<li>入参：具有<code>Iterator</code>接口且每个成员都是一个双元素数组的数据结构</li>
<li>属性<ul>
<li><code>constructor</code>：构造函数，返回<code>Map</code></li>
<li><code>size</code>：返回实例成员总数</li>
</ul>
</li>
<li>方法<ul>
<li><code>get()</code>：返回键值对</li>
<li><code>set()</code>：添加键值对，返回实例</li>
<li><code>delete()</code>：删除键值对，返回布尔值</li>
<li><code>has()</code>：检查键值对，返回布尔值</li>
<li><code>clear()</code>：清除所有成员</li>
<li><code>keys()</code>：返回以键为遍历器的对象</li>
<li><code>values()</code>：返回以值为遍历器的对象</li>
<li><code>entries()</code>：返回以键和值为遍历器的对象</li>
<li><code>forEach()</code>：使用回调函数遍历每个成员</li>
</ul>
</li>
</ul>
<p><strong>重点难点</strong></p>
<ul>
<li>遍历顺序：插入顺序</li>
<li>对同一个键多次赋值，后面的值将覆盖前面的值</li>
<li>对同一个对象的引用，被视为一个键</li>
<li>对同样值的两个实例，被视为两个键</li>
<li>键跟内存地址绑定，只要内存地址不一样就视为两个键</li>
<li>添加多个以<code>NaN</code>作为键时，只会存在一个以<code>NaN</code>作为键的值</li>
<li><code>Object</code>结构提供字符串—值的对应，<code>Map</code>结构提供值—值的对应</li>
</ul>
<p><strong>WeakMap</strong></p>
<ul>
<li>定义：和<code>Map</code>结构类似，成员键只能是对象</li>
<li>声明：<code>const set = new WeakMap(arr)</code></li>
<li>入参：具有Iterator接口且每个成员都是一个双元素数组的数据结构</li>
<li>属性<ul>
<li><code>constructor</code>：构造函数，返回<code>WeakMap</code></li>
</ul>
</li>
<li>方法<ul>
<li><code>get()</code>：返回键值对</li>
<li><code>set()</code>：添加键值对，返回实例</li>
<li><code>delete()</code>：删除键值对，返回布尔值</li>
<li><code>has()</code>：检查键值对，返回布尔值</li>
</ul>
</li>
</ul>
<p><strong>应用场景</strong></p>
<ul>
<li>储存DOM节点：DOM节点被移除时自动释放此成员键，不用担心这些节点从文档移除时会引发内存泄漏</li>
<li>部署私有属性：内部属性是实例的弱引用，删除实例时它们也随之消失，不会造成内存泄漏</li>
</ul>
<p><strong>重点难点</strong></p>
<ul>
<li>成员键都是弱引用，垃圾回收机制不考虑<code>WeakMap</code>结构对此成员键的引用</li>
<li>成员键不适合引用，它会随时消失，因此ES6规定<code>WeakMap</code>结构不可遍历</li>
<li>其他对象不再引用成员键时，垃圾回收机制会自动回收此成员所占用的内存，不考虑此成员是否还存在于<code>WeakMap</code>结构中</li>
<li>一旦不再需要，成员会自动消失，不用手动删除引用</li>
<li>弱引用的只是键而不是值，值依然是正常引用</li>
<li>即使在外部消除了成员键的引用，内部的成员值依然存在</li>
</ul>
<h3 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h3><ul>
<li>定义：修改某些操作的默认行为</li>
<li>声明：<code>const proxy = new Proxy(target, handler)</code></li>
<li>入参<ul>
<li><code>target</code>：拦截的目标对象</li>
<li><code>handler</code>：定制拦截行为</li>
</ul>
</li>
<li>方法<ul>
<li><code>Proxy.revocable()</code>：返回可取消的<code>Proxy</code>实例(返回<code>&#123; proxy, revoke &#125;</code>，通过<code>revoke()</code>取消代理)</li>
</ul>
</li>
<li>拦截方式<ul>
<li><code>get()</code>：拦截对象属性读取</li>
<li><code>set()</code>：拦截对象属性设置，返回布尔值</li>
<li><code>has()</code>：拦截对象属性检查<code>k in obj</code>，返回布尔值</li>
<li><code>deleteProperty()</code>：拦截对象属性删除<code>delete obj[k]</code>，返回布尔值</li>
<li><code>defineProperty()</code>：拦截对象属性定义<code>Object.defineProperty()</code>、<code>Object.defineProperties()</code>，返回布尔值</li>
<li><code>ownKeys()</code>：拦截对象属性遍历<code>for-in</code>、<code>Object.keys()</code>、<code>Object.getOwnPropertyNames()、Object.getOwnPropertySymbols()</code>，返回数组</li>
<li><code>getOwnPropertyDescriptor()</code>：拦截对象属性描述读取<code>Object.getOwnPropertyDescriptor()</code>，返回对象</li>
<li><code>getPrototypeOf()</code>：拦截对象原型读取<code>instanceof</code>、<code>Object.getPrototypeOf()</code>、<code>Object.prototype.__proto__</code>、<code>Object.prototype.isPrototypeOf()</code>、<code>Reflect.getPrototypeOf()</code>，返回对象</li>
<li><code>setPrototypeOf()</code>：拦截对象原型设置<code>Object.setPrototypeOf()</code>，返回布尔值</li>
<li><code>isExtensible()</code>：拦截对象是否可扩展读取<code>Object.isExtensible()</code>，返回布尔值</li>
<li><code>preventExtensions()</code>：拦截对象不可扩展设置<code>Object.preventExtensions()</code>，返回布尔值</li>
<li><code>apply()</code>：拦截<code>Proxy</code>实例作为函数调用<code>proxy()</code>、<code>proxy.apply()</code>、<code>proxy.call()</code></li>
<li><code>construct()</code>：拦截<code>Proxy</code>实例作为构造函数调用<code>new proxy()</code></li>
</ul>
</li>
</ul>
<p><strong>应用场景</strong></p>
<ul>
<li><code>Proxy.revocable()</code>：不允许直接访问对象，必须通过代理访问，一旦访问结束就收回代理权不允许再次访问</li>
<li><code>get()</code>：读取未知属性报错、读取数组负数索引的值、封装链式操作、生成DOM嵌套节点</li>
<li><code>set()</code>：数据绑定(<code>Vue</code>数据绑定实现原理)、确保属性值设置符合要求、防止内部属性被外部读写</li>
<li><code>has()</code>：隐藏内部属性不被发现、排除不符合属性条件的对象</li>
<li><code>deleteProperty()</code>：保护内部属性不被删除</li>
<li><code>defineProperty()</code>：阻止属性被外部定义</li>
<li><code>ownKeys()</code>：保护内部属性不被遍历</li>
</ul>
<p><strong>重点难点</strong></p>
<ul>
<li>要使<code>Proxy</code>起作用，必须针对实例进行操作，而不是针对目标对象进行操作</li>
<li>没有设置任何拦截时，等同于直接通向原对象</li>
<li>属性被定义为不可读写&#x2F;扩展&#x2F;配置&#x2F;枚举时，使用拦截方法会报错</li>
<li>代理下的目标对象，内部<code>this</code>指向<code>Proxy</code>代理</li>
</ul>
<h3 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h3><ul>
<li>定义：保持<code>Object</code>方法的默认行为</li>
<li>方法<ul>
<li><code>get()</code>：返回对象属性</li>
<li><code>set()</code>：设置对象属性，返回布尔值</li>
<li><code>has()</code>：检查对象属性，返回布尔值</li>
<li><code>deleteProperty()</code>：删除对象属性，返回布尔值</li>
<li><code>defineProperty()</code>：定义对象属性，返回布尔值</li>
<li><code>ownKeys()</code>：遍历对象属性，返回数<code>组(Object.getOwnPropertyNames()+Object.getOwnPropertySymbols())</code></li>
<li><code>getOwnPropertyDescriptor()</code>：返回对象属性描述，返回对象</li>
<li><code>getPrototypeOf()</code>：返回对象原型，返回对象</li>
<li><code>setPrototypeOf()</code>：设置对象原型，返回布尔值</li>
<li><code>isExtensible()</code>：返回对象是否可扩展，返回布尔值</li>
<li><code>preventExtensions()</code>：设置对象不可扩展，返回布尔值</li>
<li><code>apply()</code>：绑定<code>this</code>后执行指定函数</li>
<li><code>construct()</code>：调用构造函数创建实例</li>
</ul>
</li>
</ul>
<p><strong>设计目的</strong></p>
<ul>
<li><code>Object</code>属于语言内部的方法放到<code>Reflect</code>上</li>
<li>将某些<code>Object</code>方法报错情况改成返回<code>false</code></li>
<li>让<code>Object</code>操作变成函数行为</li>
<li><code>Proxy</code>与<code>Reflect</code>相辅相成</li>
</ul>
<p><strong>废弃方法</strong></p>
<ul>
<li><code>Object.defineProperty()</code> &#x3D;&gt; <code>Reflect.defineProperty()</code></li>
<li><code>Object.getOwnPropertyDescriptor()</code> &#x3D;&gt; <code>Reflect.getOwnPropertyDescriptor()</code></li>
</ul>
<blockquote>
<p>数据绑定：观察者模式</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const observerQueue = new Set();</span><br><span class="line">const observe = fn =&gt; observerQueue.add(fn);</span><br><span class="line">const observable = obj =&gt; new Proxy(obj, &#123;</span><br><span class="line">    set(tgt, key, val, receiver) &#123;</span><br><span class="line">        const result = Reflect.set(tgt, key, val, receiver);</span><br><span class="line">        observerQueue.forEach(v =&gt; v());</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">const person = observable(&#123; age: 25, name: &quot;Yajun&quot; &#125;);</span><br><span class="line">const print = () =&gt; console.log(`$&#123;person.name&#125; is $&#123;person.age&#125; years old`);</span><br><span class="line">observe(print);</span><br><span class="line">person.name = &quot;Joway&quot;;</span><br></pre></td></tr></table></figure>

<h3 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h3><ul>
<li><p>定义：对一类具有共同特征的事物的抽象(构造函数语法糖)</p>
</li>
<li><p>原理：类本身指向构造函数，所有方法定义在<code>prototype</code>上，可看作构造函数的另一种写法(<code>Class === Class.prototype.constructor</code>)</p>
</li>
<li><p>方法和关键字</p>
<ul>
<li><code>constructor()</code>：构造函数，<code>new</code>命令生成实例时自动调用</li>
<li><code>extends</code>：继承父类</li>
<li><code>super</code>：新建父类的this</li>
<li><code>static</code>：定义静态属性方法</li>
<li><code>get</code>：取值函数，拦截属性的取值行为</li>
<li><code>set</code>：存值函数，拦截属性的存值行为</li>
</ul>
</li>
<li><p>属性</p>
<ul>
<li><code>__proto__</code>：构造函数的继承(总是指向父类)</li>
<li><code>__proto__.__proto__</code>：子类的原型的原型，即父类的原型(总是指向父类的<code>__proto__</code>)</li>
<li><code>prototype.__proto__</code>：属性方法的继承(总是指向父类的<code>prototype</code>)</li>
</ul>
</li>
<li><p><strong>静态属性</strong>：定义类完成后赋值属性，该属性不会被实例继承，只能通过类来调用</p>
</li>
<li><p><strong>静态方法</strong>：使用static定义方法，该方法不会被实例继承，只能通过类来调用(方法中的this指向类，而不是实例)</p>
</li>
<li><p>继承</p>
<ul>
<li><p>实质</p>
<ul>
<li><p>ES5实质：先创造子类实例的<code>this</code>，再将父类的属性方法添加到<code>this</code>上(<code>Parent.apply(this)</code>)</p>
</li>
<li><p><code>ES6</code>实质：先将父类实例的属性方法加到<code>this</code>上(调用<code>super()</code>)，再用子类构造函数修改<code>this</code></p>
</li>
<li><p>&#96;&#96;&#96;<br>super</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 作为函数调用：只能在构造函数中调用`super()`，内部`this`指向继承的当前子类(`super()`调用后才可在构造函数中使用`this`)</span><br><span class="line">  - 作为对象调用：在普通方法中指向父类的原型对象，在静态方法中指向父类</span><br><span class="line"></span><br><span class="line">- 显示定义：使用`constructor() &#123; super(); &#125;`定义继承父类，没有书写则显示定义</span><br><span class="line"></span><br><span class="line">- 子类继承父类：子类使用父类的属性方法时，必须在构造函数中调用</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>super()</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">，否则得不到父类的</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>this</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">      - 父类静态属性方法可被子类继承</span><br><span class="line">      - 类继承父类后，可从`super`上调用父类静态属性方法</span><br><span class="line"></span><br><span class="line">- 实例</span><br><span class="line"></span><br><span class="line">  ：类相当于实例的原型，所有在类中定义的属性方法都会被实例继承</span><br><span class="line"></span><br><span class="line">  - 显式指定属性方法：使用`this`指定到自身上(使用`Class.hasOwnProperty()`可检测到)</span><br><span class="line">  - 隐式指定属性方法：直接声明定义在对象原型上(使用`Class.__proto__.hasOwnProperty()`可检测到)</span><br><span class="line"></span><br><span class="line">- 表达式</span><br><span class="line"></span><br><span class="line">  - 类表达式：`const Class = class &#123;&#125;`</span><br><span class="line">  - `name`属性：返回紧跟`class`后的类名</span><br><span class="line">  - 属性表达式：`[prop]`</span><br><span class="line">  - `Generator`方法：`* mothod() &#123;&#125;`</span><br><span class="line">  - `Async`方法：`async mothod() &#123;&#125;`</span><br><span class="line"></span><br><span class="line">- this指向</span><br><span class="line"></span><br><span class="line">  ：解构实例属性或方法时会报错</span><br><span class="line"></span><br><span class="line">  - 绑定`this`：`this.mothod = this.mothod.bind(this)`</span><br><span class="line">  - 箭头函数：`this.mothod = () =&gt; this.mothod()`</span><br><span class="line"></span><br><span class="line">- 属性定义位置</span><br><span class="line"></span><br><span class="line">  - 定义在构造函数中并使用`this`指向</span><br><span class="line">  - 定义在类最顶层</span><br><span class="line"></span><br><span class="line">- **`new.target`：确定构造函数是如何调用**</span><br><span class="line"></span><br><span class="line">**原生构造函数**</span><br><span class="line"></span><br><span class="line">- `String()`</span><br><span class="line">- `Number()`</span><br><span class="line">- `Boolean()`</span><br><span class="line">- `Array()`</span><br><span class="line">- `Object()`</span><br><span class="line">- `Function()`</span><br><span class="line">- `Date()`</span><br><span class="line">- `RegExp()`</span><br><span class="line">- `Error()`</span><br><span class="line"></span><br><span class="line">**重点难点**</span><br><span class="line"></span><br><span class="line">- 在实例上调用方法，实质是调用原型上的方法</span><br><span class="line">- `Object.assign()`可方便地一次向类添加多个方法`(Object.assign(Class.prototype, &#123; ... &#125;))`</span><br><span class="line">- 类内部所有定义的方法是不可枚举的(`non-enumerable`)</span><br><span class="line">- 构造函数默认返回实例对象(`this`)，可指定返回另一个对象</span><br><span class="line">- 取值函数和存值函数设置在属性的`Descriptor`对象上</span><br><span class="line">- 类不存在变量提升</span><br><span class="line">- 利用`new.target === Class`写出不能独立使用必须继承后才能使用的类</span><br><span class="line">- 子类继承父类后，`this`指向子类实例，通过`super`对某个属性赋值，赋值的属性会变成子类实例的属性</span><br><span class="line">- 使用`super`时，必须显式指定是作为函数还是作为对象使用</span><br><span class="line">- `extends`不仅可继承类还可继承原生的构造函数</span><br><span class="line"></span><br><span class="line">**私有属性方法**</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>const name &#x3D; Symbol(“name”);<br>const print &#x3D; Symbol(“print”);<br>class Person {<br>    constructor(age) {<br>        this[name] &#x3D; “Bruce”;<br>        this.age &#x3D; age;<br>    }<br>    <a href="">print</a> {<br>        console.log(<code>$&#123;this[name]&#125; is $&#123;this.age&#125; years old</code>);<br>    }<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**继承混合类**</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>function CopyProperties(target, source) {<br>    for (const key of Reflect.ownKeys(source)) {<br>        if (key !&#x3D;&#x3D; “constructor” &amp;&amp; key !&#x3D;&#x3D; “prototype” &amp;&amp; key !&#x3D;&#x3D; “name”) {<br>            const desc &#x3D; Object.getOwnPropertyDescriptor(source, key);<br>            Object.defineProperty(target, key, desc);<br>        }<br>    }<br>}<br>function MixClass(…mixins) {<br>    class Mix {<br>        constructor() {<br>            for (const mixin of mixins) {<br>                CopyProperties(this, new mixin());<br>            }<br>        }<br>    }<br>    for (const mixin of mixins) {<br>        CopyProperties(Mix, mixin);<br>        CopyProperties(Mix.prototype, mixin.prototype);<br>    }<br>    return Mix;<br>}<br>class Student extends MixClass(Person, Kid) {}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### Module</span><br><span class="line"></span><br><span class="line">**命令**</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  export</span><br></pre></td></tr></table></figure>

<p>  ：规定模块对外接口</p>
<ul>
<li><p>默认导出：<code>export default Person</code>(导入时可指定模块任意名称，无需知晓内部真实名称)</p>
</li>
<li><p>单独导出：<code>export const name = &quot;Bruce&quot;</code></p>
</li>
<li><p>按需导出：<code>export &#123; age, name, sex &#125;(推荐)</code></p>
</li>
<li><p>改名导出：<code>export &#123; name as newName &#125;</code></p>
</li>
<li><pre><code>import
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  ：导入模块内部功能</span><br><span class="line"></span><br><span class="line">  - 默认导入：`import Person from &quot;person&quot;`</span><br><span class="line">  - 整体导入：`import * as Person from &quot;person&quot;`</span><br><span class="line">  - 按需导入：`import &#123; age, name, sex &#125; from &quot;person&quot;`</span><br><span class="line">  - 改名导入：`import &#123; name as newName &#125; from &quot;person&quot;`</span><br><span class="line">  - 自执导入：`import &quot;person&quot;`</span><br><span class="line">  - 复合导入：`import Person, &#123; name &#125; from &quot;person&quot;`</span><br><span class="line"></span><br><span class="line">- 复合模式：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
export
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">命令和</span><br><span class="line"></span><br></pre></td></tr></table></figure>
import
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  命令结合在一起写成一行，变量实质没有被导入 当前模块，相当于对外转发接口，导致当前模块无法直接使用其导入变量</span><br><span class="line"></span><br><span class="line">  - 默认导入导出：`export &#123; default &#125; from &quot;person&quot;`</span><br><span class="line">  - 整体导入导出：`export * from &quot;person&quot;`</span><br><span class="line">  - 按需导入导出：`export &#123; age, name, sex &#125; from &quot;person&quot;`</span><br><span class="line">  - 改名导入导出：`export &#123; name as newName &#125; from &quot;person&quot;`</span><br><span class="line">  - 具名改默认导入导出：`export &#123; name as default &#125; from &quot;person&quot;`</span><br><span class="line">  - 默认改具名导入导出：`export &#123; default as name &#125; from &quot;person&quot;`</span><br><span class="line"></span><br><span class="line">- 继承：默认导出和改名导出结合使用可使模块具备继承性</span><br><span class="line"></span><br><span class="line">- 设计思想：尽量地静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量</span><br><span class="line"></span><br><span class="line">- 严格模式：ES6模块自动采用严格模式(不管模块头部是否添加`use strict`)</span><br><span class="line"></span><br><span class="line">**模块方案**</span><br><span class="line"></span><br><span class="line">- **CommonJS**：用于服务器(动态化依赖)</span><br><span class="line">- **AMD**：用于浏览器(动态化依赖)</span><br><span class="line">- **CMD**：用于浏览器(动态化依赖)</span><br><span class="line">- **UMD**：用于浏览器和服务器(动态化依赖)</span><br><span class="line">- **ESM**：用于浏览器和服务器(静态化依赖)</span><br><span class="line"></span><br><span class="line">**加载方式**</span><br><span class="line"></span><br><span class="line">- 运行时加载</span><br><span class="line">  - 定义：整体加载模块生成一个对象，再从对象上获取需要的属性和方法进行加载(全部加载)</span><br><span class="line">  - 影响：只有运行时才能得到这个对象，导致无法在编译时做静态优化</span><br><span class="line">- **编译时加载**</span><br><span class="line">- 定义：直接从模块中获取需要的属性和方法进行加载(按需加载)</span><br><span class="line">- 影响：在编译时就完成模块加载，效率比其他方案高，但无法引用模块本身(本身不是对象)，可拓展JS高级语法(宏和类型校验)</span><br><span class="line"></span><br><span class="line">**加载实现**</span><br><span class="line"></span><br><span class="line">- 传统加载</span><br><span class="line"></span><br><span class="line">  ：通过</span><br><span class="line"></span><br></pre></td></tr></table></figure>
&lt;script&gt;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  进行同步或异步加载脚本</span><br><span class="line"></span><br><span class="line">  - 同步加载：``</span><br><span class="line">  - `Defer`异步加载：``(顺序加载，渲染完再执行)</span><br><span class="line">  - `Async`异步加载：``(乱序加载，下载完就执行)</span><br><span class="line"></span><br><span class="line">- **模块加载**：``(默认是`Defer`异步加载)</span><br><span class="line"></span><br><span class="line">**CommonJS和ESM的区别**</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  CommonJS</span><br></pre></td></tr></table></figure>

输出值的拷贝，

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ESM</span><br></pre></td></tr></table></figure>

输出值的引用

- `CommonJS`一旦输出一个值，模块内部的变化就影响不到这个值
- `ESM`是动态引用且不会缓存值，模块里的变量绑定其所在的模块，等到脚本真正执行时，再根据这个只读引用到被加载的那个模块里去取值
</code></pre>
</li>
<li><pre><code>CommonJS
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">是运行时加载，</span><br><span class="line"></span><br></pre></td></tr></table></figure>
ESM
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  是编译时加载</span><br><span class="line"></span><br><span class="line">  - `CommonJS`加载模块是对象(即`module.exports`)，该对象只有在脚本运行完才会生成</span><br><span class="line">  - `ESM`加载模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成</span><br><span class="line"></span><br><span class="line">**Node加载**</span><br><span class="line"></span><br><span class="line">- 背景：`CommonJS`和`ESM`互不兼容，目前解决方案是将两者分开，采用各自的加载方案</span><br><span class="line"></span><br><span class="line">- 区分：要求</span><br><span class="line"></span><br></pre></td></tr></table></figure>
ESM
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">采用</span><br><span class="line"></span><br></pre></td></tr></table></figure>
.mjs
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  后缀文件名</span><br><span class="line"></span><br><span class="line">  - `require()`不能加载`.mjs`文件，只有`import`命令才可加载`.mjs`文件</span><br><span class="line">  - `.mjs`文件里不能使用`require()`，必须使用`import`命令加载文件</span><br><span class="line"></span><br><span class="line">- 驱动：`node --experimental-modules file.mjs`</span><br><span class="line"></span><br><span class="line">- 限制：`Node`的`import`命令目前只支持加载本地模块(`file:协`议)，不支持加载远程模块</span><br><span class="line"></span><br><span class="line">- 加载优先级</span><br><span class="line"></span><br><span class="line">  - 脚本文件省略后缀名：依次尝试加载四个后缀名文件(`.mjs`、`.js`、`.json`、`node`)</span><br><span class="line">  - 以上不存在：尝试加载`package.json`的`main`字段指定的脚本</span><br><span class="line">  - 以上不存在：依次尝试加载名称为`index`四个后缀名文件(`.mjs`、`.js`、`.json`、`node`)</span><br><span class="line">  - 以上不存在：报错</span><br><span class="line"></span><br><span class="line">- 不存在的内部变量：`arguments`、`exports`、`module`、`require`、`this`、`__dirname`、`__filename`</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  CommonJS</span><br></pre></td></tr></table></figure>

加载

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ESM</span><br></pre></td></tr></table></figure>

- 不能使用`require()`，只能使用`import()`
</code></pre>
</li>
<li><p>&#96;&#96;&#96;<br>ESM</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">加载</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>CommonJS</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 自动将`module.exports`转化成`export default`</span><br><span class="line">  - `CommonJS`输出缓存机制在ESM加载方式下依然有效</span><br><span class="line">  - 采用`import`命令加载`CommonJS`模块时，不允许采用按需导入，应使用默认导入或整体导入</span><br><span class="line"></span><br><span class="line">**循环加载**</span><br><span class="line"></span><br><span class="line">- 定义：脚本`A`的执行依赖脚本`B`，而脚本`A`的执行又依赖脚本B</span><br><span class="line">- 加载原理</span><br><span class="line">  - `CommonJS`：`require()`首次加载脚本就会执行整个脚本，在内存里生成一个对象缓存下来，二次加载脚本时直接从缓存中获取</span><br><span class="line">  - `ESM`：`import`命令加载变量不会被缓存，而是成为一个指向被加载模块的引用</span><br><span class="line">- 循环加载</span><br><span class="line">  - `CommonJS`：只输出已经执行的部分，还未执行的部分不会输出</span><br><span class="line">  - `ESM`：需开发者自己保证真正取值时能够取到值(可把变量写成函数形式，函数具有提升作用)</span><br><span class="line"></span><br><span class="line">**重点难点**</span><br><span class="line"></span><br><span class="line">- `ES6`模块中，顶层`this`指向`undefined`，不应该在顶层代码使用`this`</span><br><span class="line">- `一个模块就是一个独立的文件，该文件内部的所有变量，外部无法获取</span><br><span class="line">- `export`命令输出的接口与其对应的值是动态绑定关系，即通过该接口可获取模块内部实时的值</span><br><span class="line">- `import`命令大括号里的变量名必须与被导入模块对外接口的名称相同</span><br><span class="line">- `import`命令输入的变量只读(本质是输入接口)，不允许在加载模块的脚本里改写接口</span><br><span class="line">- `import`命令命令具有提升效果，会提升到整个模块的头部，首先执行</span><br><span class="line">  重复执行同一句import语句，只会执行一次</span><br><span class="line">- `export default`命令只能使用一次</span><br><span class="line">- `export default`命令导出的整体模块，在执行`import`命令时其后不能跟大括号</span><br><span class="line">- `export default`命令本质是输出一个名为`default`的变量，后面不能跟变量声明语句</span><br><span class="line">- `export default`命令本质是将后面的值赋给名为`default`的变量，可直接将值写在其后</span><br><span class="line">- `export default`命令和`export &#123;&#125;`命令可同时存在，对应复合导入</span><br><span class="line">- `export`命令和`import`命令可出现在模块任何位置，只要处于模块顶层即可，不能处于块级作用域</span><br><span class="line">- `import()`加载模块成功后，此模块会作为一个对象，当作`then()`的参数，可使用对象解构赋值来获取输出接口</span><br><span class="line">- 同时动态加载多个模块时，可使用`Promise.all()`和`import()`相结合来实现</span><br><span class="line">- `import()`和结`合async/await`来书写同步操作的代码</span><br><span class="line"></span><br><span class="line">**单例模式：跨模块常量**</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>&#x2F;&#x2F; 常量跨文件共享<br>&#x2F;&#x2F; person.js<br>const NAME &#x3D; “Bruce”;<br>const AGE &#x3D; 25;<br>const SEX &#x3D; “male”;<br>export { AGE, NAME, SEX };<br>&#x2F;&#x2F; file1.js<br>import { AGE } from “person”;<br>console.log(AGE);<br>&#x2F;&#x2F; file2.js<br>import { AGE, NAME, SEX } from “person”;<br>console.log(AGE, NAME, SEX);</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt; 默认导入互换整体导入</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>import Person from “person”;<br>console.log(Person.AGE);<br>import * as Person from “person”;<br>console.log(Person.default.AGE);</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### Iterator</span><br><span class="line"></span><br><span class="line">- 定义：为各种不同的数据结构提供统一的访问机制</span><br><span class="line">- 原理：创建一个指针指向首个成员，按照次序使用`next()`指向下一个成员，直接到结束位置(数据结构只要部署`Iterator`接口就可完成遍历操作)</span><br><span class="line">- 作用</span><br><span class="line">  - 为各种数据结构提供一个统一的简便的访问接口</span><br><span class="line">  - 使得数据结构成员能够按某种次序排列</span><br><span class="line">  - `ES6`创造了新的遍历命令`for-of`，`Iterator`接口主要供`for-of`消费</span><br><span class="line">- 形式：`for-of`(自动去寻找`Iterator`接口)</span><br><span class="line">- 数据结构</span><br><span class="line">  - 集合：`Array`、`Object`、`Set`、`Map`</span><br><span class="line">  - 原生具备接口的数据结构：`String`、`Array`、`Set`、`Map`、`TypedArray`、`Arguments、NodeList`</span><br><span class="line">- 部署：默认部署在`Symbol.iterator`(具备此属性被认为可遍历的`iterable`)</span><br><span class="line">- 遍历器对象</span><br><span class="line">  - `next()`：下一步操作，返回`&#123; done, value &#125;`(必须部署)</span><br><span class="line">  - `return()`：`for-of`提前退出调用，返回`&#123; done: true &#125;`</span><br><span class="line">  - `throw()`：不使用，配合`Generator`函数使用</span><br><span class="line"></span><br><span class="line">**ForOf循环**</span><br><span class="line"></span><br><span class="line">- 定义：调用`Iterator`接口产生遍历器对象(`for-of`内部调用数据结构的`Symbol.iterator()`)</span><br><span class="line"></span><br><span class="line">- 遍历字符串：`for-in`获取索引，`for-of`获取值(可识别32位UTF-16字符)</span><br><span class="line"></span><br><span class="line">- 遍历数组：`for-in`获取索引，`for-of`获取值</span><br><span class="line"></span><br><span class="line">- 遍历对象：`for-in`获取键，`for-of`需自行部署</span><br><span class="line"></span><br><span class="line">- 遍历`Set`：`for-of`获取值 =&gt; `for (const v of set)`</span><br><span class="line"></span><br><span class="line">- 遍历`Map`：`for-of`获取键值对 =&gt; `for (const [k, v] of map)`</span><br><span class="line"></span><br><span class="line">- 遍历类数组：包含`length`的对象、`Arguments`对象、`NodeList`对象(无`Iterator`接口的类数组可用`Array.from()`转换)</span><br><span class="line"></span><br><span class="line">- 计算生成数据结构：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Array</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">、</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Set</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">、</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Map</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - `keys()`：返回遍历器对象，遍历所有的键</span><br><span class="line">  - `values()`：返回遍历器对象，遍历所有的值</span><br><span class="line">  - `entries()`：返回遍历器对象，遍历所有的键值对</span><br><span class="line"></span><br><span class="line">- 与for-in区别</span><br><span class="line"></span><br><span class="line">  - 有着同`for-in`一样的简洁语法，但没有`for-in`那些缺点、</span><br><span class="line">  - 不同于`forEach()`，它可与`break`、`continue`和`return`配合使用</span><br><span class="line">  - 提供遍历所有数据结构的统一操作接口</span><br><span class="line"></span><br><span class="line">**应用场景**</span><br><span class="line"></span><br><span class="line">- 改写具有`Iterator`接口的数据结构的`Symbol.iterator`</span><br><span class="line">- 解构赋值：对`Set`进行结构</span><br><span class="line">- 扩展运算符：将部署Iterator接口的数据结构转为数组</span><br><span class="line">- `yield*`：`yield*`后跟一个可遍历的数据结构，会调用其遍历器接口</span><br><span class="line">- 接受数组作为参数的函数：`for-of`、`Array.from()`、`new Set()`、`new WeakSet()`、`new Map()`、`new WeakMap()`、`Promise.all()`、`Promise.race()`</span><br><span class="line"></span><br><span class="line">### Promise</span><br><span class="line"></span><br><span class="line">- 定义：包含异步操作结果的对象</span><br><span class="line"></span><br><span class="line">- 状态</span><br><span class="line"></span><br><span class="line">  - 进行中：`pending`</span><br><span class="line">  - 已成功：`resolved`</span><br><span class="line">  - 已失败：`rejected`</span><br><span class="line"></span><br><span class="line">- 特点</span><br><span class="line"></span><br><span class="line">  - 对象的状态不受外界影响</span><br><span class="line">  - 一旦状态改变就不会再变，任何时候都可得到这个结果</span><br><span class="line"></span><br><span class="line">- 声明：`new Promise((resolve, reject) =&gt; &#123;&#125;)`</span><br><span class="line"></span><br><span class="line">- 出参</span><br><span class="line"></span><br><span class="line">  - `resolve`：将状态从未完成变为成功，在异步操作成功时调用，并将异步操作的结果作为参数传递出去</span><br><span class="line">  - `reject`：将状态从未完成变为失败，在异步操作失败时调用，并将异步操作的错误作为参数传递出去</span><br><span class="line"></span><br><span class="line">- 方法</span><br><span class="line"></span><br><span class="line">  - ```</span><br><span class="line">    then()</span><br></pre></td></tr></table></figure>

<p>  ：分别指定</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">resolved</span><br></pre></td></tr></table></figure>

<p>  状态和</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rejected</span><br></pre></td></tr></table></figure>

<p>  状态的回调函数</p>
<ul>
<li><p>第一参数：状态变为<code>resolved</code>时调用</p>
</li>
<li><p>第二参数：状态变为<code>rejected</code>时调用(可选)</p>
</li>
<li><p><code>catch()</code>：指定发生错误时的回调函数</p>
</li>
<li><pre><code>Promise.all()
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  ：将多个实例包装成一个新实例，返回全部实例状态变更后的结果数组(齐变更再返回)</span><br><span class="line"></span><br><span class="line">  - 入参：具有`Iterator`接口的数据结构</span><br><span class="line">  - 成功：只有全部实例状态变成`resolved`，最终状态才会变成`resolved`</span><br><span class="line">  - 失败：其中一个实例状态变成`rejected`，最终状态就会变成`rejected`</span><br><span class="line"></span><br><span class="line">- `Promise.race()`：将多个实例包装成一个新实例，返回全部实例状态优先变更后的结果(先变更先返回)</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  Promise.resolve()</span><br></pre></td></tr></table></figure>

：将对象转为Promise对象(等价于

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new Promise(resolve =&gt; resolve())</span><br></pre></td></tr></table></figure>

)

- `Promise`实例：原封不动地返回入参
- `Thenable`对象：将此对象转为`Promise`对象并返回(`Thenable`为包含`then()`的对象，执行`then()`相当于执行此对象的`then()`)
- 不具有`then()`的对象：将此对象转为`Promise`对象并返回，状态为`resolved`
- 不带参数：返回`Promise`对象，状态为`resolved`
</code></pre>
</li>
<li><p><code>Promise.reject()</code>：将对象转为状态为<code>rejected</code>的<code>Promise</code>对象(等价于<code>new Promise((resolve, reject) =&gt; reject())</code>)</p>
</li>
</ul>
</li>
</ul>
<p><strong>应用场景</strong></p>
<ul>
<li>加载图片</li>
<li><code>AJAX</code>转<code>Promise</code>对象</li>
</ul>
<p><strong>重点难点</strong></p>
<ul>
<li>只有异步操作的结果可决定当前状态是哪一种，其他操作都无法改变这个状态</li>
<li>状态改变只有两种可能：从<code>pending</code>变为<code>resolved</code>、从<code>pending</code>变为<code>rejected</code></li>
<li>一旦新建<code>Promise</code>对象就会立即执行，无法中途取消</li>
<li>不设置回调函数，内部抛错不会反应到外部</li>
<li>当处于<code>pending</code>时，无法得知目前进展到哪一个阶段</li>
<li>实例状态变为<code>resolved</code>或<code>rejected</code>时，会触发<code>then()</code>绑定的回调函数</li>
<li><code>resolve()</code>和<code>reject()</code>的执行总是晚于本轮循环的同步任务</li>
<li><code>then()</code>返回新实例，其后可再调用另一个<code>then()</code></li>
<li><code>then()</code>运行中抛出错误会被<code>catch()</code>捕获</li>
<li><code>reject()</code>的作用等同于抛出错误</li>
<li>实例状态已变成<code>resolved</code>时，再抛出错误是无效的，不会被捕获，等于没有抛出</li>
<li>实例状态的错误具有冒泡性质，会一直向后传递直到被捕获为止，错误总是会被下一个<code>catch()</code>捕获</li>
<li>不要在<code>then()</code>里定义<code>rejected</code>状态的回调函数(不使用其第二参数)</li>
<li>建议使用<code>catch()</code>捕获错误，不要使用<code>then()</code>第二个参数捕获</li>
<li>没有使用<code>catch()</code>捕获错误，实例抛错不会传递到外层代码，即不会有任何反应</li>
<li>作为参数的实例定义了<code>catch()</code>，一旦被<code>rejected</code>并不会触发<code>Promise.all()</code>的<code>catch()</code></li>
<li><code>Promise.reject()</code>的参数会原封不动地作为<code>rejected</code>的理由，变成后续方法的参数</li>
</ul>
<h3 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h3><ul>
<li><p>定义：封装多个内部状态的异步编程解决方案</p>
</li>
<li><p>形式：调用<code>Generator</code>函数(该函数不执行)返回指向内部状态的指针对象(不是运行结果)</p>
</li>
<li><p>声明：<code>function* Func() &#123;&#125;</code></p>
</li>
<li><p>方法</p>
<ul>
<li><code>next()</code>：使指针移向下一个状态，返回<code>&#123; done, value &#125;</code>(入参会被当作上一个<code>yield</code>命令表达式的返回值)</li>
<li><code>return()</code>：返回指定值且终结遍历<code>Generator</code>函数，返回<code>&#123; done: true, value: 入参 &#125;</code></li>
<li><code>throw()</code>：在<code>Generator</code>函数体外抛出错误，在<code>Generator</code>函数体内捕获错误，返回自定义的<code>new Errow()</code></li>
</ul>
</li>
<li><pre><code>yield
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">命令：声明内部状态的值(</span><br><span class="line"></span><br></pre></td></tr></table></figure>
return
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  声明结束返回的值)</span><br><span class="line"></span><br><span class="line">  - 遇到`yield`命令就暂停执行后面的操作，并将其后表达式的值作为返回对象的`value`</span><br><span class="line">  - 下次调用`next()`时，再继续往下执行直到遇到下一个`yield`命令</span><br><span class="line">  - 没有再遇到`yield`命令就一直运行到`Generator`函数结束，直到遇到`return`语句为止并将其后表达式的值作为返回对象的`value`</span><br><span class="line">  - `Generator`函数没有`return`语句则返回对象的`value`为`undefined`</span><br><span class="line"></span><br><span class="line">- `yield*`命令：在一个`Generator`函数里执行另一个`Generator`函数(后随具有`Iterator`接口的数据结构)</span><br><span class="line"></span><br><span class="line">- 遍历：通过`for-of`自动调用`next()`</span><br><span class="line"></span><br><span class="line">- 作为对象属性</span><br><span class="line"></span><br><span class="line">  - 全写：`const obj = &#123; method: function*() &#123;&#125; &#125;`</span><br><span class="line">  - 简写：`const obj = &#123; * method() &#123;&#125; &#125;`</span><br><span class="line"></span><br><span class="line">- 上下文：执行产生的上下文环境一旦遇到`yield`命令就会暂时退出堆栈(但并不消失)，所有变量和对象会冻结在当前状态，等到对它执行`next()`时，这个上下文环境又会重新加入调用栈，冻结的变量和对象恢复执行</span><br><span class="line"></span><br><span class="line">**方法异同**</span><br><span class="line"></span><br><span class="line">- 相同点</span><br><span class="line"></span><br><span class="line">  ：</span><br><span class="line"></span><br><span class="line">  - `next()`、`throw()`、`return()`本质上是同一件事，作用都是让函数恢复执行且使用不同的语句替换yield命令</span><br><span class="line"></span><br><span class="line">- 不同点</span><br><span class="line"></span><br><span class="line">  - `next()`：将`yield`命令替换成一个值</span><br><span class="line">  - `return()`：将`yield`命令替换成一个`return`语句</span><br><span class="line">  - `throw()`：将`yield`命令替换成一个`throw`语句</span><br><span class="line"></span><br><span class="line">**应用场景**</span><br><span class="line"></span><br><span class="line">- 异步操作同步化表达</span><br><span class="line">- 控制流管理</span><br><span class="line">- 为对象部署`Iterator`接口：把`Generator`函数赋值给对象的`Symbol.iterator`，从而使该对象具有`Iterator`接口</span><br><span class="line">- 作为具有`Iterator`接口的数据结构</span><br><span class="line"></span><br><span class="line">**重点难点**</span><br><span class="line"></span><br><span class="line">- 每次调用`next()`，指针就从函数头部或上次停下的位置开始执行，直到遇到下一个`yield`命令或`return`语句为止</span><br><span class="line">- 函数内部可不用`yield`命令，但会变成单纯的暂缓执行函数(还是需要`next()`触发)</span><br><span class="line">- `yield`命令是暂停执行的标记，`next()`是恢复执行的操作</span><br><span class="line">- `yield`命令用在另一个表达式中必须放在圆括号里</span><br><span class="line">- `yield`命令用作函数参数或放在赋值表达式的右边，可不加圆括号</span><br><span class="line">- `yield`命令本身没有返回值，可认为是返回`undefined`</span><br><span class="line">- `yield`命令表达式为惰性求值，等`next()`执行到此才求值</span><br><span class="line">- 函数调用后生成遍历器对象，此对象的`Symbol.iterator`是此对象本身</span><br><span class="line">- 在函数运行的不同阶段，通过`next()`从外部向内部注入不同的值，从而调整函数行为</span><br><span class="line">- 首个`next()`用来启动遍历器对象，后续才可传递参数</span><br><span class="line">- 想首次调用`next()`时就能输入值，可在函数外面再包一层</span><br><span class="line">- 一旦`next()`返回对象的`done`为`true`，`for-of`遍历会中止且不包含该返回对象</span><br><span class="line">- 函数内部部署`try-finally`且正在执行`try`，那么`return()`会导致立刻进入`finally`，执行完`finally`以后整个函数才会结束</span><br><span class="line">- 函数内部没有部署`try-catch`，`throw()`抛错将被外部`try-catch`捕获</span><br><span class="line">- `throw()`抛错要被内部捕获，前提是必须至少执行过一次`next()`</span><br><span class="line">- `throw()`被捕获以后，会附带执行下一条`yield`命令</span><br><span class="line">- 函数还未开始执行，这时`throw()`抛错只可能抛出在函数外部</span><br><span class="line"></span><br><span class="line">&gt; 首次next()可传值</span><br><span class="line"></span><br></pre></td></tr></table></figure>
function Wrapper(func) &#123;
  return function(...args) &#123;
      const generator = func(...args);
      generator.next();
      return generator;
  &#125;
&#125;
const print = Wrapper(function*() &#123;
  console.log(`First Input: $&#123;yield&#125;`);
  return &quot;done&quot;;
&#125;);
print().next(&quot;hello&quot;);
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## ES2016</span><br><span class="line"></span><br><span class="line">![img](https://poetries1.gitee.io/img-repo/2019/11/126.png)</span><br><span class="line"></span><br><span class="line">### 数值扩展</span><br><span class="line"></span><br><span class="line">- 指数运算符(`**`)：数值求幂(相当于`Math.pow()`)</span><br><span class="line"></span><br><span class="line">### 数组扩展</span><br><span class="line"></span><br><span class="line">- `includes()`：是否存在指定成员</span><br><span class="line"></span><br><span class="line">## ES2017</span><br><span class="line"></span><br><span class="line">![img](https://poetries1.gitee.io/img-repo/2019/11/127.png)</span><br><span class="line"></span><br><span class="line">**声明**</span><br><span class="line"></span><br><span class="line">- 共享内存和原子操作：由全局对象`SharedArrayBuffer`和`Atomics`实现，将数据存储在一块共享内存空间中，这些数据可在`JS`主线程和`web-worker`线程之间共享</span><br><span class="line"></span><br><span class="line">### 字符串扩展</span><br><span class="line"></span><br><span class="line">- `padStart()`：把指定字符串填充到字符串头部，返回新字符串</span><br><span class="line">- `padEnd()`：把指定字符串填充到字符串尾部，返回新字符串</span><br><span class="line"></span><br><span class="line">**对象扩展**</span><br><span class="line"></span><br><span class="line">- `Object.getOwnPropertyDescriptors()`：返回对象所有自身属性(非继承属性)的描述对象</span><br><span class="line">- `Object.values()`：返回以值组成的数组</span><br><span class="line">- `Object.entries()`：返回以键和值组成的数组</span><br><span class="line"></span><br><span class="line">### 函数扩展</span><br><span class="line"></span><br><span class="line">- 函数参数尾逗号：允许函数最后一个参数有尾逗号</span><br><span class="line"></span><br><span class="line">**Async**</span><br><span class="line"></span><br><span class="line">- 定义：使异步函数以同步函数的形式书写(`Generator`函数语法糖)</span><br><span class="line"></span><br><span class="line">- 原理：将`Generator`函数和自动执行器`spawn`包装在一个函数里</span><br><span class="line"></span><br><span class="line">- 形式：将`Generator`函数的`*`替换成`async`，将`yield`替换成`await`</span><br><span class="line"></span><br><span class="line">- 声明</span><br><span class="line"></span><br><span class="line">  - 具名函数：`async function Func() &#123;&#125;`</span><br><span class="line">  - 函数表达式：`const func = async function() &#123;&#125;`</span><br><span class="line">  - 箭头函数：`const func = async() =&gt; &#123;&#125;`</span><br><span class="line">  - 对象方法：`const obj = &#123; async func() &#123;&#125; &#125;`</span><br><span class="line">  - 类方法：`class Cla &#123; async Func() &#123;&#125; &#125;`</span><br><span class="line"></span><br><span class="line">- await命令</span><br><span class="line"></span><br><span class="line">  ：等待当前</span><br><span class="line"></span><br></pre></td></tr></table></figure>
Promise
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  对象状态变更完毕</span><br><span class="line"></span><br><span class="line">  - 正常情况：后面是`Promise`对象则返回其结果，否则返回对应的值</span><br><span class="line">  - 后随`Thenable`对象：将其等同于`Promise`对象返回其结果</span><br><span class="line"></span><br><span class="line">- **错误处理**：将`await`命令`Promise`对象放到`try-catch`中(可放多个)</span><br><span class="line"></span><br><span class="line">**Async对Generator改进**</span><br><span class="line"></span><br><span class="line">- 内置执行器</span><br><span class="line">- 更好的语义</span><br><span class="line">- 更广的适用性</span><br><span class="line">- 返回值是`Promise`对象</span><br><span class="line"></span><br><span class="line">**应用场景**</span><br><span class="line"></span><br><span class="line">- 按顺序完成异步操作</span><br><span class="line"></span><br><span class="line">**重点难点**</span><br><span class="line"></span><br><span class="line">- `Async`函数返回`Promise`对象，可使用`then()`添加回调函数</span><br><span class="line">- 内部`return`返回值会成为后续`then()`的出参</span><br><span class="line">- 内部抛出错误会导致返回的`Promise`对象变为`rejected`状态，被`catch()`接收到</span><br><span class="line">- 返回的`Promise`对象必须等到内部所有`await`命令`Promise`对象执行完才会发生状态改变，除非遇到`return`语句或抛出错误</span><br><span class="line">- 任何一个`await`命令`Promise`对象变为`rejected`状态，整个`Async`函数都会中断执行</span><br><span class="line">- 希望即使前一个异步操作失败也不要中断后面的异步操作</span><br><span class="line">  - 将`await`命令`Promise`对象放到`try-catch`中</span><br><span class="line">  - `await`命令`Promise`对象跟一个`catch()`</span><br><span class="line">- `await`命令`Promise`对象可能变为`rejected`状态，最好把其放到`try-catch`中</span><br><span class="line">- 多个`await`命令`Promise`对象若不存在继发关系，最好让它们同时触发</span><br><span class="line">- `await`命令只能用在`Async`函数之中，否则会报错</span><br><span class="line">- 数组使用`forEach()`执行`async/await`会失效，可使用`for-of`和P`romise.all()`代替</span><br><span class="line">- 可保留运行堆栈，函数上下文随着`Async`函数的执行而存在，执行完成就消失</span><br><span class="line"></span><br><span class="line">## ES2018</span><br><span class="line"></span><br><span class="line">![img](https://poetries1.gitee.io/img-repo/2019/11/128.png)</span><br><span class="line"></span><br><span class="line">### 字符串扩展</span><br><span class="line"></span><br><span class="line">- 放松对标签模板里字符串转义的限制：遇到不合法的字符串转义返回`undefined`，并且从`raw`上可获取原字符串</span><br><span class="line"></span><br><span class="line">**对象扩展**</span><br><span class="line"></span><br><span class="line">- 扩展运算符(`...`)：转换对象为用逗号分隔的参数序列(`&#123; ...obj &#125;`，相当于`rest/spread`参数的逆运算)</span><br><span class="line"></span><br><span class="line">&gt; 扩展应用</span><br><span class="line"></span><br><span class="line">- 克隆对象：`const obj = &#123; __proto__: Object.getPrototypeOf(obj1), ...obj1 &#125;`</span><br><span class="line">- 合并对象：`const obj = &#123; ...obj1, ...obj2 &#125;`</span><br><span class="line">- 转换字符串为对象：`&#123; ...&quot;hello&quot; &#125;`</span><br><span class="line">- 转换数组为对象：`&#123; ...[1, 2] &#125;`</span><br><span class="line">- 与对象解构赋值结合：`const &#123; x, ...rest/spread &#125; = &#123; x: 1, y: 2, z: 3 &#125;`(不能复制继承自原型对象的属性)</span><br><span class="line">- 修改现有对象部分属性：`const obj = &#123; x: 1, ...&#123; x: 2 &#125; &#125;`</span><br><span class="line"></span><br><span class="line">### 正则扩展</span><br><span class="line"></span><br><span class="line">- `s`修饰符：`dotAll`模式修饰符，使`.`匹配任意单个字符(`dotAll`模式)</span><br><span class="line"></span><br><span class="line">- `dotAll`：是否设置`s`修饰符</span><br><span class="line"></span><br><span class="line">- 后行断言：`x`只有在`y`后才匹配</span><br><span class="line"></span><br><span class="line">- 后行否定断言：`x`只有不在`y`后才匹配</span><br><span class="line"></span><br><span class="line">- `Unicode`属性转义</span><br><span class="line"></span><br><span class="line">  ：匹配符合</span><br><span class="line"></span><br></pre></td></tr></table></figure>
Unicode
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  某种属性的所有字符</span><br><span class="line"></span><br><span class="line">  - 正向匹配：`\p&#123;PropRule&#125;`</span><br><span class="line">  - 反向匹配：`\P&#123;PropRule&#125;`</span><br><span class="line">  - 限制：`\p&#123;...&#125;`和`\P&#123;...&#125;`只对`Unicode`字符有效，使用时需加上u修饰符</span><br><span class="line"></span><br><span class="line">- 具名组匹配</span><br><span class="line"></span><br><span class="line">  ：为每组匹配指定名字(</span><br><span class="line"></span><br></pre></td></tr></table></figure>
?&lt;GroupName&gt;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  - 形式：`str.exec().groups.GroupName`</span><br><span class="line">  - 解构赋值替换</span><br><span class="line">    - 声明：`const time = &quot;2017-09-11&quot;、const regexp = /(?\d&#123;4&#125;)-(?\d&#123;2&#125;)-(?\d&#123;2&#125;)/u`</span><br><span class="line">    - 匹配：`time.replace(regexp, &quot;$/$/$&quot;)`</span><br><span class="line"></span><br><span class="line">### Promise</span><br><span class="line"></span><br><span class="line">- `finally()`：指定不管最后状态如何都会执行的回调函数</span><br><span class="line"></span><br><span class="line">### Async</span><br><span class="line"></span><br><span class="line">- 异步迭代器(`for-await-of`)：，循环等待每个`Promise`对象变为`resolved`状态才进入下一步</span><br><span class="line"></span><br><span class="line">## ES2019</span><br><span class="line"></span><br><span class="line">![img](https://poetries1.gitee.io/img-repo/2019/11/129.png)</span><br><span class="line"></span><br><span class="line">### 字符串扩展</span><br><span class="line"></span><br><span class="line">- 直接输入`U+2028`和`U+2029`：字符串可直接输入行分隔符和段分隔符</span><br><span class="line">- `JSON.stringify()`改造：可返回不符合`UTF-8`标准的字符串</span><br><span class="line">- `trimStart()`：消除字符串头部空格，返回新字符串</span><br><span class="line">- `trimEnd()`：消除字符串尾部空格，返回新字符串</span><br><span class="line"></span><br><span class="line">### 对象扩展</span><br><span class="line"></span><br><span class="line">- `Object.fromEntries()`：返回以键和值组成的对象(`Object.entries()`的逆操作)</span><br><span class="line"></span><br><span class="line">### 数组扩展</span><br><span class="line"></span><br><span class="line">- `flat()`：扁平化数组，返回新数组</span><br><span class="line">- `flatMap()`：映射且扁平化数组，返回新数组(只能展开一层数组)</span><br><span class="line"></span><br><span class="line">### 函数扩展</span><br><span class="line"></span><br><span class="line">- `toString()`改造：返回函数原始代码(与编码一致)</span><br><span class="line">- `catch()`参数可省略：`catch()`中的参数可省略</span><br><span class="line"></span><br><span class="line">### Symbol</span><br><span class="line"></span><br><span class="line">- `description`：返回`Symbol`值的描述</span><br><span class="line"></span><br><span class="line">## ES提案</span><br><span class="line"></span><br><span class="line">![img](https://poetries1.gitee.io/img-repo/2019/11/130.png)</span><br><span class="line"></span><br><span class="line">### 声明</span><br><span class="line"></span><br><span class="line">- `globalThis`对象：作为顶层对象，指向全局环境下的`this`</span><br><span class="line">- `do`表达式：封装块级作用域的操作，返回内部最后执行表达式的值(`do&#123;&#125;`)</span><br><span class="line">- `throw`表达式：直接使用`throw new Error()`，无需`()`或`&#123;&#125;`包括</span><br><span class="line">- `!#`命令：指定脚本执行器(写在文件首行)</span><br><span class="line"></span><br><span class="line">### 数值扩展</span><br><span class="line"></span><br><span class="line">- 数值分隔符(`_`)：使用`_`作为千分位分隔符(增加数值的可读性)</span><br><span class="line">- `BigInt()`：创建任何位数的整数(新增的数据类型，使用`n`结尾)</span><br><span class="line"></span><br><span class="line">### 对象扩展</span><br><span class="line"></span><br><span class="line">- 链判断操作符(`?.`)：是否存在对象属性(不存在返回`undefined`且不再往下执行)</span><br><span class="line">- 空判断操作符(`??`)：是否值为`undefined`或`null`，是则使用默认值</span><br><span class="line"></span><br><span class="line">### 函数扩展</span><br><span class="line"></span><br><span class="line">- 函数部分执行：复用函数功能(`?`表示单个参数占位符，`...`表示多个参数占位符)</span><br><span class="line"></span><br><span class="line">- 管道操作符(`|&gt;`)：把左边表达式的值传入右边的函数进行求值(`f(x) =&gt; x |&gt; f`)</span><br><span class="line"></span><br><span class="line">- 绑定运算符(</span><br><span class="line"></span><br></pre></td></tr></table></figure>
::
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">)：函数绑定(左边是对象右边是函数，取代</span><br><span class="line"></span><br></pre></td></tr></table></figure>
bind
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">、</span><br><span class="line"></span><br></pre></td></tr></table></figure>
apply
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">、</span><br><span class="line"></span><br></pre></td></tr></table></figure>
call
</code></pre>
<p>调用)</p>
<ul>
<li><code>bind：bar.bind(foo)</code> &#x3D;&gt; <code>foo::bar</code></li>
<li><code>apply</code>：bar.apply(foo, arguments)<code>=&gt;</code>foo::bar(…arguments)&#96;</li>
</ul>
</li>
</ul>
<h3 id="Proxy-1"><a href="#Proxy-1" class="headerlink" title="Proxy"></a>Proxy</h3><ul>
<li><code>Promise.try()</code>：不想区分是否同步异步函数，包装函数为实例，使用<code>then()</code>指定下一步流程，使用<code>catch()</code>捕获错误</li>
</ul>
<h3 id="Realm"><a href="#Realm" class="headerlink" title="Realm"></a>Realm</h3><ul>
<li>定义：提供沙箱功能，允许隔离代码，防止被隔离的代码拿到全局对象</li>
<li>声明：<code>new Realm().global</code></li>
</ul>
<h3 id="Class-1"><a href="#Class-1" class="headerlink" title="Class"></a>Class</h3><ul>
<li>静态属性：使用<code>static</code>定义属性，该属性不会被实例继承，只能通过类来调用</li>
<li>私有属性：使用<code>#</code>定义属性，该属性只能在类内部访问</li>
<li>私有方法：使用<code>#</code>定义方法，该方法只能在类内部访问</li>
<li>装饰器：使用<code>@</code>注释或修改类和类方法</li>
</ul>
<h3 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h3><ul>
<li>import()：动态导入(返回Promise)<ul>
<li>背景：<code>import</code>命令被JS引擎静态分析，先于模块内的其他语句执行，无法取代<code>require()</code>的动态加载功能，提案建议引入<code>import()</code>来代替<code>require()</code></li>
<li>位置：可在任何地方使用</li>
<li>区别：<code>require()</code>是同步加载，<code>import()</code>是异步加载</li>
<li>场景：按需加载、条件加载、模块路径动态化</li>
</ul>
</li>
<li><strong>import.meta：返回脚本元信息</strong></li>
</ul>
<h3 id="Async"><a href="#Async" class="headerlink" title="Async"></a>Async</h3><ul>
<li>顶层<code>Await</code>：允许在模块的顶层独立使用<code>await</code>命令(借用<code>await</code>解决模块异步加载的问题)</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/03/23/html+css+js+ts/4-es6/" data-id="cl7k9sbhs00cl98u06x6y2gmg" data-title="ES 2015~2019" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/es6/" rel="tag">es6</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-html+css+js+ts/4-asyncawait" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/03/20/html+css+js+ts/4-asyncawait/" class="article-date">
  <time class="dt-published" datetime="2018-03-20T01:21:42.000Z" itemprop="datePublished">2018-03-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/03/20/html+css+js+ts/4-asyncawait/">ES async/await</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="一、含义"><a href="#一、含义" class="headerlink" title="一、含义"></a>一、含义</h2><blockquote>
<p><code>async</code> 函数是什么？一句话，它就是 <code>Generator</code> 函数的语法糖</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 有一个 Generator 函数，依次读取两个文件</span><br><span class="line"></span><br><span class="line">const fs = require(&#x27;fs&#x27;);</span><br><span class="line"></span><br><span class="line">const readFile = function (fileName) &#123;</span><br><span class="line">  return new Promise(function (resolve, reject) &#123;</span><br><span class="line">    fs.readFile(fileName, function(error, data) &#123;</span><br><span class="line">      if (error) return reject(error);</span><br><span class="line">      resolve(data);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const gen = function* () &#123;</span><br><span class="line">  const f1 = yield readFile(&#x27;/etc/fstab&#x27;);</span><br><span class="line">  const f2 = yield readFile(&#x27;/etc/shells&#x27;);</span><br><span class="line">  console.log(f1.toString());</span><br><span class="line">  console.log(f2.toString());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面代码的函数<code>gen</code>可以写成<code>async</code>函数，就是下面这样</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const asyncReadFile = async function () &#123;</span><br><span class="line">  const f1 = await readFile(&#x27;/etc/fstab&#x27;);</span><br><span class="line">  const f2 = await readFile(&#x27;/etc/shells&#x27;);</span><br><span class="line">  console.log(f1.toString());</span><br><span class="line">  console.log(f2.toString());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>async</code>函数就是将 <code>Generator</code> 函数的星号（<code>*</code>）替换成<code>async</code>，将<code>yield</code>替换成<code>await</code>，仅此而已</p>
</blockquote>
<p><strong>async函数对 Generator 函数的改进，体现在以下四点</strong></p>
<ol>
<li>内置执行器</li>
</ol>
<blockquote>
<p><code>Generator</code>函数的执行必须靠执行器，所以才有了<code>co</code>模块，而<code>async</code>函数自带执行器。也就是说，<code>async</code>函数的执行，与普通函数一模一样，只要一行</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">asyncReadFile();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面的代码调用了<code>asyncReadFile</code>函数，然后它就会自动执行，输出最后结果。这完全不像 <code>Generator</code>函数，需要调用<code>next</code>方法，或者用<code>co</code>模块，才能真正执行，得到最后结果</p>
</blockquote>
<ol>
<li>更好的语义</li>
</ol>
<blockquote>
<p><code>async</code>和<code>await</code>，比起星号和<code>yield</code>，语义更清楚了。<code>async</code>表示函数里有异步操作，<code>await</code>表示紧跟在后面的表达式需要等待结果</p>
</blockquote>
<ol>
<li>更广的适用性</li>
</ol>
<blockquote>
<p><code>co</code>模块约定，<code>yield</code>命令后面只能是 <code>Thunk</code> 函数或 <code>Promise</code> 对象，而<code>async</code>函数的<code>await</code>命令后面，可以是 <code>Promise</code> 对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）</p>
</blockquote>
<ol>
<li>返回值是 <code>Promise</code></li>
</ol>
<blockquote>
<p><code>async</code>函数的返回值是 <code>Promise</code> 对象，这比 <code>Generator</code> 函数的返回值是 <code>Iterator</code> 对象方便多了。你可以用<code>then</code>方法指定下一步的操作</p>
</blockquote>
<p>进一步说，<code>async</code>函数完全可以看作多个异步操作，包装成的一个 <code>Promise</code> 对象，而<code>await</code>命令就是内部<code>then</code>命令的语法糖</p>
<h2 id="二、基本用法"><a href="#二、基本用法" class="headerlink" title="二、基本用法"></a>二、基本用法</h2><blockquote>
<p><code>async</code>函数返回一个 <code>Promise</code> 对象，可以使用<code>then</code>方法添加回调函数。当函数执行的时候，一旦遇到<code>await</code>就会先返回，等到异步操作完成，再接着执行函数体内后面的语句</p>
</blockquote>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/53.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 调用该函数时，会立即返回一个Promise对象</span><br><span class="line">async function getStockPriceByName(name) &#123;</span><br><span class="line">  const symbol = await getStockSymbol(name);</span><br><span class="line">  const stockPrice = await getStockPrice(symbol);</span><br><span class="line">  return stockPrice;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getStockPriceByName(&#x27;goog&#x27;).then(function (result) &#123;</span><br><span class="line">  console.log(result);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>async 函数有多种使用形式</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 函数声明</span><br><span class="line">async function foo() &#123;&#125;</span><br><span class="line"></span><br><span class="line">// 函数表达式</span><br><span class="line">const foo = async function () &#123;&#125;;</span><br><span class="line"></span><br><span class="line">// 对象的方法</span><br><span class="line">let obj = &#123; async foo() &#123;&#125; &#125;;</span><br><span class="line">obj.foo().then(...)</span><br><span class="line"></span><br><span class="line">// Class 的方法</span><br><span class="line">class Storage &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.cachePromise = caches.open(&#x27;avatars&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  async getAvatar(name) &#123;</span><br><span class="line">    const cache = await this.cachePromise;</span><br><span class="line">    return cache.match(`/avatars/$&#123;name&#125;.jpg`);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const storage = new Storage();</span><br><span class="line">storage.getAvatar(&#x27;jake&#x27;).then(…);</span><br><span class="line"></span><br><span class="line">// 箭头函数</span><br><span class="line">const foo = async () =&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="三、语法"><a href="#三、语法" class="headerlink" title="三、语法"></a>三、语法</h2><blockquote>
<p><code>async</code>函数的语法规则总体上比较简单，难点是错误处理机制</p>
</blockquote>
<h3 id="3-1-返回-Promise-对象"><a href="#3-1-返回-Promise-对象" class="headerlink" title="3.1 返回 Promise 对象"></a>3.1 返回 Promise 对象</h3><ul>
<li><code>async</code>函数返回一个 <code>Promise</code> 对象</li>
<li><code>async</code>函数内部<code>return</code>语句返回的值，会成为<code>then</code>方法回调函数的参数</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 函数f内部return命令返回的值，会被then方法回调函数接收到</span><br><span class="line">async function f() &#123;</span><br><span class="line">  return &#x27;hello world&#x27;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f().then(v =&gt; console.log(v))</span><br><span class="line">// &quot;hello world&quot;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>async</code>函数内部抛出错误，会导致返回的 <code>Promise</code> 对象变为<code>reject</code>状态。抛出的错误对象会被<code>catch</code>方法回调函数接收到</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">async function f() &#123;</span><br><span class="line">  throw new Error(&#x27;出错了&#x27;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f().then(</span><br><span class="line">  v =&gt; console.log(v),</span><br><span class="line">  e =&gt; console.log(e)</span><br><span class="line">)</span><br><span class="line">// Error: 出错了</span><br></pre></td></tr></table></figure>

<h3 id="3-2-Promise-对象的状态变化"><a href="#3-2-Promise-对象的状态变化" class="headerlink" title="3.2 Promise 对象的状态变化"></a>3.2 Promise 对象的状态变化</h3><blockquote>
<p><code>async</code>函数返回的 <code>Promise</code> 对象，必须等到内部所有<code>await</code>命令后面的 <code>Promise</code> 对象执行完，才会发生状态改变，除非遇到<code>return</code>语句或者抛出错误。也就是说，只有<code>async</code>函数内部的异步操作执行完，才会执行<code>then</code>方法指定的回调函数</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">async function getTitle(url) &#123;</span><br><span class="line">  let response = await fetch(url);</span><br><span class="line">  let html = await response.text();</span><br><span class="line">  return html.match(/&lt;title&gt;([\s\S]+)&lt;\/title&gt;/i)[1];</span><br><span class="line">&#125;</span><br><span class="line">getTitle(&#x27;https://tc39.github.io/ecma262/&#x27;).then(console.log)</span><br><span class="line">// &quot;ECMAScript 2017 Language Specification&quot;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-await-命令"><a href="#3-3-await-命令" class="headerlink" title="3.3 await 命令"></a>3.3 await 命令</h3><blockquote>
<p>正常情况下，<code>await</code>命令后面是一个 <code>Promise</code> 对象，返回该对象的结果。如果不是 <code>Promise</code> 对象，就直接返回对应的值</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">async function f() &#123;</span><br><span class="line">  // 等同于</span><br><span class="line">  // return 123;</span><br><span class="line">  return await 123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f().then(v =&gt; console.log(v))</span><br><span class="line">// 123</span><br></pre></td></tr></table></figure>

<blockquote>
<p>另一种情况是，<code>await</code>命令后面是一个<code>thenable</code>对象（即定义<code>then</code>方法的对象），那么<code>await</code>会将其等同于 <code>Promise</code> 对象</p>
</blockquote>
<ul>
<li><code>await</code>命令后面的 <code>Promise</code> 对象如果变为<code>reject</code>状态，则<code>reject</code>的参数会被<code>catch</code>方法的回调函数接收到。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">async function f() &#123;</span><br><span class="line">  await Promise.reject(&#x27;出错了&#x27;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f()</span><br><span class="line">.then(v =&gt; console.log(v))</span><br><span class="line">.catch(e =&gt; console.log(e))</span><br><span class="line">// 出错了</span><br></pre></td></tr></table></figure>

<ul>
<li>注意，上面代码中，<code>await</code>语句前面没有<code>return</code>，但是<code>reject</code>方法的参数依然传入了<code>catch</code>方法的回调函数。这里如果在<code>await</code>前面加上<code>return</code>，效果是一样的。</li>
<li>任何一个<code>await</code>语句后面的 <code>Promise</code> 对象变为<code>reject</code>状态，那么整个<code>async</code>函数都会中断执行</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">async function f() &#123;</span><br><span class="line">  await Promise.reject(&#x27;出错了&#x27;);</span><br><span class="line">  await Promise.resolve(&#x27;hello world&#x27;); // 不会执行</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>有时，我们希望即使前一个异步操作失败，也不要中断后面的异步操作。这时可以将第一个<code>await</code>放在<code>try...catch</code>结构里面，这样不管这个异步操作是否成功，第二个<code>await</code>都会执行</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">async function f() &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    await Promise.reject(&#x27;出错了&#x27;);</span><br><span class="line">  &#125; catch(e) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  return await Promise.resolve(&#x27;hello world&#x27;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f()</span><br><span class="line">.then(v =&gt; console.log(v))</span><br><span class="line">// hello world</span><br></pre></td></tr></table></figure>

<blockquote>
<p>另一种方法是<code>await</code>后面的 <code>Promise</code> 对象再跟一个<code>catch</code>方法，处理前面可能出现的错误。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">async function f() &#123;</span><br><span class="line">  await Promise.reject(&#x27;出错了&#x27;)</span><br><span class="line">    .catch(e =&gt; console.log(e));</span><br><span class="line">  return await Promise.resolve(&#x27;hello world&#x27;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f()</span><br><span class="line">.then(v =&gt; console.log(v))</span><br><span class="line">// 出错了</span><br><span class="line">// hello world</span><br></pre></td></tr></table></figure>

<h3 id="3-4-错误处理"><a href="#3-4-错误处理" class="headerlink" title="3.4 错误处理"></a>3.4 错误处理</h3><blockquote>
<p>如果<code>await</code>后面的异步操作出错，那么等同于<code>async</code>函数返回的 <code>Promise</code> 对象被<code>reject</code></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">async function f() &#123;</span><br><span class="line">  await new Promise(function (resolve, reject) &#123;</span><br><span class="line">    throw new Error(&#x27;出错了&#x27;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f()</span><br><span class="line">.then(v =&gt; console.log(v))</span><br><span class="line">.catch(e =&gt; console.log(e))</span><br><span class="line">// Error：出错了</span><br></pre></td></tr></table></figure>

<blockquote>
<p>防止出错的方法，也是将其放在<code>try...catch</code>代码块之中</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">async function f() &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    await new Promise(function (resolve, reject) &#123;</span><br><span class="line">      throw new Error(&#x27;出错了&#x27;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; catch(e) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  return await(&#x27;hello world&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果有多个<code>await</code>命令，可以统一放在<code>try...catch</code>结构中</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">async function main() &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    const val1 = await firstStep();</span><br><span class="line">    const val2 = await secondStep(val1);</span><br><span class="line">    const val3 = await thirdStep(val1, val2);</span><br><span class="line"></span><br><span class="line">    console.log(&#x27;Final: &#x27;, val3);</span><br><span class="line">  &#125;</span><br><span class="line">  catch (err) &#123;</span><br><span class="line">    console.error(err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-5-使用注意点"><a href="#3-5-使用注意点" class="headerlink" title="3.5 使用注意点"></a>3.5 使用注意点</h3><blockquote>
<p>第一点：<code>await</code>命令后面的Promise对象，运行结果可能是<code>rejected</code>，所以最好把<code>await</code>命令放在<code>try...catch</code>代码块中</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">async function myFunction() &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    await somethingThatReturnsAPromise();</span><br><span class="line">  &#125; catch (err) &#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 另一种写法</span><br><span class="line"></span><br><span class="line">async function myFunction() &#123;</span><br><span class="line">  await somethingThatReturnsAPromise()</span><br><span class="line">  .catch(function (err) &#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>第二点，多个<code>await</code>命令后面的异步操作，如果不存在继发关系，最好让它们同时触发</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// getFoo和getBar是两个独立的异步操作（即互不依赖），被写成继发关系。这样比较耗时，因为只有getFoo完成以后，才会执行getBar，完全可以让它们同时触发</span><br><span class="line"></span><br><span class="line">let foo = await getFoo();</span><br><span class="line">let bar = await getBar();</span><br><span class="line">// 两种写法，getFoo和getBar都是同时触发，这样就会缩短程序的执行时间。</span><br><span class="line"></span><br><span class="line">// 写法一</span><br><span class="line">let [foo, bar] = await Promise.all([getFoo(), getBar()]);</span><br><span class="line"></span><br><span class="line">// 写法二</span><br><span class="line">let fooPromise = getFoo();</span><br><span class="line">let barPromise = getBar();</span><br><span class="line">let foo = await fooPromise;</span><br><span class="line">let bar = await barPromise;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>第三点，<code>await</code>命令只能用在<code>async</code>函数之中，如果用在普通函数，就会报错</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">async function dbFuc(db) &#123;</span><br><span class="line">  let docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line"></span><br><span class="line">  // 报错</span><br><span class="line">  docs.forEach(function (doc) &#123;</span><br><span class="line">    await db.post(doc);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四、async-函数的实现原理"><a href="#四、async-函数的实现原理" class="headerlink" title="四、async 函数的实现原理"></a>四、async 函数的实现原理</h2><blockquote>
<p><code>async</code> 函数的实现原理，就是将 <code>Generator</code> 函数和自动执行器，包装在一个函数里</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">async function fn(args) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line"></span><br><span class="line">function fn(args) &#123;</span><br><span class="line">  return spawn(function* () &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>所有的<code>async</code>函数都可以写成上面的第二种形式，其中的<code>spawn</code>函数就是自动执行器</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// spawn函数的实现，基本就是前文自动执行器的翻版</span><br><span class="line"></span><br><span class="line">function spawn(genF) &#123;</span><br><span class="line">  return new Promise(function(resolve, reject) &#123;</span><br><span class="line">    const gen = genF();</span><br><span class="line">    function step(nextF) &#123;</span><br><span class="line">      let next;</span><br><span class="line">      try &#123;</span><br><span class="line">        next = nextF();</span><br><span class="line">      &#125; catch(e) &#123;</span><br><span class="line">        return reject(e);</span><br><span class="line">      &#125;</span><br><span class="line">      if(next.done) &#123;</span><br><span class="line">        return resolve(next.value);</span><br><span class="line">      &#125;</span><br><span class="line">      Promise.resolve(next.value).then(function(v) &#123;</span><br><span class="line">        step(function() &#123; return gen.next(v); &#125;);</span><br><span class="line">      &#125;, function(e) &#123;</span><br><span class="line">        step(function() &#123; return gen.throw(e); &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    step(function() &#123; return gen.next(undefined); &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/03/20/html+css+js+ts/4-asyncawait/" data-id="cl7k9sbhp00c798u0cb0w5x4d" data-title="ES async/await" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/es6/" rel="tag">es6</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/18/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/17/">17</a><a class="page-number" href="/page/18/">18</a><span class="page-number current">19</span><a class="page-number" href="/page/20/">20</a><a class="page-number" href="/page/21/">21</a><a class="extend next" rel="next" href="/page/20/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/React/">React</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/css/">css</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/http/">http</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/javascript/">javascript</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/liunx/">liunx</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/%E7%A7%BB%E5%8A%A8%E7%AB%AF/">移动端</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/%E9%97%AE%E9%A2%98/">问题</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/%E9%9F%B3%E8%A7%86%E9%A2%91/">音视频</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/">前端工程化</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">前端性能优化</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%8E%9F%E7%90%86/">原理</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%8E%9F%E7%90%86/React/">React</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%90%8E%E7%AB%AF/">后端</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%90%8E%E7%AB%AF/%E7%AE%97%E6%B3%95/">算法</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/">小程序</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B7%A5%E5%85%B7/">工具</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BE%AE%E5%89%8D%E7%AB%AF/">微前端</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/">数据可视化</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/">架构模式</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/%E6%A1%86%E6%9E%B6/">框架</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%A1%86%E6%9E%B6/">框架</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%A1%86%E6%9E%B6/React/">React</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">正则表达式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/">浏览器</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%88%AC%E8%99%AB/">爬虫</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Graphviz/" rel="tag">Graphviz</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mock/" rel="tag">Mock</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RESTful/" rel="tag">RESTful</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React/" rel="tag">React</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redux/" rel="tag">Redux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/async-await/" rel="tag">async&#x2F;await</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/css/" rel="tag">css</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/echart/" rel="tag">echart</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/es6/" rel="tag">es6</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/eslint/" rel="tag">eslint</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/" rel="tag">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/glup/" rel="tag">glup</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/" rel="tag">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/html/" rel="tag">html</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/http/" rel="tag">http</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javascript/" rel="tag">javascript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mongodb/" rel="tag">mongodb</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nginx/" rel="tag">nginx</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/" rel="tag">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/qiankun/" rel="tag">qiankun</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/react/" rel="tag">react</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/typescript/" rel="tag">typescript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vs-code/" rel="tag">vs code</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vue/" rel="tag">vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vue3/" rel="tag">vue3</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/webpack/" rel="tag">webpack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/xml/" rel="tag">xml</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BC%98%E5%8C%96/" rel="tag">优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/" rel="tag">小程序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8A%93%E5%8C%85/" rel="tag">抓包</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" rel="tag">正则表达式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/" rel="tag">浏览器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/" rel="tag">移动端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Graphviz/" style="font-size: 10px;">Graphviz</a> <a href="/tags/Mock/" style="font-size: 10px;">Mock</a> <a href="/tags/RESTful/" style="font-size: 10px;">RESTful</a> <a href="/tags/React/" style="font-size: 19.23px;">React</a> <a href="/tags/Redux/" style="font-size: 11.54px;">Redux</a> <a href="/tags/async-await/" style="font-size: 10px;">async/await</a> <a href="/tags/css/" style="font-size: 13.85px;">css</a> <a href="/tags/echart/" style="font-size: 10px;">echart</a> <a href="/tags/es6/" style="font-size: 16.92px;">es6</a> <a href="/tags/eslint/" style="font-size: 10px;">eslint</a> <a href="/tags/git/" style="font-size: 16.15px;">git</a> <a href="/tags/glup/" style="font-size: 10.77px;">glup</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/html/" style="font-size: 14.62px;">html</a> <a href="/tags/http/" style="font-size: 17.69px;">http</a> <a href="/tags/javascript/" style="font-size: 13.08px;">javascript</a> <a href="/tags/mongodb/" style="font-size: 10px;">mongodb</a> <a href="/tags/mysql/" style="font-size: 10px;">mysql</a> <a href="/tags/nginx/" style="font-size: 10.77px;">nginx</a> <a href="/tags/python/" style="font-size: 10.77px;">python</a> <a href="/tags/qiankun/" style="font-size: 10px;">qiankun</a> <a href="/tags/react/" style="font-size: 10px;">react</a> <a href="/tags/typescript/" style="font-size: 12.31px;">typescript</a> <a href="/tags/vs-code/" style="font-size: 11.54px;">vs code</a> <a href="/tags/vue/" style="font-size: 20px;">vue</a> <a href="/tags/vue3/" style="font-size: 10px;">vue3</a> <a href="/tags/webpack/" style="font-size: 18.46px;">webpack</a> <a href="/tags/xml/" style="font-size: 10px;">xml</a> <a href="/tags/%E4%BC%98%E5%8C%96/" style="font-size: 13.85px;">优化</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 10.77px;">前端</a> <a href="/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/" style="font-size: 15.38px;">小程序</a> <a href="/tags/%E6%8A%93%E5%8C%85/" style="font-size: 10px;">抓包</a> <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 10px;">操作系统</a> <a href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" style="font-size: 10px;">正则表达式</a> <a href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/" style="font-size: 13.08px;">浏览器</a> <a href="/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/" style="font-size: 10.77px;">移动端</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 10px;">算法</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">April 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">January 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">October 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">September 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">July 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">June 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/04/12/%E5%BE%AE%E5%89%8D%E7%AB%AF/qiankun%E5%BE%AE%E5%89%8D%E7%AB%AF/">qiankun微前端</a>
          </li>
        
          <li>
            <a href="/2022/01/12/%E5%B7%A5%E5%85%B7/git-stach/">git-stach</a>
          </li>
        
          <li>
            <a href="/2021/10/16/Vue/vue3%E4%BC%98%E5%8C%96/">vue3优化</a>
          </li>
        
          <li>
            <a href="/2021/10/11/Vue/Vue3-%E8%AE%BE%E8%AE%A1%E7%9B%AE%E6%A0%87%E3%80%81%E5%81%9A%E4%BA%86%E5%93%AA%E4%BA%9B%E4%BC%98%E5%8C%96/">Vue3-设计目标、做了哪些优化</a>
          </li>
        
          <li>
            <a href="/2021/09/29/Vue/vue3-Treeshaking/">vue3-Treeshaking</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>