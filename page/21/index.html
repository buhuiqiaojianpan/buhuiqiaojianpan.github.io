<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/21/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-html+css+js+ts/2-css-基础（1）" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/02/24/html+css+js+ts/2-css-%E5%9F%BA%E7%A1%80%EF%BC%881%EF%BC%89/" class="article-date">
  <time class="dt-published" datetime="2018-02-24T01:21:16.000Z" itemprop="datePublished">2018-02-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/02/24/html+css+js+ts/2-css-%E5%9F%BA%E7%A1%80%EF%BC%881%EF%BC%89/">css-基础（1）</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <hr>
<table>
<thead>
<tr>
<th align="left"><strong>一、CSS 文字属性</strong></th>
<th align="left"></th>
</tr>
</thead>
<tbody><tr>
<td align="left">语 言</td>
<td align="left">功 能</td>
</tr>
<tr>
<td align="left">color : #999999;</td>
<td align="left">文字颜色</td>
</tr>
<tr>
<td align="left">font-family:宋体,sans-serif;</td>
<td align="left">文字字体</td>
</tr>
<tr>
<td align="left">font-size:9pt;</td>
<td align="left">文字大小</td>
</tr>
<tr>
<td align="left">font-style:itelic;</td>
<td align="left">文字斜体</td>
</tr>
<tr>
<td align="left">font-variant:small-caps;</td>
<td align="left">小字体</td>
</tr>
<tr>
<td align="left">letter-spacing:1pt;</td>
<td align="left">字间距离</td>
</tr>
<tr>
<td align="left">line-height : 200%;</td>
<td align="left">设置行高</td>
</tr>
<tr>
<td align="left">font-weight:bold;</td>
<td align="left">文字粗体</td>
</tr>
<tr>
<td align="left">vertical-align:sub;</td>
<td align="left">下标字</td>
</tr>
<tr>
<td align="left">vertical-align:super;</td>
<td align="left">上标字</td>
</tr>
<tr>
<td align="left">text-decoration:line-through;</td>
<td align="left">加删除线</td>
</tr>
<tr>
<td align="left">text-decoration:overline;</td>
<td align="left">加顶线</td>
</tr>
<tr>
<td align="left">text-decoration:underline;</td>
<td align="left">加下画线</td>
</tr>
<tr>
<td align="left">text-decoration:none;</td>
<td align="left">删除链接下画线</td>
</tr>
<tr>
<td align="left">text-transform:capitalize;</td>
<td align="left">首字大写</td>
</tr>
<tr>
<td align="left">text-transform:uppercase;</td>
<td align="left">英文大写</td>
</tr>
<tr>
<td align="left">text-transform:lowercase;</td>
<td align="left">英文小写</td>
</tr>
<tr>
<td align="left">text-align:right;</td>
<td align="left">文字右对齐</td>
</tr>
<tr>
<td align="left">text-align:left;</td>
<td align="left">文字左对齐</td>
</tr>
<tr>
<td align="left">text-align:center;</td>
<td align="left">文字居中对齐</td>
</tr>
<tr>
<td align="left">text-align:justify;</td>
<td align="left">文字两端对齐</td>
</tr>
<tr>
<td align="left"><strong>vertical-align属性</strong></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">vertical-align:top;</td>
<td align="left">垂直向上对齐</td>
</tr>
<tr>
<td align="left">vertical-align:bottom;</td>
<td align="left">垂直向下对齐</td>
</tr>
<tr>
<td align="left">vertical-align:middle;</td>
<td align="left">垂直居中对齐</td>
</tr>
<tr>
<td align="left">vertical-align:text-top;</td>
<td align="left">文字垂直向上对齐</td>
</tr>
<tr>
<td align="left">vertical-align:text-bottom;</td>
<td align="left">文字垂直向下对齐</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><strong>二、CSS 项目符号</strong></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">list-style-type:none;</td>
<td align="left">不编号</td>
</tr>
<tr>
<td align="left">list-style-type:decimal;</td>
<td align="left">阿拉伯数字</td>
</tr>
<tr>
<td align="left">list-style-type:lower-roman;</td>
<td align="left">小写罗马数字</td>
</tr>
<tr>
<td align="left">list-style-type:upper-roman;</td>
<td align="left">大写罗马数字</td>
</tr>
<tr>
<td align="left">list-style-type:lower-alpha;</td>
<td align="left">小写英文字母</td>
</tr>
<tr>
<td align="left">list-style-type:upper-alpha;</td>
<td align="left">大写英文字母</td>
</tr>
<tr>
<td align="left">list-style-type:disc;</td>
<td align="left">实心圆形符号</td>
</tr>
<tr>
<td align="left">list-style-type:circle;</td>
<td align="left">空心圆形符号</td>
</tr>
<tr>
<td align="left">list-style-type:square;</td>
<td align="left">实心方形符号</td>
</tr>
<tr>
<td align="left">list-style-image:url(&#x2F;dot.gif)</td>
<td align="left">图片式符号</td>
</tr>
<tr>
<td align="left">list-style-position:outside;</td>
<td align="left">凸排</td>
</tr>
<tr>
<td align="left">list-style-position:inside;</td>
<td align="left">缩进</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><strong>三、CSS 背景样式</strong></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">background-color:#F5E2EC;</td>
<td align="left">背景颜色</td>
</tr>
<tr>
<td align="left">background:transparent;</td>
<td align="left">透视背景</td>
</tr>
<tr>
<td align="left">background-image:url(image&#x2F;bg.gif);</td>
<td align="left">背景图片</td>
</tr>
<tr>
<td align="left">background-attachment:fixed;</td>
<td align="left">浮水印固定背景</td>
</tr>
<tr>
<td align="left">background-repeat:repeat;</td>
<td align="left">重复排列-网页默认</td>
</tr>
<tr>
<td align="left">background-repeat:no-repeat;</td>
<td align="left">不重复排列</td>
</tr>
<tr>
<td align="left">background-repeat:repeat-x;</td>
<td align="left">在 X 轴重复排列</td>
</tr>
<tr>
<td align="left">background-repeat:repeat-y;</td>
<td align="left">在 Y 轴重复排列</td>
</tr>
<tr>
<td align="left">background-position:90% 90%;</td>
<td align="left">背景图片 X 与 Y 轴的位置</td>
</tr>
<tr>
<td align="left">background-position:top;</td>
<td align="left">向上对齐</td>
</tr>
<tr>
<td align="left">background-position:buttom;</td>
<td align="left">向下对齐</td>
</tr>
<tr>
<td align="left">background-position:left;</td>
<td align="left">向左对齐</td>
</tr>
<tr>
<td align="left">background-position:right;</td>
<td align="left">向右对齐</td>
</tr>
<tr>
<td align="left">background-position:center;</td>
<td align="left">居中对齐</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><strong>四、CSS 链接属性</strong></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">a 所有超链接</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">a:link</td>
<td align="left">超链接文字格式</td>
</tr>
<tr>
<td align="left">a:visited</td>
<td align="left">浏览过的链接文字格式</td>
</tr>
<tr>
<td align="left">a:active</td>
<td align="left">按下链接的格式</td>
</tr>
<tr>
<td align="left">a:hover</td>
<td align="left">鼠标转到链接</td>
</tr>
<tr>
<td align="left">cursor:crosshair</td>
<td align="left">十字体</td>
</tr>
<tr>
<td align="left">cursor:s-resize</td>
<td align="left">箭头朝下</td>
</tr>
<tr>
<td align="left">cursor:help</td>
<td align="left">加一问号</td>
</tr>
<tr>
<td align="left">cursor:w-resize</td>
<td align="left">箭头朝左</td>
</tr>
<tr>
<td align="left">cursor:n-resize</td>
<td align="left">箭头朝上</td>
</tr>
<tr>
<td align="left">cursor:ne-resize</td>
<td align="left">箭头朝右上</td>
</tr>
<tr>
<td align="left">cursor:nw-resize</td>
<td align="left">箭头朝左上</td>
</tr>
<tr>
<td align="left">cursor:text</td>
<td align="left">文字 I 型</td>
</tr>
<tr>
<td align="left">cursor:se-resize</td>
<td align="left">箭头斜右下</td>
</tr>
<tr>
<td align="left">cursor:sw-resize</td>
<td align="left">箭头斜左下</td>
</tr>
<tr>
<td align="left">cursor:wait</td>
<td align="left">漏斗</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><strong>五、CSS 边框属性</strong></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">border-top:1px solid #6699cc;</td>
<td align="left">上框线</td>
</tr>
<tr>
<td align="left">border-bottom:1px solid #6699cc;</td>
<td align="left">下框线</td>
</tr>
<tr>
<td align="left">border-left:1px solid #6699cc;</td>
<td align="left">左框线</td>
</tr>
<tr>
<td align="left">border-right:1px solid #6699cc;</td>
<td align="left">右框线</td>
</tr>
<tr>
<td align="left">solid</td>
<td align="left">实线框 2+6010</td>
</tr>
<tr>
<td align="left">47dotted</td>
<td align="left">虚线框</td>
</tr>
<tr>
<td align="left">double</td>
<td align="left">双线框</td>
</tr>
<tr>
<td align="left">groove</td>
<td align="left">立体内凸框</td>
</tr>
<tr>
<td align="left">ridge</td>
<td align="left">立体浮雕框</td>
</tr>
<tr>
<td align="left">inset</td>
<td align="left">凹框</td>
</tr>
<tr>
<td align="left">outset</td>
<td align="left">凸框</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><strong>六、CSS 表单</strong></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">&#96;&#96;</td>
<td align="left">文本域</td>
</tr>
<tr>
<td align="left">&#96;&#96;</td>
<td align="left">按钮</td>
</tr>
<tr>
<td align="left">&#96;&#96;</td>
<td align="left">复选框</td>
</tr>
<tr>
<td align="left">&#96;&#96;</td>
<td align="left">单选按钮</td>
</tr>
<tr>
<td align="left"><code>选项1</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left">列表菜单</td>
</tr>
<tr>
<td align="left">&#96;&#96;</td>
<td align="left">多行文本域</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><strong>七、CSS 边界样式</strong></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">margin-top:10px;</td>
<td align="left">上边界</td>
</tr>
<tr>
<td align="left">margin-right:10px;</td>
<td align="left">右边界值</td>
</tr>
<tr>
<td align="left">margin-bottom:10px;</td>
<td align="left">下边界值</td>
</tr>
<tr>
<td align="left">margin-left:10px;</td>
<td align="left">左边界值</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><strong>八、CSS 边框空白</strong></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">padding-top:10px;</td>
<td align="left">上边框留空白</td>
</tr>
<tr>
<td align="left">padding-right:10px;</td>
<td align="left">右边框留空白</td>
</tr>
<tr>
<td align="left">padding-bottom:10px;</td>
<td align="left">下边框留空白</td>
</tr>
<tr>
<td align="left">padding-left:10px;</td>
<td align="left">左边框留空白</td>
</tr>
</tbody></table>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/02/24/html+css+js+ts/2-css-%E5%9F%BA%E7%A1%80%EF%BC%881%EF%BC%89/" data-id="cl7k9sbgo008a98u0fji57k7x" data-title="css-基础（1）" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/css/" rel="tag">css</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-html+css+js+ts/2-css-标准盒子模型和IE盒子模型" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/02/21/html+css+js+ts/2-css-%E6%A0%87%E5%87%86%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B%E5%92%8CIE%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/" class="article-date">
  <time class="dt-published" datetime="2018-02-21T10:32:12.000Z" itemprop="datePublished">2018-02-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/02/21/html+css+js+ts/2-css-%E6%A0%87%E5%87%86%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B%E5%92%8CIE%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/">标准盒子模型和IE盒子模型</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="标准准盒子模型"><a href="#标准准盒子模型" class="headerlink" title="标准准盒子模型"></a>标准准盒子模型</h3><ul>
<li>盒子模型是css中一个重要的概念，理解了盒子模型才能更好的排版。其实盒子模型有两种，分别是 ie 盒子模型和标准 w3c 盒子模型。他们对盒子模型的解释各不相同，先来看看我们熟知的标准盒子模型</li>
</ul>
<p><img src="http://images.cnblogs.com/cnblogs_com/cchyao/%E6%A0%87%E5%87%86W3C%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B%E5%92%8CIE%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8BCSS%E5%B8%83%E5%B1%80%E7%BB%8F%E5%85%B8%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/1.JPG" alt="img"></p>
<ul>
<li>从上图可以看到标准 <code>w3c</code> 盒子模型的范围包括 <code>margin</code>、<code>border</code>、<code>padding</code>、<code>content</code>，并且 <code>content</code>部分不包含其他部分</li>
</ul>
<hr>
<h3 id="IE盒子模型"><a href="#IE盒子模型" class="headerlink" title="IE盒子模型"></a>IE盒子模型</h3><p><img src="http://images.cnblogs.com/cnblogs_com/cchyao/%E6%A0%87%E5%87%86W3C%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B%E5%92%8CIE%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8BCSS%E5%B8%83%E5%B1%80%E7%BB%8F%E5%85%B8%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/2.JPG" alt="img"></p>
<ul>
<li>从上图可以看到 <code>ie</code>盒子模型的范围也包括 <code>margin</code>、<code>border</code>、<code>padding</code>、<code>content</code></li>
<li>和标准 <code>w3c</code> 盒子模型不同的是：<code>ie</code> 盒子模型的 <code>content</code> 部分包含了 <code>border</code>和 <code>padding</code></li>
<li><code>IE</code>盒子模型<code>width</code> &#x3D; <code>padding</code>+<code>border</code>+<code>内容</code></li>
<li>标准盒子模型 &#x3D; 内容的宽度（不包含<code>border</code>+<code>padding</code>）</li>
<li>例：</li>
<li>一个盒子的 <code>margin</code>为 20px，<code>border</code> 为 1px，<code>padding</code>为 10px，<code>content</code> 的宽为 200px、高为 50px，假如用标准 <code>w3c</code> 盒子模型解释，那么这个盒子需要占据的位置为：宽 <code>20*2+1*2+10*2+200=262px</code>、高 <code>20*2+1*2*10*2+50=112px</code>，盒子的实际大小为：宽 <code>1*2+10*2+200=222px</code>、高 <code>1*2+10*2+50=72px</code>；假如用ie 盒子模型，那么这个盒子需要占据的位置为：宽 <code>20*2+200=240px</code>、高 <code>20*2+50=70px</code>，盒子的实际大小为：宽 <code>200px</code>、高 <code>50px</code></li>
<li>那应该选择哪中盒子模型呢？当然是“标准 <code>w3c</code> 盒子模型”了。怎么样才算是选择了“标准 <code>w3c</code>盒子模型”呢？很简单，就是在网页的顶部加上 <code>doctype</code> 声明。</li>
<li>假如不加<code>doctype</code> 声明，那么各个浏览器会根据自己的行为去理解网页，即 <code>ie</code>浏览器会采用 <code>ie</code> 盒子模型去解释你的盒子，而 <code>ff</code>会采用标准 w3c 盒子模型解释你的盒子，所以网页在不同的浏览器中就显示的不一样了。</li>
<li>反之，假如加上了 doctype 声明，那么所有浏览器都会采用标准 <code>w3c</code>盒子模型去解释你的盒子，网页就能在各个浏览器中显示一致了。</li>
</ul>
<hr>
<ul>
<li>再用 jquery 做的例子来证实一下</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;你用的盒子模型是？&lt;/title&gt;</span><br><span class="line">&lt;script language=&quot;javascript&quot; src=&quot;jquery.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script language=&quot;javascript&quot;&gt;</span><br><span class="line">var sbox = $.boxmodel ? &quot;标准w3c&quot;:&quot;ie&quot;;</span><br><span class="line">document.write(&quot;您的页面目前支持：&quot;+sbox+&quot;盒子模型&quot;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>　上面的代码没有加上 <code>doctype</code> 声明，在 <code>ie</code> 浏览器中显示 <code>ie</code>盒子模型，在 ff 浏览器中显示“标准<code>w3c</code> 盒子模型”。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;!doctype html public &quot;-//w3c//dtd xhtml 1.0 transitional//en&quot; &quot;http://www.w3.org/tr/xhtml1/dtd/xhtml1-transitional.dtd&quot;&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;你用的盒子模型是标准w3c盒子模型&lt;/title&gt;</span><br><span class="line">&lt;script language=&quot;javascript&quot; src=&quot;jquery.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script language=&quot;javascript&quot;&gt;</span><br><span class="line">var sbox = $.boxmodel ? &quot;标准w3c&quot;:&quot;ie&quot;;</span><br><span class="line">document.write(&quot;您的页面目前支持：&quot;+sbox+&quot;盒子模型&quot;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>　代码2 与代码1 唯一的不同的就是顶部加了 <code>doctype</code>声明。在所有浏览器中都显示“标准 <code>w3c</code>盒子模型”</li>
<li>所以为了让网页能兼容各个浏览器，让我们用标准 <code>w3c</code> 盒子模型</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/02/21/html+css+js+ts/2-css-%E6%A0%87%E5%87%86%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B%E5%92%8CIE%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/" data-id="cl7k9sbgq008i98u0b1wu84j6" data-title="标准盒子模型和IE盒子模型" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/css/" rel="tag">css</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-html+css+js+ts/2-css BFC" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/02/20/html+css+js+ts/2-css%20BFC/" class="article-date">
  <time class="dt-published" datetime="2018-02-20T06:32:17.000Z" itemprop="datePublished">2018-02-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/02/20/html+css+js+ts/2-css%20BFC/">css-BFC</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="BFC-是什么？"><a href="#BFC-是什么？" class="headerlink" title="BFC 是什么？"></a>BFC 是什么？</h3><ul>
<li><code>BFC</code> (<code>Block Formatting Contexts</code>) 即块级格式化上下文，从样式上看，它与普通的容器没有什么区别，但是从功能上，<code>BFC</code> 可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 <code>BFC</code>具有普通容器没有的一些特性，例如可以包含浮动元素，使到它可以包含浮动元素，从而防止出现高度塌陷的问题</li>
</ul>
<hr>
<h3 id="如何触发-BFC"><a href="#如何触发-BFC" class="headerlink" title="如何触发 BFC"></a>如何触发 BFC</h3><ul>
<li><p>触发 BFC 的条件</p>
<ul>
<li><p>浮动元素，<code>float</code> 除 <code>none</code> 以外的值</p>
</li>
<li><p>绝对定位元素，<code>position</code>（<code>absolute</code>，<code>fixed</code>）</p>
</li>
<li><p><code>display</code> 为以下其中之一的值 <code>inline-blocks</code>，<code>table-cells</code>，<code>table-captions</code></p>
</li>
<li><p><code>overflow</code> 除了 <code>visible</code> 以外的值（<code>hidden</code>，<code>auto</code>，<code>scroll</code>）</p>
</li>
<li><p>在CSS3中，BFC叫做Flow Root，并增加了一些触发条件：</p>
<ul>
<li><code>display</code> 的 <code>table-caption</code> 值</li>
</ul>
</li>
</ul>
</li>
<li><p><code>position</code> 的 <code>fixed</code> 值，其实 <code>fixed</code> 是 <code>absolute</code> 的一个子类，因此在 <code>CSS2.1</code> 中使用这个值也会触发 <code>BFC</code> ，只是在<code>CSS3</code> 中更加明确了这一点</p>
</li>
</ul>
<hr>
<h3 id="BFC布局规则"><a href="#BFC布局规则" class="headerlink" title="BFC布局规则"></a>BFC布局规则</h3><ul>
<li>内部的<code>Box</code>会在垂直方向，一个接一个地放置。</li>
<li><code>Box</code>垂直方向的距离由<code>margin</code>决定。属于同一个<code>BFC</code>的两个相邻<code>Box</code>的<code>margin</code>会发生重叠</li>
<li>每个元素的<code>margin box</code>的左边， 与包含块<code>border box</code>的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如 此。</li>
<li><code>BFC</code>的区域不会与<code>float box</code>重叠。</li>
<li><code>BFC</code>就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。</li>
<li>计算<code>BFC</code>的高度时，浮动元素也参与计算</li>
</ul>
<hr>
<h3 id="BFC的作用及原理"><a href="#BFC的作用及原理" class="headerlink" title="BFC的作用及原理"></a>BFC的作用及原理</h3><ul>
<li><strong>自适应两栏布局</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">       width: 300px;</span><br><span class="line">       position: relative;</span><br><span class="line">   &#125;</span><br><span class="line">   .aside &#123;</span><br><span class="line">       width: 100px;</span><br><span class="line">       height: 150px;</span><br><span class="line">       float: left;</span><br><span class="line">       background: #f66;</span><br><span class="line">   &#125;</span><br><span class="line">   .main &#123;</span><br><span class="line">       height: 200px;</span><br><span class="line">       background: #fcc;</span><br><span class="line">   &#125;</span><br><span class="line"> &lt;body&gt;</span><br><span class="line">       &lt;div class=&quot;aside&quot;&gt;&lt;/div&gt;</span><br><span class="line">       &lt;div class=&quot;main&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>

<p><img src="http://p1.qhimg.com/d/inn/4055c62a/4dca44a927d4c1ffc30e3ae5f53a0b79.png" alt="img"></p>
<ul>
<li>根据BFC布局规则第3条：<ul>
<li>每个元素的<code>margin box</code>的左边， 与包含块<code>border box</code>的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。</li>
</ul>
</li>
<li>因此，虽然存在浮动的元素<code>aslide</code>，但<code>main</code>的左边依然会与包含块的左边相接触</li>
<li>根据<code>BFC</code>布局规则第四条：<ul>
<li><code>BFC</code>的区域不会与<code>float box</code>重叠</li>
</ul>
</li>
<li>我们可以通过通过触发<code>main</code>生成<code>BFC</code>， 来实现自适应两栏布局</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.main &#123;</span><br><span class="line">    overflow: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>当触发<code>main</code>生成<code>BFC</code>后，这个新的<code>BFC</code>不会与浮动的<code>aside</code>重叠。因此会根据包含块的宽度，和<code>aside</code>的宽度，自动变窄。效果如下：</li>
</ul>
<p><img src="http://p6.qhimg.com/t01077886a9706cb26b.png" alt="img"></p>
<ul>
<li><strong>清除内部浮动</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">.par &#123;</span><br><span class="line">    border: 5px solid #fcc;</span><br><span class="line">    width: 300px;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">.child &#123;</span><br><span class="line">    border: 5px solid #f66;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    float: left;</span><br><span class="line">&#125;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class=&quot;par&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;child&quot;&gt;&lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;child&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>

<p><img src="http://p1.qhimg.com/t016035b58195e7909a.png" alt="img"></p>
<ul>
<li><p>根据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BFC</span><br></pre></td></tr></table></figure>

<p>布局规则第六条：</p>
<ul>
<li>计算<code>BFC</code>的高度时，浮动元素也参与计算</li>
</ul>
</li>
<li><p>为达到清除内部浮动，我们可以触发<code>par</code>生成<code>BFC</code>，那么<code>par</code>在计算高度时，<code>par</code>内部的浮动元素<code>child</code>也会参与计算</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.par &#123;</span><br><span class="line">    overflow: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://p2.qhimg.com/t016bbbe5236ef1ffd5.png" alt="img"></p>
<ul>
<li><strong>防止垂直 margin 重叠</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">p &#123;</span><br><span class="line">    color: #f55;</span><br><span class="line">    background: #fcc;</span><br><span class="line">    width: 200px;</span><br><span class="line">    line-height: 100px;</span><br><span class="line">    text-align: center;</span><br><span class="line">    margin: 100px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;p&gt;Haha&lt;/p&gt;</span><br><span class="line">&lt;p&gt;Hehe&lt;/p&gt;</span><br></pre></td></tr></table></figure>

<p><img src="http://p5.qhimg.com/t01b47b8b7d153c07cc.png" alt="img"></p>
<ul>
<li>两个<code>p</code>之间的距离为<code>100px</code>，发送了<code>margin</code>重叠</li>
<li>根据BFC布局规则第二条：<ul>
<li><code>Box</code>垂直方向的距离由<code>margin</code>决定。属于同一个<code>BFC</code>的两个相邻Box的<code>margin</code>会发生重叠</li>
</ul>
</li>
<li>我们可以在<code>p</code>外面包裹一层容器，并触发该容器生成一个<code>BFC</code>。那么两个<code>P</code>便不属于同一个<code>BFC</code>，就不会发生<code>margin</code>重叠了</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">.wrap &#123;</span><br><span class="line">    overflow: hidden;</span><br><span class="line">&#125;</span><br><span class="line">p &#123;</span><br><span class="line">    color: #f55;</span><br><span class="line">    background: #fcc;</span><br><span class="line">    width: 200px;</span><br><span class="line">    line-height: 100px;</span><br><span class="line">    text-align: center;</span><br><span class="line">    margin: 100px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;p&gt;Haha&lt;/p&gt;</span><br><span class="line">&lt;div class=&quot;wrap&quot;&gt;</span><br><span class="line">    &lt;p&gt;Hehe&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p><img src="http://p3.qhimg.com/t0118d1d2badbb00521.png" alt="img"></p>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><p>其实以上的几个例子都体现了</p>
<p>布局规则第五条</p>
<ul>
<li><code>BFC</code>就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此</li>
</ul>
</li>
<li><p>因为<code>BFC</code>内部的元素和外部的元素绝对不会互相影响，因此， 当<code>BFC</code>外部存在浮动时，它不应该影响<code>BFC</code>内部<code>Box</code>的布局，<code>BFC</code>会通过变窄，而不与浮动有重叠。同样的，当<code>BFC</code>内部有浮动时，为了不影响外部元素的布局，<code>BFC</code>计算高度时会包括浮动的高度。避免<code>margin</code>重叠也是这样的一个道理</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/02/20/html+css+js+ts/2-css%20BFC/" data-id="cl7k9sbgo008698u0g466cvy6" data-title="css-BFC" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/css/" rel="tag">css</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-html+css+js+ts/3-js虚拟DOM进阶" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/02/19/html+css+js+ts/3-js%E8%99%9A%E6%8B%9FDOM%E8%BF%9B%E9%98%B6/" class="article-date">
  <time class="dt-published" datetime="2018-02-19T01:16:46.000Z" itemprop="datePublished">2018-02-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/02/19/html+css+js+ts/3-js%E8%99%9A%E6%8B%9FDOM%E8%BF%9B%E9%98%B6/">js DOM进阶</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="一、为什么需要虚拟DOM"><a href="#一、为什么需要虚拟DOM" class="headerlink" title="一、为什么需要虚拟DOM"></a>一、为什么需要虚拟DOM</h2><blockquote>
<p>先介绍浏览器加载一个<code>HTML</code>文件需要做哪些事，帮助我们理解为什么我们需要虚拟<code>DOM</code>。<code>webkit</code>引擎的处理流程</p>
</blockquote>
<blockquote>
<p>所有浏览器的引擎工作流程都差不多，如上图大致分5步：创建<code>DOM tree</code> –&gt; 创建<code>Style Rules</code> -&gt; 构建<code>Render tree</code> -&gt; 布局<code>Layout</code> –&gt; 绘制<code>Painting</code></p>
</blockquote>
<ul>
<li>第一步，用<code>HTML</code>分析器，分析<code>HTML</code>元素，构建一颗<code>DOM</code>树。</li>
<li>第二步：用<code>CSS</code>分析器，分析<code>CSS</code>文件和元素上的<code>inline</code>样式，生成页面的样式表。</li>
<li>第三步：将上面的<code>DOM</code>树和样式表，关联起来，构建一颗<code>Render</code>树。这一过程又称为<code>Attachment</code>。每个<code>DOM</code>节点都有<code>attach</code>方法，接受样式信息，返回一个<code>render</code>对象（又名<code>renderer</code>）。这些<code>render</code>对象最终会被构建成一颗<code>Render</code>树。</li>
<li>第四步：有了<code>Render</code>树后，浏览器开始布局，会为每个<code>Render</code>树上的节点确定一个在显示屏上出现的精确坐标值。</li>
<li>第五步：<code>Render</code>数有了，节点显示的位置坐标也有了，最后就是调用每个节点的<code>paint</code>方法，让它们显示出来。</li>
</ul>
<blockquote>
<p>当你用传统的源生<code>api</code>或<code>jQuery</code>去操作<code>DOM</code>时，浏览器会从构建<code>DOM</code>树开始从头到尾执行一遍流程。比如当你在一次操作时，需要更新<code>10</code>个<code>DOM</code>节点，理想状态是一次性构建完<code>DOM</code>树，再执行后续操作。但浏览器没这么智能，收到第一个更新<code>DOM</code>请求后，并不知道后续还有9次更新操作，因此会马上执行流程，最终执行10次流程。显然例如计算<code>DOM</code>节点的坐标值等都是白白浪费性能，可能这次计算完，紧接着的下一个<code>DOM</code>更新请求，这个节点的坐标值就变了，前面的一次计算是无用功。</p>
</blockquote>
<ul>
<li>即使计算机硬件一直在更新迭代，操作<code>DOM</code>的代价仍旧是昂贵的，频繁操作还是会出现页面卡顿，影响用户的体验。真实的<code>DOM</code>节点，哪怕一个最简单的div也包含着很多属性，可以打印出来直观感受一下</li>
</ul>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/606.png" alt="img"></p>
<blockquote>
<p>虚拟<code>DOM</code>就是为了解决这个浏览器性能问题而被设计出来的。例如前面的例子，假如一次操作中有<code>10</code>次更新<code>DOM</code>的动作，虚拟<code>DOM</code>不会立即操作<code>DOM</code>，而是将这<code>10</code>次更新的<code>diff</code>内容保存到本地的一个<code>js</code>对象中，最终将这个js对象一次性<code>attach</code>到<code>DOM</code>树上，通知浏览器去执行绘制工作，这样可以避免大量的无谓的计算量</p>
</blockquote>
<h2 id="二、实现虚拟DOM"><a href="#二、实现虚拟DOM" class="headerlink" title="二、实现虚拟DOM"></a>二、实现虚拟DOM</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;real-container&quot;&gt;</span><br><span class="line">    &lt;p&gt;Real DOM&lt;/p&gt;</span><br><span class="line">    &lt;div&gt;cannot update&lt;/div&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">        &lt;li className=&quot;item&quot;&gt;Item 1&lt;/li&gt;</span><br><span class="line">        &lt;li className=&quot;item&quot;&gt;Item 2&lt;/li&gt;</span><br><span class="line">        &lt;li className=&quot;item&quot;&gt;Item 3&lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>用<code>js</code>对象来模拟<code>DOM</code>节点如下</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const tree = Element(&#x27;div&#x27;, &#123; id: &#x27;virtual-container&#x27; &#125;, [</span><br><span class="line">    Element(&#x27;p&#x27;, &#123;&#125;, [&#x27;Virtual DOM&#x27;]),</span><br><span class="line">    Element(&#x27;div&#x27;, &#123;&#125;, [&#x27;before update&#x27;]),</span><br><span class="line">    Element(&#x27;ul&#x27;, &#123;&#125;, [</span><br><span class="line">        Element(&#x27;li&#x27;, &#123; class: &#x27;item&#x27; &#125;, [&#x27;Item 1&#x27;]),</span><br><span class="line">        Element(&#x27;li&#x27;, &#123; class: &#x27;item&#x27; &#125;, [&#x27;Item 2&#x27;]),</span><br><span class="line">        Element(&#x27;li&#x27;, &#123; class: &#x27;item&#x27; &#125;, [&#x27;Item 3&#x27;]),</span><br><span class="line">    ]),</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">const root = tree.render();</span><br><span class="line">document.getElementById(&#x27;virtualDom&#x27;).appendChild(root);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>用<code>js</code>对象模拟<code>DOM</code>节点的好处是，页面的更新可以先全部反映在<code>js</code>对象上，操作内存中的<code>js</code>对象的速度显然要快多了。等更新完后，再将最终的<code>js</code>对象映射成真实的<code>DOM</code>，交由浏览器去绘制</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function Element(tagName, props, children) &#123;</span><br><span class="line">    if (!(this instanceof Element)) &#123;</span><br><span class="line">        return new Element(tagName, props, children);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    this.tagName = tagName;</span><br><span class="line">    this.props = props || &#123;&#125;;</span><br><span class="line">    this.children = children || [];</span><br><span class="line">    this.key = props ? props.key : undefined;</span><br><span class="line"></span><br><span class="line">    let count = 0;</span><br><span class="line">    this.children.forEach((child) =&gt; &#123;</span><br><span class="line">        if (child instanceof Element) &#123;</span><br><span class="line">            count += child.count;</span><br><span class="line">        &#125;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;);</span><br><span class="line">    this.count = count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>第一个参数是节点名（如<code>div</code>），第二个参数是节点的属性（如<code>class</code>），第三个参数是子节点（如<code>ul</code>的<code>li</code>）。除了这三个参数会被保存在对象上外，还保存了<code>key</code>和<code>count</code></p>
</blockquote>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/607.png" alt="img"></p>
<blockquote>
<p>有了<code>js</code>对象后，最终还需要将其映射成真实的<code>DOM</code></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Element.prototype.render = function() &#123;</span><br><span class="line">    const el = document.createElement(this.tagName);</span><br><span class="line">    const props = this.props;</span><br><span class="line"></span><br><span class="line">    for (const propName in props) &#123;</span><br><span class="line">        setAttr(el, propName, props[propName]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    this.children.forEach((child) =&gt; &#123;</span><br><span class="line">        const childEl = (child instanceof Element) ? child.render() : document.createTextNode(child);</span><br><span class="line">        el.appendChild(childEl);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    return el;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>根据<code>DOM</code>名调用源生的<code>createElement</code>创建真实<code>DOM</code>，将<code>DOM</code>的属性全都加到这个<code>DOM</code>元素上，如果有子元素继续递归调用创建子元素，并<code>appendChild</code>挂到该<code>DOM</code>元素上。这样就完成了从创建虚拟<code>DOM</code>到将其映射成真实<code>DOM</code>的全部工作</p>
</blockquote>
<h2 id="三、Diff算法"><a href="#三、Diff算法" class="headerlink" title="三、Diff算法"></a>三、Diff算法</h2><blockquote>
<p>我们已经完成了创建虚拟<code>DOM</code>并将其映射成真实<code>DOM</code>的工作，这样所有的更新都可以先反映到虚拟<code>DOM</code>上，如何反映呢？需要明确一下<code>Diff</code>算法</p>
</blockquote>
<ul>
<li>两棵树如果完全比较时间复杂度是<code>O(n^3)</code></li>
<li><code>React</code>的<code>Diff</code>算法的时间复杂度是<code>O(n)</code>。要实现这么低的时间复杂度，意味着只能平层地比较两棵树的节点，放弃了深度遍历</li>
<li>这样做，似乎牺牲了一定的精确性来换取速度，但考虑到现实中前端页面通常也不会跨层级移动<code>DOM</code>元素，所以这样做是最优的。</li>
</ul>
<p>我们新创建一棵树，用于和之前的树进行比较</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const newTree = Element(&#x27;div&#x27;, &#123; id: &#x27;virtual-container&#x27; &#125;, [</span><br><span class="line">    Element(&#x27;h3&#x27;, &#123;&#125;, [&#x27;Virtual DOM&#x27;]),                     // REPLACE</span><br><span class="line">    Element(&#x27;div&#x27;, &#123;&#125;, [&#x27;after update&#x27;]),                   // TEXT</span><br><span class="line">    Element(&#x27;ul&#x27;, &#123; class: &#x27;marginLeft10&#x27; &#125;, [              // PROPS</span><br><span class="line">        Element(&#x27;li&#x27;, &#123; class: &#x27;item&#x27; &#125;, [&#x27;Item 1&#x27;]),</span><br><span class="line">        // Element(&#x27;li&#x27;, &#123; class: &#x27;item&#x27; &#125;, [&#x27;Item 2&#x27;]),    // REORDER remove</span><br><span class="line">        Element(&#x27;li&#x27;, &#123; class: &#x27;item&#x27; &#125;, [&#x27;Item 3&#x27;]),</span><br><span class="line">    ]),</span><br><span class="line">]);</span><br></pre></td></tr></table></figure>

<p>只考虑平层地<code>Diff</code>的话，就简单多了，只需要考虑以下4种情况</p>
<blockquote>
<p>第一种是最简单的，节点类型变了，例如下图中的<code>P</code>变成了<code>h3</code>。我们将这个过程称之为<code>REPLACE</code>。直接将旧节点卸载（<code>componentWillUnmount</code>）并装载新节点（<code>componentWillMount</code>）就行了</p>
</blockquote>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/608.png" alt="img"></p>
<p>旧节点包括下面的子节点都将被卸载，如果新节点和旧节点仅仅是类型不同，但下面的所有子节点都一样时，这样做显得效率不高。但为了避免<code>O(n^3)</code>的时间复杂度，这样做是值得的。这也提醒了<code>React</code>开发者，应该避免无谓的节点类型的变化，例如运行时将<code>div</code>变成<code>p</code>就没什么太大意义</p>
<blockquote>
<p>第二种也比较简单，节点类型一样，仅仅属性或属性值变了</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">renderA: &lt;ul&gt;</span><br><span class="line">renderB: &lt;ul class: &#x27;marginLeft10&#x27;&gt;</span><br><span class="line">=&gt; [addAttribute class &quot;marginLeft10&quot;]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>我们将这个过程称之为<code>PROPS</code>。此时不会触发节点的卸载（<code>componentWillUnmount</code>）和装载（<code>componentWillMount</code>）动作。而是执行节点更新（<code>shouldComponentUpdate</code>到<code>componentDidUpdate</code>的一系列方法）</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">function diffProps(oldNode, newNode) &#123;</span><br><span class="line">    const oldProps = oldNode.props;</span><br><span class="line">    const newProps = newNode.props;</span><br><span class="line"></span><br><span class="line">    let key;</span><br><span class="line">    const propsPatches = &#123;&#125;;</span><br><span class="line">    let isSame = true;</span><br><span class="line"></span><br><span class="line">    // find out different props</span><br><span class="line">    for (key in oldProps) &#123;</span><br><span class="line">        if (newProps[key] !== oldProps[key]) &#123;</span><br><span class="line">            isSame = false;</span><br><span class="line">            propsPatches[key] = newProps[key];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // find out new props</span><br><span class="line">    for (key in newProps) &#123;</span><br><span class="line">        if (!oldProps.hasOwnProperty(key)) &#123;</span><br><span class="line">            isSame = false;</span><br><span class="line">            propsPatches[key] = newProps[key];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return isSame ? null : propsPatches;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>第三种是文本变了，文本对也是一个<code>Text Node</code>，也比较简单，直接修改文字内容就行了，我们将这个过程称之为<code>TEXT</code></li>
<li>第四种是移动，增加，删除子节点，我们将这个过程称之为<code>REORDER</code></li>
</ul>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/609.png" alt="img"></p>
<blockquote>
<p>在中间插入一个节点，程序员写代码很简单：$(B).after(F)。但如何高效地插入呢？简单粗暴的做法是：卸载C，装载F，卸载D，装载C，卸载E，装载D，装载E。如下图</p>
</blockquote>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/610.png" alt="img"></p>
<blockquote>
<p>我们写<code>JSX</code>代码时，如果没有给数组或枚举类型定义一个<code>key</code>，就会看到下面这样的<code>warning</code>。<code>React</code>提醒我们，没有<code>key</code>的话，涉及到移动，增加，删除子节点的操作时，就会用上面那种简单粗暴的做法来更新。虽然程序运行不会有错，但效率太低，因此<code>React</code>会给我们一个<code>warning</code></p>
</blockquote>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/611.png" alt="img"></p>
<blockquote>
<p>如果我们在<code>JSX</code>里为数组或枚举型元素增加上<code>key</code>后，<code>React</code>就能根据<code>key</code>，直接找到具体的位置进行操作，效率比较高。如下图</p>
</blockquote>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/612.png" alt="img"></p>
<blockquote>
<p>常见的最小编辑距离问题，可以用<code>Levenshtein Distance</code>算法来实现，时间复杂度是<code>O(M*N)</code>，但通常我们只要一些简单的移动就能满足需要，降低点精确性，将时间复杂度降低到<code>O(max(M, N)</code>即可</p>
</blockquote>
<p>最终<code>Diff</code>出来的结果如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    1: [ &#123;type: REPLACE, node: Element&#125; ],</span><br><span class="line">    4: [ &#123;type: TEXT, content: &quot;after update&quot;&#125; ],</span><br><span class="line">    5: [ &#123;type: PROPS, props: &#123;class: &quot;marginLeft10&quot;&#125;&#125;, &#123;type: REORDER, moves: [&#123;index: 2, type: 0&#125;]&#125; ],</span><br><span class="line">    6: [ &#123;type: REORDER, moves: [&#123;index: 2, type: 0&#125;]&#125; ],</span><br><span class="line">    8: [ &#123;type: REORDER, moves: [&#123;index: 2, type: 0&#125;]&#125; ],</span><br><span class="line">    9: [ &#123;type: TEXT, content: &quot;Item 3&quot;&#125; ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四、映射成真实DOM"><a href="#四、映射成真实DOM" class="headerlink" title="四、映射成真实DOM"></a>四、映射成真实DOM</h2><blockquote>
<p>虚拟<code>DOM</code>有了，<code>Diff</code>也有了，现在就可以将<code>Diff</code>应用到真实<code>DOM</code>上了</p>
</blockquote>
<p>深度遍历DOM将Diff的内容更新进去</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function dfsWalk(node, walker, patches) &#123;</span><br><span class="line">    const currentPatches = patches[walker.index];</span><br><span class="line"></span><br><span class="line">    const len = node.childNodes ? node.childNodes.length : 0;</span><br><span class="line">    for (let i = 0; i &lt; len; i++) &#123;</span><br><span class="line">        walker.index++;</span><br><span class="line">        dfsWalk(node.childNodes[i], walker, patches);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (currentPatches) &#123;</span><br><span class="line">        applyPatches(node, currentPatches);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>具体更新的代码如下，其实就是根据<code>Diff</code>信息调用源生<code>API</code>操作<code>DOM</code></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">function applyPatches(node, currentPatches) &#123;</span><br><span class="line">    currentPatches.forEach((currentPatch) =&gt; &#123;</span><br><span class="line">        switch (currentPatch.type) &#123;</span><br><span class="line">            case REPLACE: &#123;</span><br><span class="line">                const newNode = (typeof currentPatch.node === &#x27;string&#x27;)</span><br><span class="line">                    ? document.createTextNode(currentPatch.node)</span><br><span class="line">                    : currentPatch.node.render();</span><br><span class="line">                node.parentNode.replaceChild(newNode, node);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            case REORDER:</span><br><span class="line">                reorderChildren(node, currentPatch.moves);</span><br><span class="line">                break;</span><br><span class="line">            case PROPS:</span><br><span class="line">                setProps(node, currentPatch.props);</span><br><span class="line">                break;</span><br><span class="line">            case TEXT:</span><br><span class="line">                if (node.textContent) &#123;</span><br><span class="line">                    node.textContent = currentPatch.content;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    // ie</span><br><span class="line">                    node.nodeValue = currentPatch.content;</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            default:</span><br><span class="line">                throw new Error(`Unknown patch type $&#123;currentPatch.type&#125;`);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>虚拟<code>DOM</code>的目的是将所有操作累加起来，统计计算出所有的变化后，统一更新一次<code>DOM</code></p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/02/19/html+css+js+ts/3-js%E8%99%9A%E6%8B%9FDOM%E8%BF%9B%E9%98%B6/" data-id="cl7k9sbhk00bi98u04am0b5w4" data-title="js DOM进阶" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/" rel="tag">javascript</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-html+css+js+ts/3-js虚拟DOM基础" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/02/17/html+css+js+ts/3-js%E8%99%9A%E6%8B%9FDOM%E5%9F%BA%E7%A1%80/" class="article-date">
  <time class="dt-published" datetime="2018-02-17T07:26:51.000Z" itemprop="datePublished">2018-02-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/02/17/html+css+js+ts/3-js%E8%99%9A%E6%8B%9FDOM%E5%9F%BA%E7%A1%80/">js DOM基础</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="一、什么是-vdom"><a href="#一、什么是-vdom" class="headerlink" title="一、什么是 vdom"></a>一、什么是 vdom</h2><ul>
<li>用 <code>JS</code> 模拟 <code>DOM</code> 结构</li>
<li><code>DOM</code> 变化的对比，放在 <code>JS</code> 层来做</li>
<li>提高重绘性能</li>
</ul>
<h2 id="二、设计一个需求场景"><a href="#二、设计一个需求场景" class="headerlink" title="二、设计一个需求场景"></a>二、设计一个需求场景</h2><p><img src="https://poetries1.gitee.io/img-repo/2019/10/587.png" alt="img"></p>
<p><strong>用jQuery实现</strong></p>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/588.png" alt="img"><br><img src="https://poetries1.gitee.io/img-repo/2019/10/589.png" alt="img"><br><img src="https://poetries1.gitee.io/img-repo/2019/10/590.png" alt="img"></p>
<p><strong>遇到的问题</strong></p>
<ul>
<li>DOM 操作是“昂贵”的，js 运行效率高</li>
<li>尽量减少 DOM 操作，而不是“推倒重来”</li>
<li>项目越复杂，影响就越严重</li>
<li>vdom 即可解决这个问题</li>
</ul>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/591.png" alt="img"></p>
<h2 id="三、vdom-的如何应用，核心-API-是什么"><a href="#三、vdom-的如何应用，核心-API-是什么" class="headerlink" title="三、vdom 的如何应用，核心 API 是什么"></a>三、vdom 的如何应用，核心 API 是什么</h2><p><strong>什么是 vdom</strong></p>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/592.png" alt="img"></p>
<p><strong>介绍 snabbdom</strong></p>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/593.png" alt="img"><br><img src="https://poetries1.gitee.io/img-repo/2019/10/594.png" alt="img"></p>
<p><strong>介绍 snabbdom - h 函数</strong></p>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/595.png" alt="img"></p>
<p><strong>介绍 snabbdom - patch 函数</strong></p>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/596.png" alt="img"></p>
<p><strong>重做jQuery的demo</strong></p>
<ul>
<li>使用 <code>data</code>生成 <code>vnode</code></li>
<li>第一次渲染，将 <code>vnode</code> 渲染到 <code>#container</code>中</li>
<li>并将 <code>vnode</code> 缓存下来</li>
<li>修改 <code>data</code> 之后，用新 <code>data</code> 生成 <code>newVnode</code></li>
<li>将 <code>vnode</code> 和 <code>newVnode</code> 对比</li>
</ul>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/597.png" alt="img"></p>
<p><strong>核心 API</strong></p>
<ul>
<li><code>h(‘&lt;标签名&gt;’, &#123;…属性…&#125;, […子元素…])</code></li>
<li><code>h(‘&lt;标签名&gt;’, &#123;…属性…&#125;, ‘….’)</code></li>
<li><code>patch(container, vnode)</code></li>
<li><code>patch(vnode, newVnode)</code></li>
</ul>
<h2 id="四、介绍一下-diff-算法"><a href="#四、介绍一下-diff-算法" class="headerlink" title="四、介绍一下 diff 算法"></a>四、介绍一下 diff 算法</h2><h3 id="4-1-vdom-为何使用-diff-算法"><a href="#4-1-vdom-为何使用-diff-算法" class="headerlink" title="4.1 vdom 为何使用 diff 算法"></a>4.1 vdom 为何使用 diff 算法</h3><ul>
<li>DOM 操作是“昂贵”的，因此尽量减少 DOM 操作</li>
<li>找出本次 DOM 必须更新的节点来更新，其他的不更新</li>
<li>这个“找出”的过程，就需要 diff 算法</li>
</ul>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/598.png" alt="img"></p>
<p><strong>patch(container, vnode)</strong></p>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/599.png" alt="img"><br><img src="https://poetries1.gitee.io/img-repo/2019/10/600.png" alt="img"></p>
<p><strong>演示过程</strong></p>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/601.png" alt="img"><br><img src="https://poetries1.gitee.io/img-repo/2019/10/602.png" alt="img"><br><img src="https://poetries1.gitee.io/img-repo/2019/10/603.png" alt="img"><br><img src="https://poetries1.gitee.io/img-repo/2019/10/604.png" alt="img"></p>
<h3 id="4-2-diff-实现过程"><a href="#4-2-diff-实现过程" class="headerlink" title="4.2 diff 实现过程"></a>4.2 diff 实现过程</h3><ul>
<li><code>patch(container, vnode)</code> 和 <code>patch(vnode, newVnode)</code></li>
<li><code>createElment</code></li>
<li><code>updateChildren</code></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/02/17/html+css+js+ts/3-js%E8%99%9A%E6%8B%9FDOM%E5%9F%BA%E7%A1%80/" data-id="cl7k9sbhi00bf98u079fr5w3y" data-title="js DOM基础" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/" rel="tag">javascript</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-html+css+js+ts/3-js数据常用操作方法" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/02/15/html+css+js+ts/3-js%E6%95%B0%E6%8D%AE%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95/" class="article-date">
  <time class="dt-published" datetime="2018-02-15T03:19:43.000Z" itemprop="datePublished">2018-02-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/02/15/html+css+js+ts/3-js%E6%95%B0%E6%8D%AE%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95/">js 常用操作</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="一、由map、filter、reduce、find展开"><a href="#一、由map、filter、reduce、find展开" class="headerlink" title="一、由map、filter、reduce、find展开"></a>一、由map、filter、reduce、find展开</h2><p><strong>filter</strong></p>
<blockquote>
<p>filter方法可以筛除数组和类似结构中不满足条件的元素，并返回满足条件的元素组成的数组。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const integers = [1, 2, 3, 4, 6, 7];</span><br><span class="line">const evenIntegers = integers.filter(i =&gt; i%2 === 0);</span><br><span class="line">// evenIntegers的值为[2, 4, 6]</span><br></pre></td></tr></table></figure>

<p><strong>find</strong></p>
<blockquote>
<p>find返回数组或类似结构中满足条件的第一个元素</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const posts = [</span><br><span class="line">  &#123;id: 1, title: &#x27;Title 1&#x27;&#125;,</span><br><span class="line">  &#123;id: 2, title: &#x27;Title 2&#x27;&#125;</span><br><span class="line">];</span><br><span class="line">// 找出id为1的posts</span><br><span class="line">const title = posts.find(p =&gt; p.id === 1).title;</span><br></pre></td></tr></table></figure>

<p><strong>map</strong></p>
<blockquote>
<p>map方法的作用在于处理流式数据，比如数组。我们可以把它想象成所有元素都要经过的一个转换器。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const integers = [1, 2, 3, 4, 6, 7];</span><br><span class="line">const twoXIntegers = integers.map(i =&gt; i*2);</span><br><span class="line">// twoXIntegers现在是 [2, 4, 6, 8, 12, 14]，而integers不发生变化。</span><br></pre></td></tr></table></figure>

<p><strong>reduce</strong></p>
<blockquote>
<p>当你想要将多个数据放进一个实例中时，你可以使用一个reducer</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const posts = [</span><br><span class="line">  &#123;id: 1, upVotes: 2&#125;,</span><br><span class="line">  &#123;id: 2, upVotes: 89&#125;,</span><br><span class="line">  &#123;id: 3, upVotes: 1&#125;</span><br><span class="line">];</span><br><span class="line">const totalUpvotes = posts.reduce((totalUpvotes, currentPost) =&gt;     </span><br><span class="line">  totalUpvotes + currentPost.upVotes, //reducer函数</span><br><span class="line">  0 // 初始化投票数为0</span><br><span class="line">);</span><br><span class="line">console.log(totalUpvotes)//输出投票总数：92</span><br></pre></td></tr></table></figure>

<ul>
<li>传给<code>reduce</code>的第一个参数函数还可以增加2个参数：</li>
<li>第三个参数：每个元素在原数据结构中的位置，比如数组下标。</li>
<li>第四个参数：调用reduce方法的数据集合，比如例子中的posts</li>
</ul>
<p><strong>some</strong></p>
<blockquote>
<p>some找到数组中符合条件的一项就不会在找，类似于<code>find</code>只找第一项</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1,2,3,4,5].some(v=&gt;v&gt;4) // true 符合有某一项满足条件</span><br></pre></td></tr></table></figure>

<p><strong>every</strong></p>
<blockquote>
<p><code>every</code>数组中每个条件都为真才会返回真</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1,2,3,4,5].every(v=&gt;v&gt;1) // false 数组中每一项都大于1才会返回true</span><br></pre></td></tr></table></figure>

<h2 id="二、向对象数组添加新元素"><a href="#二、向对象数组添加新元素" class="headerlink" title="二、向对象数组添加新元素"></a>二、向对象数组添加新元素</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const books = [];</span><br><span class="line">const newBook = &#123;title: &#x27;Alice in wonderland&#x27;, id: 1&#125;;</span><br><span class="line">const updatedBooks = [...books, newBook];</span><br><span class="line">//updatedBooks的值为[&#123;title: &#x27;Alice in wonderland&#x27;, id: 1&#125;]</span><br></pre></td></tr></table></figure>

<h2 id="三、为一个数组创建视图"><a href="#三、为一个数组创建视图" class="headerlink" title="三、为一个数组创建视图"></a>三、为一个数组创建视图</h2><blockquote>
<p>如果需要实现用户从购物车中删除物品，但是又不想破坏原来的购物车列表，可以使用filter方法</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const myId = 6;</span><br><span class="line">const userIds = [1, 5, 7, 3, 6];</span><br><span class="line">const allButMe = userIds.filter(id =&gt; id !== myId);</span><br><span class="line">// allButMe is [1, 5, 7, 3]</span><br></pre></td></tr></table></figure>

<h2 id="四、向数组中新增元素"><a href="#四、向数组中新增元素" class="headerlink" title="四、向数组中新增元素"></a>四、向数组中新增元素</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const books = [&#x27;Positioning by Trout&#x27;, &#x27;War by Green&#x27;];</span><br><span class="line">const newBooks = [...books, &#x27;HWFIF by Carnegie&#x27;];</span><br><span class="line">// newBooks are now [&#x27;Positioning by Trout&#x27;, &#x27;War by Green&#x27;, &#x27;HWFIF // by Carnegie&#x27;]</span><br></pre></td></tr></table></figure>

<h2 id="五、为对象新增一组键值对"><a href="#五、为对象新增一组键值对" class="headerlink" title="五、为对象新增一组键值对"></a>五、为对象新增一组键值对</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const user = &#123;name: &#x27;Shivek Khurana&#x27;&#125;;</span><br><span class="line">const updatedUser = &#123;...user, age: 23&#125;;</span><br><span class="line">//updatedUser的值为：&#123;name: &#x27;Shivek Khurana&#x27;, age: 23&#125;</span><br></pre></td></tr></table></figure>

<h2 id="六、使用变量作为键名为对象添加键值对"><a href="#六、使用变量作为键名为对象添加键值对" class="headerlink" title="六、使用变量作为键名为对象添加键值对"></a>六、使用变量作为键名为对象添加键值对</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const dynamicKey = &#x27;wearsSpectacles&#x27;;</span><br><span class="line">const user = &#123;name: &#x27;Shivek Khurana&#x27;&#125;;</span><br><span class="line">const updatedUser = &#123;...user, [dynamicKey]: true&#125;;</span><br><span class="line">// updatedUser is &#123;name: &#x27;Shivek Khurana&#x27;, wearsSpectacles: true&#125;</span><br></pre></td></tr></table></figure>

<h2 id="七、修改数组中满足条件的元素对象"><a href="#七、修改数组中满足条件的元素对象" class="headerlink" title="七、修改数组中满足条件的元素对象"></a>七、修改数组中满足条件的元素对象</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const posts = [</span><br><span class="line">  &#123;id: 1, title: &#x27;Title 1&#x27;&#125;,</span><br><span class="line">  &#123;id: 2, title: &#x27;Title 2&#x27;&#125;</span><br><span class="line">];</span><br><span class="line">const updatedPosts = posts.map(p =&gt; p.id !== 1 ?</span><br><span class="line">  p : &#123;...p, title: &#x27;Updated Title 1&#x27;&#125;</span><br><span class="line">);</span><br><span class="line">/*</span><br><span class="line">updatedPosts is now </span><br><span class="line">[</span><br><span class="line">  &#123;id: 1, title: &#x27;Updated Title 1&#x27;&#125;,</span><br><span class="line">  &#123;id: 2, title: &#x27;Title 2&#x27;&#125;</span><br><span class="line">];</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<h2 id="八、找出数组中满足条件的元素"><a href="#八、找出数组中满足条件的元素" class="headerlink" title="八、找出数组中满足条件的元素"></a>八、找出数组中满足条件的元素</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const posts = [</span><br><span class="line">  &#123;id: 1, title: &#x27;Title 1&#x27;&#125;,</span><br><span class="line">  &#123;id: 2, title: &#x27;Title 2&#x27;&#125;</span><br><span class="line">];</span><br><span class="line">const postInQuestion = posts.find(p =&gt; p.id === 2);</span><br><span class="line">// postInQuestion now holds &#123;id: 2, title: &#x27;Title 2&#x27;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="九、删除目标对象的一组属性"><a href="#九、删除目标对象的一组属性" class="headerlink" title="九、删除目标对象的一组属性"></a>九、删除目标对象的一组属性</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//方法一</span><br><span class="line">const user = &#123;name: &#x27;Shivek Khurana&#x27;, age: 23, password: &#x27;SantaCl@use&#x27;&#125;;</span><br><span class="line">const userWithoutPassword = Object.keys(user)</span><br><span class="line">  .filter(key =&gt; key !== &#x27;password&#x27;)</span><br><span class="line">  .map(key =&gt; &#123;[key]: user[key]&#125;)</span><br><span class="line">  .reduce((accumulator, current) =&gt; </span><br><span class="line">    (&#123;...accumulator, ...current&#125;),</span><br><span class="line">    &#123;&#125;</span><br><span class="line">  )</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">// 方法二</span><br><span class="line">const user = &#123;name: &#x27;Shivek Khurana&#x27;, age: 23, password: &#x27;SantaCl@use&#x27;&#125;;</span><br><span class="line">const userWithoutPassword = ((&#123;name, age&#125;) =&gt; (&#123;name, age&#125;))(user);</span><br><span class="line"></span><br><span class="line">// userWithoutPassword becomes &#123;name: &#x27;Shivek Khurana&#x27;, age: 23&#125;</span><br></pre></td></tr></table></figure>

<h2 id="十、将对象转化成请求串"><a href="#十、将对象转化成请求串" class="headerlink" title="十、将对象转化成请求串"></a>十、将对象转化成请求串</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const params = &#123;color: &#x27;red&#x27;, minPrice: 8000, maxPrice: 10000&#125;;</span><br><span class="line">const query = &#x27;?&#x27; + Object.keys(params)</span><br><span class="line">  .map(k =&gt;   </span><br><span class="line">    encodeURIComponent(k) + &#x27;=&#x27; + encodeURIComponent(params[k])</span><br><span class="line">  )</span><br><span class="line">  .join(&#x27;&amp;&#x27;)</span><br><span class="line">;</span><br><span class="line">// encodeURIComponent将对特殊字符进行编码。</span><br><span class="line">// query is now &quot;color=red&amp;minPrice=8000&amp;maxPrice=10000&quot;</span><br></pre></td></tr></table></figure>

<h2 id="十一、获取数组中某一对象的下标"><a href="#十一、获取数组中某一对象的下标" class="headerlink" title="十一、获取数组中某一对象的下标"></a>十一、获取数组中某一对象的下标</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const posts = [</span><br><span class="line">  &#123;id: 13, title: &#x27;Title 221&#x27;&#125;,</span><br><span class="line">  &#123;id: 5, title: &#x27;Title 102&#x27;&#125;,</span><br><span class="line">  &#123;id: 131, title: &#x27;Title 18&#x27;&#125;,</span><br><span class="line">  &#123;id: 55, title: &#x27;Title 234&#x27;&#125;</span><br><span class="line">];</span><br><span class="line">// 找到id为131的元素</span><br><span class="line">const requiredIndex = posts.findIndex(obj=&gt;obj.id===131);</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/02/15/html+css+js+ts/3-js%E6%95%B0%E6%8D%AE%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95/" data-id="cl7k9sbhf00b498u059djd0f9" data-title="js 常用操作" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/" rel="tag">javascript</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-html+css+js+ts/3-js-事件绑定、事件监听、事件委托" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/02/13/html+css+js+ts/3-js-%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A%E3%80%81%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E3%80%81%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/" class="article-date">
  <time class="dt-published" datetime="2018-02-13T01:45:35.000Z" itemprop="datePublished">2018-02-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/02/13/html+css+js+ts/3-js-%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A%E3%80%81%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E3%80%81%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/">js事件绑定、事件监听、事件委托</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><blockquote>
<p>事件流是一个事件沿着特定数据结构传播的过程。冒泡和捕获是事件流在<code>DOM</code>中两种不同的传播方法</p>
</blockquote>
<p><strong>事件流有三个阶段</strong></p>
<ul>
<li>事件捕获阶段</li>
<li>处于目标阶段</li>
<li>事件冒泡阶段</li>
</ul>
<p><strong>事件捕获</strong></p>
<blockquote>
<p>事件捕获（<code>event capturing</code>）：通俗的理解就是，当鼠标点击或者触发<code>dom</code>事件时，浏览器会从根节点开始由外到内进行事件传播，即点击了子元素，如果父元素通过事件捕获方式注册了对应的事件的话，会先触发父元素绑定的事件</p>
</blockquote>
<p><strong>事件冒泡</strong></p>
<blockquote>
<p>事件冒泡（dubbed bubbling）：与事件捕获恰恰相反，事件冒泡顺序是由内到外进行事件传播，直到根节点</p>
</blockquote>
<p>无论是事件捕获还是事件冒泡，它们都有一个共同的行为，就是事件传播</p>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/319.png" alt="img"></p>
<h2 id="二、捕获和冒泡"><a href="#二、捕获和冒泡" class="headerlink" title="二、捕获和冒泡"></a>二、捕获和冒泡</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;div1&quot;&gt;</span><br><span class="line">  &lt;div id=&quot;div2&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    let div1 = document.getElementById(&#x27;div1&#x27;);</span><br><span class="line">    let div2 = document.getElementById(&#x27;div2&#x27;);</span><br><span class="line">    </span><br><span class="line">    div1.onClick = function()&#123;</span><br><span class="line">        alert(&#x27;1&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    div2.onClick = function()&#123;</span><br><span class="line">        alert(&#x27;2&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当点击 <code>div2</code>时，会弹出两个弹出框。在 <code>ie8/9/10</code>、<code>chrome</code>浏览器，会先弹出”2”再弹出“1”，这就是事件冒泡：事件从最底层的节点向上冒泡传播。事件捕获则跟事件冒泡相反</p>
</blockquote>
<blockquote>
<p>W3C的标准是先捕获再冒泡， <code>addEventListener</code>的第三个参数决定把事件注册在捕获（<code>true</code>）还是冒泡(<code>false</code>)</p>
</blockquote>
<h2 id="三、事件对象"><a href="#三、事件对象" class="headerlink" title="三、事件对象"></a>三、事件对象</h2><p><img src="https://poetries1.gitee.io/img-repo/2019/10/320.png" alt="img"></p>
<h2 id="四、事件流阻止"><a href="#四、事件流阻止" class="headerlink" title="四、事件流阻止"></a>四、事件流阻止</h2><blockquote>
<p>在一些情况下需要阻止事件流的传播，阻止默认动作的发生</p>
</blockquote>
<ul>
<li><code>event.preventDefault()</code>：取消事件对象的默认动作以及继续传播。</li>
<li><code>event.stopPropagation()/ event.cancelBubble = true</code>：阻止事件冒泡。</li>
</ul>
<p><strong>事件的阻止在不同浏览器有不同处理</strong></p>
<ul>
<li>在<code>IE</code>下使用 <code>event.returnValue= false</code>，</li>
<li>在非<code>IE</code>下则使用 <code>event.preventDefault()</code>进行阻止</li>
</ul>
<p><strong>preventDefault与stopPropagation的区别</strong></p>
<ul>
<li><code>preventDefault</code>告诉浏览器不用执行与事件相关联的默认动作（如表单提交）</li>
<li><code>stopPropagation</code>是停止事件继续冒泡，但是对IE9以下的浏览器无效</li>
</ul>
<h2 id="五、事件注册"><a href="#五、事件注册" class="headerlink" title="五、事件注册"></a>五、事件注册</h2><ul>
<li>通常我们使用 <code>addEventListener</code> 注册事件，该函数的第三个参数可以是布尔值，也可以是对象。对于布尔值 <code>useCapture</code> 参数来说，该参数默认值为 <code>false</code>。<code>useCapture</code> 决定了注册的事件是捕获事件还是冒泡事件</li>
<li>一般来说，我们只希望事件只触发在目标上，这时候可以使用 <code>stopPropagation</code> 来阻止事件的进一步传播。通常我们认为 <code>stopPropagation</code> 是用来阻止事件冒泡的，其实该函数也可以阻止捕获事件。<code>stopImmediatePropagation</code> 同样也能实现阻止事件，但是还能阻止该事件目标执行别的注册事件</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">node.addEventListener(&#x27;click&#x27;,(event) =&gt;&#123;</span><br><span class="line">	event.stopImmediatePropagation()</span><br><span class="line">	console.log(&#x27;冒泡&#x27;)</span><br><span class="line">&#125;,false);</span><br><span class="line">// 点击 node 只会执行上面的函数，该函数不会执行</span><br><span class="line">node.addEventListener(&#x27;click&#x27;,(event) =&gt; &#123;</span><br><span class="line">	console.log(&#x27;捕获 &#x27;)</span><br><span class="line">&#125;,true)</span><br></pre></td></tr></table></figure>

<h2 id="六、事件委托"><a href="#六、事件委托" class="headerlink" title="六、事件委托"></a>六、事件委托</h2><ul>
<li>在<code>js</code>中性能优化的其中一个主要思想是减少<code>dom</code>操作。</li>
<li>事件委托就是利用冒泡的原理，把事件加到父元素或祖先元素上，触发执行效果</li>
<li>提高JavaScript性能。事件委托可以显著的提高事件的处理速度，减少内存的占用</li>
</ul>
<blockquote>
<p>假设有<code>100</code>个<code>li</code>，每个<code>li</code>有相同的点击事件。如果为每<code>个Li</code>都添加事件，则会造成<code>dom</code>访问次数过多，引起浏览器重绘与重排的次数过多，性能则会降低。<br>使用事件委托则可以解决这样的问题</p>
</blockquote>
<p><strong>原理</strong></p>
<blockquote>
<p>实现事件委托是利用了事件的冒泡原理实现的。当我们为最外层的节点添加点击事件，那么里面的<code>ul</code>、<code>li</code>、<code>a</code>的点击事件都会冒泡到最外层节点上，委托它代为执行事件</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul id=&quot;ul&quot;&gt;</span><br><span class="line">    &lt;li&gt;1&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;2&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;3&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">window.onload = function()&#123;</span><br><span class="line">    var ulEle = document.getElementById(&#x27;ul&#x27;);</span><br><span class="line">    ul.onclick = function(ev)&#123;</span><br><span class="line">        //兼容IE</span><br><span class="line">        ev = ev || window.event;</span><br><span class="line">        var target = ev.target || ev.srcElement;</span><br><span class="line">        </span><br><span class="line">        if(target.nodeName.toLowerCase() == &#x27;li&#x27;)&#123;</span><br><span class="line">            alert( target.innerHTML);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/02/13/html+css+js+ts/3-js-%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A%E3%80%81%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E3%80%81%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/" data-id="cl7k9sbh300a298u0c4ku9suh" data-title="js事件绑定、事件监听、事件委托" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/" rel="tag">javascript</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-html+css+js+ts/3-js深浅拷贝" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/02/12/html+css+js+ts/3-js%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/" class="article-date">
  <time class="dt-published" datetime="2018-02-12T06:35:26.000Z" itemprop="datePublished">2018-02-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/02/12/html+css+js+ts/3-js%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/">js深浅拷贝</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><blockquote>
<p>在<code>js</code>中，变量的类型可以大致分成两种：基本数据类型和引用数据类型，其中基本数据类型指的是简单的数据段，包括：</p>
</blockquote>
<ul>
<li><code>undefined</code></li>
<li><code>Null</code></li>
<li><code>Boolean</code></li>
<li><code>Number</code></li>
<li><code>String</code>(字符串在一些其他语言中是被当做对象使用的，属于引用类型，但在<code>js</code>里是基本类型)</li>
</ul>
<blockquote>
<p>而引用类型的值指的是可能包含多个值的对象。本质上，是因为基本数据类型保存在栈内存,而引用类型保存在堆内存中。为什么要分两种保存方式呢？ 根本原因在于保存在栈内存的必须是大小固定的数据，引用类型的大小不固定，只能保存在堆内存中，但是我们可以把它的地址写在占内存中以供我们访问</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a = 1;//定义了一个number类型</span><br><span class="line">var obj1 = &#123;//定义了一个objr类型</span><br><span class="line">    name:&#x27;obj&#x27;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在执行这段代码后，内存空间里是这样的</p>
</blockquote>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/314.png" alt="img"></p>
<blockquote>
<p>因为这种保存方式的存在，所以我们在操作变量的时候，如果是基本数据类型，则按值访问，操作的就是变量保存的值；如果是引用类型的值，我们只是通过保存在变量中的引用类型的地址类操作实际对象。从而也引出了所谓的深浅复制问题</p>
</blockquote>
<h2 id="二、浅拷贝"><a href="#二、浅拷贝" class="headerlink" title="二、浅拷贝"></a>二、浅拷贝</h2><p><strong>方法一</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 假设有两个对象</span><br><span class="line"></span><br><span class="line">var objA = &#123;</span><br><span class="line">  a: &#x27;aa&#x27;,</span><br><span class="line">  b: &#x27;bb&#x27;</span><br><span class="line">&#125;;</span><br><span class="line">var objB = &#123;&#125;;</span><br><span class="line">// 现在想把对象A的值复制给B，由于对象A的两个值都是原始类型，用浅复制即可</span><br><span class="line"></span><br><span class="line">function copy(sub, sup) &#123;</span><br><span class="line">  for (var key in sup) &#123;</span><br><span class="line">    sub[key] = sup[key];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">copy(objB, objA);</span><br></pre></td></tr></table></figure>

<p><strong>方法二</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object.assign() (兼容性不好)</span><br></pre></td></tr></table></figure>

<p><strong>方法三</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_.clone()</span><br></pre></td></tr></table></figure>

<p><strong>方法四</strong></p>
<blockquote>
<p>数组中<code>concat</code>和<code>slice</code>方法</p>
</blockquote>
<p><strong>方法五</strong></p>
<blockquote>
<p>ES6展开运算</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&#123;name:&#x27;poetries&#x27;,age:22&#125;]</span><br><span class="line"></span><br><span class="line">var target = [...arr]</span><br></pre></td></tr></table></figure>

<h2 id="三、深拷贝"><a href="#三、深拷贝" class="headerlink" title="三、深拷贝"></a>三、深拷贝</h2><blockquote>
<p>简单来说深复制就是当遇到值是对象类型的时候就再运行一遍复制</p>
</blockquote>
<p><strong>方法一 JSON.parse(JSON.stringify(obj))</strong></p>
<blockquote>
<p>简单粗暴又有点<code>dirty</code>，但是能满足日常需求，只能处理<code>json</code>能理解的数据格式，当然不包括函数了，性能也没有特别好</p>
</blockquote>
<p><strong>方法二 lodash —— _.cloneDeep()</strong></p>
<blockquote>
<p>很好地兼容了ES6的新引用类型，而且处理了环型对象的情况</p>
</blockquote>
<p><strong>方法三 jQuery —— $.clone() &#x2F; $.extend()</strong></p>
<blockquote>
<p>源码适合初学者学习，比较好理解</p>
</blockquote>
<p><strong>方法四 自己实现一个</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function deepCopy (obj) &#123;</span><br><span class="line">    var result;</span><br><span class="line"></span><br><span class="line">    //引用类型分数组和对象分别递归</span><br><span class="line">    if (Object.prototype.toString.call(obj) == &#x27;[object Array]&#x27;) &#123;</span><br><span class="line">      result = []</span><br><span class="line">      for (i = 0; i &lt; obj.length; i++) &#123;</span><br><span class="line">        result[i] = deepCopy(obj[i])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else if (Object.prototype.toString.call(obj) == &#x27;[object Object]&#x27;) &#123;</span><br><span class="line">      result = &#123;&#125;</span><br><span class="line">      for (var attr in obj) &#123;</span><br><span class="line">        result[attr] = deepCopy(obj[attr])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //值类型直接返回</span><br><span class="line">    else &#123;</span><br><span class="line">      return obj</span><br><span class="line">    &#125;</span><br><span class="line">    return result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/02/12/html+css+js+ts/3-js%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/" data-id="cl7k9sbhf00b198u07sumhajg" data-title="js深浅拷贝" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/" rel="tag">javascript</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-html+css+js+ts/3-js内存泄漏和垃圾回收机制" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/02/09/html+css+js+ts/3-js%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%92%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/" class="article-date">
  <time class="dt-published" datetime="2018-02-09T02:16:24.000Z" itemprop="datePublished">2018-02-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/02/09/html+css+js+ts/3-js%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%92%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/">3-js内存泄漏和垃圾回收机制</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="什么是内存泄漏？"><a href="#什么是内存泄漏？" class="headerlink" title="什么是内存泄漏？"></a>什么是内存泄漏？</h2><ul>
<li>程序的运行需要内存，只要程序提出要求，操作系统或者运行是就必须供给内存</li>
<li>对于持续运行的服务进程，必须及时释放内存，否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃</li>
<li>不再用到的内存，没有及时释放，就叫做内存泄漏。</li>
<li>有些语言（比如c语言）必须手动释放内存，程序员负责内存管理</li>
<li>这很麻烦，所以大多数语言提供自动内存管理，减轻程序员的负担，这被称为”垃圾回收机制”。</li>
</ul>
<blockquote>
<p>javascript垃圾回收机制原理：解决内存的泄露，垃圾回收机制会定期（周期性）找出那些不再用到的内存（变量），然后释放其内存。</p>
</blockquote>
<h2 id="垃圾回收的必要性"><a href="#垃圾回收的必要性" class="headerlink" title="垃圾回收的必要性"></a>垃圾回收的必要性</h2><blockquote>
<p>由于字符串、对象和数组没有固定大小，所有当他们的大小已知时，才能对他们进行动态的存储分配。JavaScript程序每次创建字符串、数组或对象时，解释器都必须分配内存来存储那个实体。只要像这样动态地分配了内存，最终都要释放这些内存以便他们能够被再用，否则，JavaScript的解释器将会消耗完系统中所有可用的内存，造成系统崩溃</p>
</blockquote>
<p>这段话解释了为什么需要系统需要垃圾回收，JS不像C&#x2F;C++，他有自己的一套垃圾回收机制（Garbage Collection）。JavaScript的解释器可以检测到何时程序不再使用一个对象了，当他确定了一个对象是无用的时候，他就知道不再需要这个对象，可以把它所占用的内存释放掉了。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a = &quot;before&quot;;</span><br><span class="line">var b = &quot;override a&quot;;</span><br><span class="line">var a = b; //重写a</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这段代码运行之后，“before”这个字符串失去了引用（之前是被a引用），系统检测到这个事实之后，就会释放该字符串的存储空间以便这些空间可以被再利用。</p>
</blockquote>
<h2 id="垃圾回收原理"><a href="#垃圾回收原理" class="headerlink" title="垃圾回收原理"></a>垃圾回收原理</h2><blockquote>
<p>现在各大浏览器通常用采用的垃圾回收有两种方法：<strong>标记清除</strong>、<strong>引用计数</strong></p>
</blockquote>
<h3 id="策略1：标记清除"><a href="#策略1：标记清除" class="headerlink" title="策略1：标记清除"></a>策略1：标记清除</h3><blockquote>
<p>这是javascript中最常用的垃圾回收方式。当变量进入执行环境是，就标记这个变量为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到他们。当变量离开环境时，则将其标记为“离开环境”。</p>
</blockquote>
<p>垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记。然后，它会去掉环境中的变量以及被环境中的变量引用的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后。垃圾收集器完成内存清除工作，销毁那些带标记的值，并回收他们所占用的内存空间</p>
<ul>
<li>垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记</li>
<li>去掉环境中的变量以及被环境中的变量引用的变量的标记</li>
<li>此后再被加上标记的变量将被视为准备删除的变量，因为环境中的变量已经无法访问到这些变量了</li>
</ul>
<h3 id="策略2：引用计数"><a href="#策略2：引用计数" class="headerlink" title="策略2：引用计数"></a>策略2：引用计数</h3><blockquote>
<p>语言引擎有一张”引用表”，保存了内存里面所有资源（通常是各种值）的引用次数。如果一个值的引用次数是0，就表示这个值不再用到了，因此可以将这块内存释放。</p>
</blockquote>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2017/bg2017041703.png" alt="img"></p>
<p>上图中，左下角的两个值，没有任何引用，所以可以释放</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const arr = [1,2,3,4];</span><br><span class="line">console.log(&quot;hello world&quot;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面的代码中，数组<code>[1,2,3,4]</code>是一个值，会占用内存。变量arr是仅有的对这个值的引用，因此引用次数为1。尽管后面的代码没有用到arr，它是会持续占用内存</p>
</blockquote>
<p>如果增加一行代码，解除arr对<code>[1,2,3,4]</code>引用，这块内存就可以被垃圾回收机制释放了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1,2,3,4];</span><br><span class="line">console.log(&quot;hello world&quot;);</span><br><span class="line">arr = null;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面代码中，arr重置为null，就解除了对<code>[1，2，3，4]</code>的引用，引用次数变成了0，内存就可以释放出来了。</p>
</blockquote>
<blockquote>
<p>因此，并不是说有了垃圾回收机制，程序员就轻松了。你还是需要关注内存占用：那些很占空间的值，一旦不再用到，你必须检查是否还存在对它们的引用。如果是的话，就必须手动解除引用</p>
</blockquote>
<p>再来下面来看看代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function problem() &#123;</span><br><span class="line">    var objA = new Object();</span><br><span class="line">    var objB = new Object();</span><br><span class="line"></span><br><span class="line">    objA.someOtherObject = objB;</span><br><span class="line">    objB.anotherObject = objA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在这个例子中，objA和objB通过各自的属性相互引用；也就是说这两个对象的引用次数都是2。在采用引用计数的策略中，由于函数执行之后，这两个对象都离开了作用域，函数执行完成之后，objA和objB还将会继续存在，因为他们的引用次数永远不会是0。这样的相互引用如果说很大量的存在就会导致大量的内存泄露</p>
</blockquote>
<p>不过上面的问题也不是不能解决，我们可以手动切断他们的循环引用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">myObj.element = null;</span><br><span class="line">element.someObject =null;</span><br></pre></td></tr></table></figure>

<p>这样写代码的话就可以解决循环引用的问题了，也就防止了内存泄露的问题。</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><blockquote>
<p>如果存在循环引用的情况，那么这个引用值占的空间就永远不会被回收。</p>
</blockquote>
<h2 id="面试回答"><a href="#面试回答" class="headerlink" title="面试回答"></a>面试回答</h2><h3 id="什么是垃圾"><a href="#什么是垃圾" class="headerlink" title="什么是垃圾"></a>什么是垃圾</h3><blockquote>
<p>一般来说没有被引用的对象就是垃圾，就是要被清除，有个例外如果几个对象引用形成一个环，互相引用，但根访问不到它们，这几个对象也是垃圾，也要被清除。</p>
</blockquote>
<h3 id="如何检垃圾"><a href="#如何检垃圾" class="headerlink" title="如何检垃圾"></a>如何检垃圾</h3><ul>
<li>一种算法是标记 标记-清除 算法</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/02/09/html+css+js+ts/3-js%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%92%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/" data-id="cl7k9sbh800aj98u0gxn89sck" data-title="3-js内存泄漏和垃圾回收机制" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/" rel="tag">javascript</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-html+css+js+ts/1-移动端适配" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/02/07/html+css+js+ts/1-%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D/" class="article-date">
  <time class="dt-published" datetime="2018-02-07T14:33:28.000Z" itemprop="datePublished">2018-02-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>►<a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/%E7%A7%BB%E5%8A%A8%E7%AB%AF/">移动端</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/02/07/html+css+js+ts/1-%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D/">移动端像素比调试</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <ul>
<li>物理像素:移动端设备的分辨率</li>
<li>独立像素:css的像素 320 375</li>
<li>像素比 &#x3D; 物理像素&#x2F;独立像素</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0&quot;&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>width=device-width</code> 设备宽度 <code>640px</code>(低版本的安卓手机不支持数字) 这个属性在不支持<code>IE</code></li>
<li><code>initial-scale=1.0</code>(初始缩放比),能够起到和<code>width=device-width</code>相同的效果(把理想的视窗设置为设备的宽度) 两个配合使用就能够很好的解决移动端各设备的适配问题</li>
<li><code>maximum-scale=1.0</code>最大缩放比例</li>
<li><code>user-scalable=0</code>禁止缩放</li>
<li><code>minimum-scale=1.0</code> 最小缩放比例</li>
</ul>
<h3 id="移动端布局方法"><a href="#移动端布局方法" class="headerlink" title="移动端布局方法"></a>移动端布局方法</h3><hr>
<ul>
<li>1、流式布局 与设备等宽 做自适应 100%或者具体的像素值</li>
<li>2、<code>rem</code>做盒子的宽度，viewport缩放</li>
<li>3、固定宽度 <code>viewport</code>缩放<code>content=&quot;width=640, initial-scale=0.5, maximum-scale=0.5, user-scalable=0&quot;</code>（用的比较少）</li>
<li>4、<code>vw/vh</code> 相对于viewport理想视窗(设备)的比例(兼容性不好)<br><code>1vw = 10%</code>设备宽 <code>10vw</code></li>
</ul>
<h3 id="meta标签属性设置"><a href="#meta标签属性设置" class="headerlink" title="meta标签属性设置"></a>meta标签属性设置</h3><hr>
<meta http-equiv="X-UA-Compatible" content="IE=edge chrome=1">

<ul>
<li>IE8<code>浏览器的显示方式:</code>IE&#x3D;edge<code>以</code>IE&#96;最高版本显示</li>
<li>chrome&#x3D;1 以谷歌浏览器模式渲染(GCF(Google Chrome Frame))</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;referrer&quot; content=&quot;never&quot;&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>referrer 告诉浏览器链接来源于哪里(计算网页上链接的访问量)</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no,email=no,adress=no&quot;&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>格式检测:（数字、邮箱、地址） no不识别为电话号码、邮箱、地址</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot;&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>删除默认的苹果工具栏、菜单栏(全屏显示)</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;apple-touch-fullscreen&quot; =&quot;yes&quot;&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>全屏显示</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black&quot;&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>设置app应用下状态条的颜色</li>
<li>默认值default (白色) black（黑色）</li>
<li><code>black-translucent</code>（灰色半透明）若果设置为这个值会占据页面的<code>px</code>位置浮在页面上方<code>20px</code>高度 <code>iphone4</code>是<code>40px</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot;&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>360</code>模式固定为极速模式</li>
</ul>
<h3 id="常见的meta属性"><a href="#常见的meta属性" class="headerlink" title="常见的meta属性"></a>常见的meta属性</h3><hr>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no&quot;&gt;</span><br><span class="line">&lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot;&gt;</span><br><span class="line">&lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black&quot;&gt;</span><br><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0，minimum-scale=1.0&quot;&gt;</span><br></pre></td></tr></table></figure>

<h3 id="link-扩展"><a href="#link-扩展" class="headerlink" title="link 扩展"></a>link 扩展</h3><hr>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=&quot;dns-prefetch&quot; href=&quot;xxx.com&quot;&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>预解析技术，当浏览网页时，浏览器会在加载页面的时对页面中的域名进行解析缓存，当我们点击这些网页的链接时就不需要再进行DNS的解析，减少用户的等待时间，提高用户的体验度</p>
</blockquote>
<ul>
<li><code>rem</code> 根目录 <code>html</code> 的<code>font-size</code>尺寸默认为<code>16px</code> <code>1rem = 16px;</code></li>
<li><code>1rem = html</code>的<code>font-size</code>的尺寸大小</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/02/07/html+css+js+ts/1-%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D/" data-id="cl7k9sbgm007y98u02y2836l4" data-title="移动端像素比调试" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/html/" rel="tag">html</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/" rel="tag">移动端</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/20/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/19/">19</a><a class="page-number" href="/page/20/">20</a><span class="page-number current">21</span><a class="page-number" href="/page/22/">22</a><a class="page-number" href="/page/23/">23</a><a class="page-number" href="/page/24/">24</a><a class="extend next" rel="next" href="/page/22/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/React/">React</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/css/">css</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/http/">http</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/javascript/">javascript</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/liunx/">liunx</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/%E7%A7%BB%E5%8A%A8%E7%AB%AF/">移动端</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/%E9%97%AE%E9%A2%98/">问题</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/%E9%9F%B3%E8%A7%86%E9%A2%91/">音视频</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/">前端工程化</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">前端性能优化</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%8E%9F%E7%90%86/">原理</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%8E%9F%E7%90%86/React/">React</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%90%8E%E7%AB%AF/">后端</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%90%8E%E7%AB%AF/%E7%AE%97%E6%B3%95/">算法</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/">小程序</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B7%A5%E5%85%B7/">工具</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BE%AE%E5%89%8D%E7%AB%AF/">微前端</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/">数据可视化</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/">架构模式</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/%E6%A1%86%E6%9E%B6/">框架</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%A1%86%E6%9E%B6/">框架</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%A1%86%E6%9E%B6/React/">React</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">正则表达式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/">浏览器</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%88%AC%E8%99%AB/">爬虫</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Event-Loop/" rel="tag">Event Loop</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Graphviz/" rel="tag">Graphviz</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mock/" rel="tag">Mock</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Promise/" rel="tag">Promise</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RESTful/" rel="tag">RESTful</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React/" rel="tag">React</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redux/" rel="tag">Redux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/async-await/" rel="tag">async&#x2F;await</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/css/" rel="tag">css</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/echart/" rel="tag">echart</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/es6/" rel="tag">es6</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/eslint/" rel="tag">eslint</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/" rel="tag">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/glup/" rel="tag">glup</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/" rel="tag">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/html/" rel="tag">html</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/http/" rel="tag">http</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javascript/" rel="tag">javascript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mongodb/" rel="tag">mongodb</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nginx/" rel="tag">nginx</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/" rel="tag">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/qiankun/" rel="tag">qiankun</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/react/" rel="tag">react</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/typescript/" rel="tag">typescript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vs-code/" rel="tag">vs code</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vue/" rel="tag">vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vue3/" rel="tag">vue3</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/webpack/" rel="tag">webpack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/xml/" rel="tag">xml</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BC%98%E5%8C%96/" rel="tag">优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/" rel="tag">小程序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8A%93%E5%8C%85/" rel="tag">抓包</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" rel="tag">正则表达式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/" rel="tag">浏览器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/" rel="tag">移动端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Event-Loop/" style="font-size: 10px;">Event Loop</a> <a href="/tags/Graphviz/" style="font-size: 10px;">Graphviz</a> <a href="/tags/Mock/" style="font-size: 10px;">Mock</a> <a href="/tags/Promise/" style="font-size: 10px;">Promise</a> <a href="/tags/RESTful/" style="font-size: 10px;">RESTful</a> <a href="/tags/React/" style="font-size: 19.29px;">React</a> <a href="/tags/Redux/" style="font-size: 11.43px;">Redux</a> <a href="/tags/async-await/" style="font-size: 10px;">async/await</a> <a href="/tags/css/" style="font-size: 13.57px;">css</a> <a href="/tags/echart/" style="font-size: 10px;">echart</a> <a href="/tags/es6/" style="font-size: 16.43px;">es6</a> <a href="/tags/eslint/" style="font-size: 10px;">eslint</a> <a href="/tags/git/" style="font-size: 15.71px;">git</a> <a href="/tags/glup/" style="font-size: 10.71px;">glup</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/html/" style="font-size: 14.29px;">html</a> <a href="/tags/http/" style="font-size: 17.14px;">http</a> <a href="/tags/javascript/" style="font-size: 18.57px;">javascript</a> <a href="/tags/mongodb/" style="font-size: 10px;">mongodb</a> <a href="/tags/mysql/" style="font-size: 10px;">mysql</a> <a href="/tags/nginx/" style="font-size: 10.71px;">nginx</a> <a href="/tags/python/" style="font-size: 10.71px;">python</a> <a href="/tags/qiankun/" style="font-size: 10px;">qiankun</a> <a href="/tags/react/" style="font-size: 10px;">react</a> <a href="/tags/typescript/" style="font-size: 12.14px;">typescript</a> <a href="/tags/vs-code/" style="font-size: 11.43px;">vs code</a> <a href="/tags/vue/" style="font-size: 20px;">vue</a> <a href="/tags/vue3/" style="font-size: 10px;">vue3</a> <a href="/tags/webpack/" style="font-size: 17.86px;">webpack</a> <a href="/tags/xml/" style="font-size: 10px;">xml</a> <a href="/tags/%E4%BC%98%E5%8C%96/" style="font-size: 13.57px;">优化</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 10.71px;">前端</a> <a href="/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/" style="font-size: 15px;">小程序</a> <a href="/tags/%E6%8A%93%E5%8C%85/" style="font-size: 10px;">抓包</a> <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 10px;">操作系统</a> <a href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" style="font-size: 10px;">正则表达式</a> <a href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/" style="font-size: 12.86px;">浏览器</a> <a href="/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/" style="font-size: 10.71px;">移动端</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 10px;">算法</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">April 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">January 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">October 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">September 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">July 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">June 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/04/12/%E5%BE%AE%E5%89%8D%E7%AB%AF/qiankun%E5%BE%AE%E5%89%8D%E7%AB%AF/">qiankun微前端</a>
          </li>
        
          <li>
            <a href="/2022/01/12/%E5%B7%A5%E5%85%B7/git-stach/">git-stach</a>
          </li>
        
          <li>
            <a href="/2021/10/16/Vue/vue3%E4%BC%98%E5%8C%96/">vue3优化</a>
          </li>
        
          <li>
            <a href="/2021/10/11/Vue/Vue3-%E8%AE%BE%E8%AE%A1%E7%9B%AE%E6%A0%87%E3%80%81%E5%81%9A%E4%BA%86%E5%93%AA%E4%BA%9B%E4%BC%98%E5%8C%96/">Vue3-设计目标、做了哪些优化</a>
          </li>
        
          <li>
            <a href="/2021/09/29/Vue/vue3-Treeshaking/">vue3-Treeshaking</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>